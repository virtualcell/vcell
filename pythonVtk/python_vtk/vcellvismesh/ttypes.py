#
# Autogenerated by Thrift Compiler (0.18.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class Face(object):
    Xm = 0
    Xp = 1
    Ym = 2
    Yp = 3
    Zm = 4
    Zp = 5

    _VALUES_TO_NAMES = {
        0: "Xm",
        1: "Xp",
        2: "Ym",
        3: "Yp",
        4: "Zm",
        5: "Zp",
    }

    _NAMES_TO_VALUES = {
        "Xm": 0,
        "Xp": 1,
        "Ym": 2,
        "Yp": 3,
        "Zm": 4,
        "Zp": 5,
    }


class Vect3D(object):
    """
    Attributes:
     - x
     - y
     - z

    """


    def __init__(self, x=None, y=None, z=None,):
        self.x = x
        self.y = y
        self.z = z

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.x = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.y = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.z = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Vect3D')
        if self.x is not None:
            oprot.writeFieldBegin('x', TType.DOUBLE, 1)
            oprot.writeDouble(self.x)
            oprot.writeFieldEnd()
        if self.y is not None:
            oprot.writeFieldBegin('y', TType.DOUBLE, 2)
            oprot.writeDouble(self.y)
            oprot.writeFieldEnd()
        if self.z is not None:
            oprot.writeFieldBegin('z', TType.DOUBLE, 3)
            oprot.writeDouble(self.z)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.x is None:
            raise TProtocolException(message='Required field x is unset!')
        if self.y is None:
            raise TProtocolException(message='Required field y is unset!')
        if self.z is None:
            raise TProtocolException(message='Required field z is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VisPoint(object):
    """
    Attributes:
     - x
     - y
     - z

    """


    def __init__(self, x=None, y=None, z=None,):
        self.x = x
        self.y = y
        self.z = z

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.x = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.y = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.z = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VisPoint')
        if self.x is not None:
            oprot.writeFieldBegin('x', TType.DOUBLE, 1)
            oprot.writeDouble(self.x)
            oprot.writeFieldEnd()
        if self.y is not None:
            oprot.writeFieldBegin('y', TType.DOUBLE, 2)
            oprot.writeDouble(self.y)
            oprot.writeFieldEnd()
        if self.z is not None:
            oprot.writeFieldBegin('z', TType.DOUBLE, 3)
            oprot.writeDouble(self.z)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.x is None:
            raise TProtocolException(message='Required field x is unset!')
        if self.y is None:
            raise TProtocolException(message='Required field y is unset!')
        if self.z is None:
            raise TProtocolException(message='Required field z is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ChomboVolumeIndex(object):
    """
    Attributes:
     - level
     - boxNumber
     - boxIndex
     - fraction

    """


    def __init__(self, level=None, boxNumber=None, boxIndex=None, fraction=None,):
        self.level = level
        self.boxNumber = boxNumber
        self.boxIndex = boxIndex
        self.fraction = fraction

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.level = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.boxNumber = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.boxIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.fraction = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ChomboVolumeIndex')
        if self.level is not None:
            oprot.writeFieldBegin('level', TType.I32, 1)
            oprot.writeI32(self.level)
            oprot.writeFieldEnd()
        if self.boxNumber is not None:
            oprot.writeFieldBegin('boxNumber', TType.I32, 2)
            oprot.writeI32(self.boxNumber)
            oprot.writeFieldEnd()
        if self.boxIndex is not None:
            oprot.writeFieldBegin('boxIndex', TType.I32, 3)
            oprot.writeI32(self.boxIndex)
            oprot.writeFieldEnd()
        if self.fraction is not None:
            oprot.writeFieldBegin('fraction', TType.DOUBLE, 4)
            oprot.writeDouble(self.fraction)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.level is None:
            raise TProtocolException(message='Required field level is unset!')
        if self.boxNumber is None:
            raise TProtocolException(message='Required field boxNumber is unset!')
        if self.boxIndex is None:
            raise TProtocolException(message='Required field boxIndex is unset!')
        if self.fraction is None:
            raise TProtocolException(message='Required field fraction is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ChomboSurfaceIndex(object):
    """
    Attributes:
     - index

    """


    def __init__(self, index=None,):
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ChomboSurfaceIndex')
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 1)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.index is None:
            raise TProtocolException(message='Required field index is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MovingBoundarySurfaceIndex(object):
    """
    Attributes:
     - index

    """


    def __init__(self, index=None,):
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MovingBoundarySurfaceIndex')
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 1)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.index is None:
            raise TProtocolException(message='Required field index is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MovingBoundaryVolumeIndex(object):
    """
    Attributes:
     - index

    """


    def __init__(self, index=None,):
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MovingBoundaryVolumeIndex')
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 1)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.index is None:
            raise TProtocolException(message='Required field index is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FiniteVolumeIndex(object):
    """
    Attributes:
     - globalIndex
     - regionIndex

    """


    def __init__(self, globalIndex=None, regionIndex=None,):
        self.globalIndex = globalIndex
        self.regionIndex = regionIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.globalIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.regionIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FiniteVolumeIndex')
        if self.globalIndex is not None:
            oprot.writeFieldBegin('globalIndex', TType.I32, 1)
            oprot.writeI32(self.globalIndex)
            oprot.writeFieldEnd()
        if self.regionIndex is not None:
            oprot.writeFieldBegin('regionIndex', TType.I32, 2)
            oprot.writeI32(self.regionIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.globalIndex is None:
            raise TProtocolException(message='Required field globalIndex is unset!')
        if self.regionIndex is None:
            raise TProtocolException(message='Required field regionIndex is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VisPolygon(object):
    """
    Attributes:
     - pointIndices
     - chomboVolumeIndex
     - finiteVolumeIndex
     - movingBoundaryVolumeIndex

    """


    def __init__(self, pointIndices=None, chomboVolumeIndex=None, finiteVolumeIndex=None, movingBoundaryVolumeIndex=None,):
        self.pointIndices = pointIndices
        self.chomboVolumeIndex = chomboVolumeIndex
        self.finiteVolumeIndex = finiteVolumeIndex
        self.movingBoundaryVolumeIndex = movingBoundaryVolumeIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pointIndices = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI32()
                        self.pointIndices.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.chomboVolumeIndex = ChomboVolumeIndex()
                    self.chomboVolumeIndex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.finiteVolumeIndex = FiniteVolumeIndex()
                    self.finiteVolumeIndex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.movingBoundaryVolumeIndex = MovingBoundaryVolumeIndex()
                    self.movingBoundaryVolumeIndex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VisPolygon')
        if self.pointIndices is not None:
            oprot.writeFieldBegin('pointIndices', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.pointIndices))
            for iter6 in self.pointIndices:
                oprot.writeI32(iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.chomboVolumeIndex is not None:
            oprot.writeFieldBegin('chomboVolumeIndex', TType.STRUCT, 2)
            self.chomboVolumeIndex.write(oprot)
            oprot.writeFieldEnd()
        if self.finiteVolumeIndex is not None:
            oprot.writeFieldBegin('finiteVolumeIndex', TType.STRUCT, 3)
            self.finiteVolumeIndex.write(oprot)
            oprot.writeFieldEnd()
        if self.movingBoundaryVolumeIndex is not None:
            oprot.writeFieldBegin('movingBoundaryVolumeIndex', TType.STRUCT, 4)
            self.movingBoundaryVolumeIndex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pointIndices is None:
            raise TProtocolException(message='Required field pointIndices is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PolyhedronFace(object):
    """
    Attributes:
     - vertices

    """


    def __init__(self, vertices=None,):
        self.vertices = vertices

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.vertices = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readI32()
                        self.vertices.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PolyhedronFace')
        if self.vertices is not None:
            oprot.writeFieldBegin('vertices', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.vertices))
            for iter13 in self.vertices:
                oprot.writeI32(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.vertices is None:
            raise TProtocolException(message='Required field vertices is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VisIrregularPolyhedron(object):
    """
    Attributes:
     - polyhedronFaces
     - chomboVolumeIndex
     - finiteVolumeIndex

    """


    def __init__(self, polyhedronFaces=None, chomboVolumeIndex=None, finiteVolumeIndex=None,):
        self.polyhedronFaces = polyhedronFaces
        self.chomboVolumeIndex = chomboVolumeIndex
        self.finiteVolumeIndex = finiteVolumeIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.polyhedronFaces = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = PolyhedronFace()
                        _elem19.read(iprot)
                        self.polyhedronFaces.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.chomboVolumeIndex = ChomboVolumeIndex()
                    self.chomboVolumeIndex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.finiteVolumeIndex = FiniteVolumeIndex()
                    self.finiteVolumeIndex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VisIrregularPolyhedron')
        if self.polyhedronFaces is not None:
            oprot.writeFieldBegin('polyhedronFaces', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.polyhedronFaces))
            for iter20 in self.polyhedronFaces:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.chomboVolumeIndex is not None:
            oprot.writeFieldBegin('chomboVolumeIndex', TType.STRUCT, 2)
            self.chomboVolumeIndex.write(oprot)
            oprot.writeFieldEnd()
        if self.finiteVolumeIndex is not None:
            oprot.writeFieldBegin('finiteVolumeIndex', TType.STRUCT, 3)
            self.finiteVolumeIndex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.polyhedronFaces is None:
            raise TProtocolException(message='Required field polyhedronFaces is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VisVoxel(object):
    """
    Attributes:
     - pointIndices
     - chomboVolumeIndex
     - finiteVolumeIndex
     - movingBoundaryVolumeIndex

    """


    def __init__(self, pointIndices=None, chomboVolumeIndex=None, finiteVolumeIndex=None, movingBoundaryVolumeIndex=None,):
        self.pointIndices = pointIndices
        self.chomboVolumeIndex = chomboVolumeIndex
        self.finiteVolumeIndex = finiteVolumeIndex
        self.movingBoundaryVolumeIndex = movingBoundaryVolumeIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pointIndices = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iprot.readI32()
                        self.pointIndices.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.chomboVolumeIndex = ChomboVolumeIndex()
                    self.chomboVolumeIndex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.finiteVolumeIndex = FiniteVolumeIndex()
                    self.finiteVolumeIndex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.movingBoundaryVolumeIndex = MovingBoundaryVolumeIndex()
                    self.movingBoundaryVolumeIndex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VisVoxel')
        if self.pointIndices is not None:
            oprot.writeFieldBegin('pointIndices', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.pointIndices))
            for iter27 in self.pointIndices:
                oprot.writeI32(iter27)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.chomboVolumeIndex is not None:
            oprot.writeFieldBegin('chomboVolumeIndex', TType.STRUCT, 2)
            self.chomboVolumeIndex.write(oprot)
            oprot.writeFieldEnd()
        if self.finiteVolumeIndex is not None:
            oprot.writeFieldBegin('finiteVolumeIndex', TType.STRUCT, 3)
            self.finiteVolumeIndex.write(oprot)
            oprot.writeFieldEnd()
        if self.movingBoundaryVolumeIndex is not None:
            oprot.writeFieldBegin('movingBoundaryVolumeIndex', TType.STRUCT, 4)
            self.movingBoundaryVolumeIndex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pointIndices is None:
            raise TProtocolException(message='Required field pointIndices is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VisTetrahedron(object):
    """
    Attributes:
     - pointIndices
     - chomboVolumeIndex
     - finiteVolumeIndex

    """


    def __init__(self, pointIndices=None, chomboVolumeIndex=None, finiteVolumeIndex=None,):
        self.pointIndices = pointIndices
        self.chomboVolumeIndex = chomboVolumeIndex
        self.finiteVolumeIndex = finiteVolumeIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pointIndices = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readI32()
                        self.pointIndices.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.chomboVolumeIndex = ChomboVolumeIndex()
                    self.chomboVolumeIndex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.finiteVolumeIndex = FiniteVolumeIndex()
                    self.finiteVolumeIndex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VisTetrahedron')
        if self.pointIndices is not None:
            oprot.writeFieldBegin('pointIndices', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.pointIndices))
            for iter34 in self.pointIndices:
                oprot.writeI32(iter34)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.chomboVolumeIndex is not None:
            oprot.writeFieldBegin('chomboVolumeIndex', TType.STRUCT, 2)
            self.chomboVolumeIndex.write(oprot)
            oprot.writeFieldEnd()
        if self.finiteVolumeIndex is not None:
            oprot.writeFieldBegin('finiteVolumeIndex', TType.STRUCT, 3)
            self.finiteVolumeIndex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pointIndices is None:
            raise TProtocolException(message='Required field pointIndices is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VisSurfaceTriangle(object):
    """
    Attributes:
     - pointIndices
     - face
     - chomboSurfaceIndex

    """


    def __init__(self, pointIndices=None, face=None, chomboSurfaceIndex=None,):
        self.pointIndices = pointIndices
        self.face = face
        self.chomboSurfaceIndex = chomboSurfaceIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pointIndices = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readI32()
                        self.pointIndices.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.face = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.chomboSurfaceIndex = ChomboSurfaceIndex()
                    self.chomboSurfaceIndex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VisSurfaceTriangle')
        if self.pointIndices is not None:
            oprot.writeFieldBegin('pointIndices', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.pointIndices))
            for iter41 in self.pointIndices:
                oprot.writeI32(iter41)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.face is not None:
            oprot.writeFieldBegin('face', TType.I32, 2)
            oprot.writeI32(self.face)
            oprot.writeFieldEnd()
        if self.chomboSurfaceIndex is not None:
            oprot.writeFieldBegin('chomboSurfaceIndex', TType.STRUCT, 3)
            self.chomboSurfaceIndex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pointIndices is None:
            raise TProtocolException(message='Required field pointIndices is unset!')
        if self.face is None:
            raise TProtocolException(message='Required field face is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VisLine(object):
    """
    Attributes:
     - p1
     - p2
     - chomboSurfaceIndex
     - finiteVolumeIndex
     - movingBoundarySurfaceIndex

    """


    def __init__(self, p1=None, p2=None, chomboSurfaceIndex=None, finiteVolumeIndex=None, movingBoundarySurfaceIndex=None,):
        self.p1 = p1
        self.p2 = p2
        self.chomboSurfaceIndex = chomboSurfaceIndex
        self.finiteVolumeIndex = finiteVolumeIndex
        self.movingBoundarySurfaceIndex = movingBoundarySurfaceIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.p1 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.p2 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.chomboSurfaceIndex = ChomboSurfaceIndex()
                    self.chomboSurfaceIndex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.finiteVolumeIndex = FiniteVolumeIndex()
                    self.finiteVolumeIndex.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.movingBoundarySurfaceIndex = MovingBoundarySurfaceIndex()
                    self.movingBoundarySurfaceIndex.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VisLine')
        if self.p1 is not None:
            oprot.writeFieldBegin('p1', TType.I32, 1)
            oprot.writeI32(self.p1)
            oprot.writeFieldEnd()
        if self.p2 is not None:
            oprot.writeFieldBegin('p2', TType.I32, 2)
            oprot.writeI32(self.p2)
            oprot.writeFieldEnd()
        if self.chomboSurfaceIndex is not None:
            oprot.writeFieldBegin('chomboSurfaceIndex', TType.STRUCT, 3)
            self.chomboSurfaceIndex.write(oprot)
            oprot.writeFieldEnd()
        if self.finiteVolumeIndex is not None:
            oprot.writeFieldBegin('finiteVolumeIndex', TType.STRUCT, 4)
            self.finiteVolumeIndex.write(oprot)
            oprot.writeFieldEnd()
        if self.movingBoundarySurfaceIndex is not None:
            oprot.writeFieldBegin('movingBoundarySurfaceIndex', TType.STRUCT, 5)
            self.movingBoundarySurfaceIndex.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.p1 is None:
            raise TProtocolException(message='Required field p1 is unset!')
        if self.p2 is None:
            raise TProtocolException(message='Required field p2 is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FiniteVolumeIndexData(object):
    """
    Attributes:
     - domainName
     - finiteVolumeIndices

    """


    def __init__(self, domainName=None, finiteVolumeIndices=None,):
        self.domainName = domainName
        self.finiteVolumeIndices = finiteVolumeIndices

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.finiteVolumeIndices = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = FiniteVolumeIndex()
                        _elem47.read(iprot)
                        self.finiteVolumeIndices.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FiniteVolumeIndexData')
        if self.domainName is not None:
            oprot.writeFieldBegin('domainName', TType.STRING, 1)
            oprot.writeString(self.domainName.encode('utf-8') if sys.version_info[0] == 2 else self.domainName)
            oprot.writeFieldEnd()
        if self.finiteVolumeIndices is not None:
            oprot.writeFieldBegin('finiteVolumeIndices', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.finiteVolumeIndices))
            for iter48 in self.finiteVolumeIndices:
                iter48.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainName is None:
            raise TProtocolException(message='Required field domainName is unset!')
        if self.finiteVolumeIndices is None:
            raise TProtocolException(message='Required field finiteVolumeIndices is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ChomboIndexData(object):
    """
    Attributes:
     - domainName
     - chomboSurfaceIndices
     - chomboVolumeIndices

    """


    def __init__(self, domainName=None, chomboSurfaceIndices=None, chomboVolumeIndices=None,):
        self.domainName = domainName
        self.chomboSurfaceIndices = chomboSurfaceIndices
        self.chomboVolumeIndices = chomboVolumeIndices

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.chomboSurfaceIndices = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = ChomboSurfaceIndex()
                        _elem54.read(iprot)
                        self.chomboSurfaceIndices.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.chomboVolumeIndices = []
                    (_etype58, _size55) = iprot.readListBegin()
                    for _i59 in range(_size55):
                        _elem60 = ChomboVolumeIndex()
                        _elem60.read(iprot)
                        self.chomboVolumeIndices.append(_elem60)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ChomboIndexData')
        if self.domainName is not None:
            oprot.writeFieldBegin('domainName', TType.STRING, 1)
            oprot.writeString(self.domainName.encode('utf-8') if sys.version_info[0] == 2 else self.domainName)
            oprot.writeFieldEnd()
        if self.chomboSurfaceIndices is not None:
            oprot.writeFieldBegin('chomboSurfaceIndices', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.chomboSurfaceIndices))
            for iter61 in self.chomboSurfaceIndices:
                iter61.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.chomboVolumeIndices is not None:
            oprot.writeFieldBegin('chomboVolumeIndices', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.chomboVolumeIndices))
            for iter62 in self.chomboVolumeIndices:
                iter62.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainName is None:
            raise TProtocolException(message='Required field domainName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MovingBoundaryIndexData(object):
    """
    Attributes:
     - domainName
     - timeIndex
     - movingBoundarySurfaceIndices
     - movingBoundaryVolumeIndices

    """


    def __init__(self, domainName=None, timeIndex=None, movingBoundarySurfaceIndices=None, movingBoundaryVolumeIndices=None,):
        self.domainName = domainName
        self.timeIndex = timeIndex
        self.movingBoundarySurfaceIndices = movingBoundarySurfaceIndices
        self.movingBoundaryVolumeIndices = movingBoundaryVolumeIndices

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.timeIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.movingBoundarySurfaceIndices = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = MovingBoundarySurfaceIndex()
                        _elem68.read(iprot)
                        self.movingBoundarySurfaceIndices.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.movingBoundaryVolumeIndices = []
                    (_etype72, _size69) = iprot.readListBegin()
                    for _i73 in range(_size69):
                        _elem74 = MovingBoundaryVolumeIndex()
                        _elem74.read(iprot)
                        self.movingBoundaryVolumeIndices.append(_elem74)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MovingBoundaryIndexData')
        if self.domainName is not None:
            oprot.writeFieldBegin('domainName', TType.STRING, 1)
            oprot.writeString(self.domainName.encode('utf-8') if sys.version_info[0] == 2 else self.domainName)
            oprot.writeFieldEnd()
        if self.timeIndex is not None:
            oprot.writeFieldBegin('timeIndex', TType.I32, 2)
            oprot.writeI32(self.timeIndex)
            oprot.writeFieldEnd()
        if self.movingBoundarySurfaceIndices is not None:
            oprot.writeFieldBegin('movingBoundarySurfaceIndices', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.movingBoundarySurfaceIndices))
            for iter75 in self.movingBoundarySurfaceIndices:
                iter75.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.movingBoundaryVolumeIndices is not None:
            oprot.writeFieldBegin('movingBoundaryVolumeIndices', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.movingBoundaryVolumeIndices))
            for iter76 in self.movingBoundaryVolumeIndices:
                iter76.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainName is None:
            raise TProtocolException(message='Required field domainName is unset!')
        if self.timeIndex is None:
            raise TProtocolException(message='Required field timeIndex is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VisMesh(object):
    """
    Attributes:
     - dimension
     - origin
     - extent
     - points
     - polygons
     - irregularPolyhedra
     - tetrahedra
     - visVoxels
     - surfaceTriangles
     - visLines
     - surfacePoints

    """


    def __init__(self, dimension=None, origin=None, extent=None, points=None, polygons=None, irregularPolyhedra=None, tetrahedra=None, visVoxels=None, surfaceTriangles=None, visLines=None, surfacePoints=None,):
        self.dimension = dimension
        self.origin = origin
        self.extent = extent
        self.points = points
        self.polygons = polygons
        self.irregularPolyhedra = irregularPolyhedra
        self.tetrahedra = tetrahedra
        self.visVoxels = visVoxels
        self.surfaceTriangles = surfaceTriangles
        self.visLines = visLines
        self.surfacePoints = surfacePoints

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dimension = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.origin = Vect3D()
                    self.origin.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.extent = Vect3D()
                    self.extent.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.points = []
                    (_etype80, _size77) = iprot.readListBegin()
                    for _i81 in range(_size77):
                        _elem82 = VisPoint()
                        _elem82.read(iprot)
                        self.points.append(_elem82)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.polygons = []
                    (_etype86, _size83) = iprot.readListBegin()
                    for _i87 in range(_size83):
                        _elem88 = VisPolygon()
                        _elem88.read(iprot)
                        self.polygons.append(_elem88)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.irregularPolyhedra = []
                    (_etype92, _size89) = iprot.readListBegin()
                    for _i93 in range(_size89):
                        _elem94 = VisIrregularPolyhedron()
                        _elem94.read(iprot)
                        self.irregularPolyhedra.append(_elem94)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.tetrahedra = []
                    (_etype98, _size95) = iprot.readListBegin()
                    for _i99 in range(_size95):
                        _elem100 = VisTetrahedron()
                        _elem100.read(iprot)
                        self.tetrahedra.append(_elem100)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.visVoxels = []
                    (_etype104, _size101) = iprot.readListBegin()
                    for _i105 in range(_size101):
                        _elem106 = VisVoxel()
                        _elem106.read(iprot)
                        self.visVoxels.append(_elem106)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.surfaceTriangles = []
                    (_etype110, _size107) = iprot.readListBegin()
                    for _i111 in range(_size107):
                        _elem112 = VisSurfaceTriangle()
                        _elem112.read(iprot)
                        self.surfaceTriangles.append(_elem112)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.LIST:
                    self.visLines = []
                    (_etype116, _size113) = iprot.readListBegin()
                    for _i117 in range(_size113):
                        _elem118 = VisLine()
                        _elem118.read(iprot)
                        self.visLines.append(_elem118)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.LIST:
                    self.surfacePoints = []
                    (_etype122, _size119) = iprot.readListBegin()
                    for _i123 in range(_size119):
                        _elem124 = VisPoint()
                        _elem124.read(iprot)
                        self.surfacePoints.append(_elem124)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VisMesh')
        if self.dimension is not None:
            oprot.writeFieldBegin('dimension', TType.I32, 1)
            oprot.writeI32(self.dimension)
            oprot.writeFieldEnd()
        if self.origin is not None:
            oprot.writeFieldBegin('origin', TType.STRUCT, 2)
            self.origin.write(oprot)
            oprot.writeFieldEnd()
        if self.extent is not None:
            oprot.writeFieldBegin('extent', TType.STRUCT, 3)
            self.extent.write(oprot)
            oprot.writeFieldEnd()
        if self.points is not None:
            oprot.writeFieldBegin('points', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.points))
            for iter125 in self.points:
                iter125.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.polygons is not None:
            oprot.writeFieldBegin('polygons', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.polygons))
            for iter126 in self.polygons:
                iter126.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.irregularPolyhedra is not None:
            oprot.writeFieldBegin('irregularPolyhedra', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.irregularPolyhedra))
            for iter127 in self.irregularPolyhedra:
                iter127.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tetrahedra is not None:
            oprot.writeFieldBegin('tetrahedra', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.tetrahedra))
            for iter128 in self.tetrahedra:
                iter128.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.visVoxels is not None:
            oprot.writeFieldBegin('visVoxels', TType.LIST, 8)
            oprot.writeListBegin(TType.STRUCT, len(self.visVoxels))
            for iter129 in self.visVoxels:
                iter129.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.surfaceTriangles is not None:
            oprot.writeFieldBegin('surfaceTriangles', TType.LIST, 9)
            oprot.writeListBegin(TType.STRUCT, len(self.surfaceTriangles))
            for iter130 in self.surfaceTriangles:
                iter130.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.visLines is not None:
            oprot.writeFieldBegin('visLines', TType.LIST, 10)
            oprot.writeListBegin(TType.STRUCT, len(self.visLines))
            for iter131 in self.visLines:
                iter131.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.surfacePoints is not None:
            oprot.writeFieldBegin('surfacePoints', TType.LIST, 11)
            oprot.writeListBegin(TType.STRUCT, len(self.surfacePoints))
            for iter132 in self.surfacePoints:
                iter132.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dimension is None:
            raise TProtocolException(message='Required field dimension is unset!')
        if self.origin is None:
            raise TProtocolException(message='Required field origin is unset!')
        if self.extent is None:
            raise TProtocolException(message='Required field extent is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Vect3D)
Vect3D.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'x', None, None, ),  # 1
    (2, TType.DOUBLE, 'y', None, None, ),  # 2
    (3, TType.DOUBLE, 'z', None, None, ),  # 3
)
all_structs.append(VisPoint)
VisPoint.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'x', None, None, ),  # 1
    (2, TType.DOUBLE, 'y', None, None, ),  # 2
    (3, TType.DOUBLE, 'z', None, None, ),  # 3
)
all_structs.append(ChomboVolumeIndex)
ChomboVolumeIndex.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'level', None, None, ),  # 1
    (2, TType.I32, 'boxNumber', None, None, ),  # 2
    (3, TType.I32, 'boxIndex', None, None, ),  # 3
    (4, TType.DOUBLE, 'fraction', None, None, ),  # 4
)
all_structs.append(ChomboSurfaceIndex)
ChomboSurfaceIndex.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'index', None, None, ),  # 1
)
all_structs.append(MovingBoundarySurfaceIndex)
MovingBoundarySurfaceIndex.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'index', None, None, ),  # 1
)
all_structs.append(MovingBoundaryVolumeIndex)
MovingBoundaryVolumeIndex.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'index', None, None, ),  # 1
)
all_structs.append(FiniteVolumeIndex)
FiniteVolumeIndex.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'globalIndex', None, None, ),  # 1
    (2, TType.I32, 'regionIndex', None, None, ),  # 2
)
all_structs.append(VisPolygon)
VisPolygon.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pointIndices', (TType.I32, None, False), None, ),  # 1
    (2, TType.STRUCT, 'chomboVolumeIndex', [ChomboVolumeIndex, None], None, ),  # 2
    (3, TType.STRUCT, 'finiteVolumeIndex', [FiniteVolumeIndex, None], None, ),  # 3
    (4, TType.STRUCT, 'movingBoundaryVolumeIndex', [MovingBoundaryVolumeIndex, None], None, ),  # 4
)
all_structs.append(PolyhedronFace)
PolyhedronFace.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'vertices', (TType.I32, None, False), None, ),  # 1
)
all_structs.append(VisIrregularPolyhedron)
VisIrregularPolyhedron.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'polyhedronFaces', (TType.STRUCT, [PolyhedronFace, None], False), None, ),  # 1
    (2, TType.STRUCT, 'chomboVolumeIndex', [ChomboVolumeIndex, None], None, ),  # 2
    (3, TType.STRUCT, 'finiteVolumeIndex', [FiniteVolumeIndex, None], None, ),  # 3
)
all_structs.append(VisVoxel)
VisVoxel.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pointIndices', (TType.I32, None, False), None, ),  # 1
    (2, TType.STRUCT, 'chomboVolumeIndex', [ChomboVolumeIndex, None], None, ),  # 2
    (3, TType.STRUCT, 'finiteVolumeIndex', [FiniteVolumeIndex, None], None, ),  # 3
    (4, TType.STRUCT, 'movingBoundaryVolumeIndex', [MovingBoundaryVolumeIndex, None], None, ),  # 4
)
all_structs.append(VisTetrahedron)
VisTetrahedron.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pointIndices', (TType.I32, None, False), None, ),  # 1
    (2, TType.STRUCT, 'chomboVolumeIndex', [ChomboVolumeIndex, None], None, ),  # 2
    (3, TType.STRUCT, 'finiteVolumeIndex', [FiniteVolumeIndex, None], None, ),  # 3
)
all_structs.append(VisSurfaceTriangle)
VisSurfaceTriangle.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pointIndices', (TType.I32, None, False), None, ),  # 1
    (2, TType.I32, 'face', None, None, ),  # 2
    (3, TType.STRUCT, 'chomboSurfaceIndex', [ChomboSurfaceIndex, None], None, ),  # 3
)
all_structs.append(VisLine)
VisLine.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'p1', None, None, ),  # 1
    (2, TType.I32, 'p2', None, None, ),  # 2
    (3, TType.STRUCT, 'chomboSurfaceIndex', [ChomboSurfaceIndex, None], None, ),  # 3
    (4, TType.STRUCT, 'finiteVolumeIndex', [FiniteVolumeIndex, None], None, ),  # 4
    (5, TType.STRUCT, 'movingBoundarySurfaceIndex', [MovingBoundarySurfaceIndex, None], None, ),  # 5
)
all_structs.append(FiniteVolumeIndexData)
FiniteVolumeIndexData.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainName', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'finiteVolumeIndices', (TType.STRUCT, [FiniteVolumeIndex, None], False), None, ),  # 2
)
all_structs.append(ChomboIndexData)
ChomboIndexData.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainName', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'chomboSurfaceIndices', (TType.STRUCT, [ChomboSurfaceIndex, None], False), None, ),  # 2
    (3, TType.LIST, 'chomboVolumeIndices', (TType.STRUCT, [ChomboVolumeIndex, None], False), None, ),  # 3
)
all_structs.append(MovingBoundaryIndexData)
MovingBoundaryIndexData.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'timeIndex', None, None, ),  # 2
    (3, TType.LIST, 'movingBoundarySurfaceIndices', (TType.STRUCT, [MovingBoundarySurfaceIndex, None], False), None, ),  # 3
    (4, TType.LIST, 'movingBoundaryVolumeIndices', (TType.STRUCT, [MovingBoundaryVolumeIndex, None], False), None, ),  # 4
)
all_structs.append(VisMesh)
VisMesh.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'dimension', None, None, ),  # 1
    (2, TType.STRUCT, 'origin', [Vect3D, None], None, ),  # 2
    (3, TType.STRUCT, 'extent', [Vect3D, None], None, ),  # 3
    (4, TType.LIST, 'points', (TType.STRUCT, [VisPoint, None], False), None, ),  # 4
    (5, TType.LIST, 'polygons', (TType.STRUCT, [VisPolygon, None], False), None, ),  # 5
    (6, TType.LIST, 'irregularPolyhedra', (TType.STRUCT, [VisIrregularPolyhedron, None], False), None, ),  # 6
    (7, TType.LIST, 'tetrahedra', (TType.STRUCT, [VisTetrahedron, None], False), None, ),  # 7
    (8, TType.LIST, 'visVoxels', (TType.STRUCT, [VisVoxel, None], False), None, ),  # 8
    (9, TType.LIST, 'surfaceTriangles', (TType.STRUCT, [VisSurfaceTriangle, None], False), None, ),  # 9
    (10, TType.LIST, 'visLines', (TType.STRUCT, [VisLine, None], False), None, ),  # 10
    (11, TType.LIST, 'surfacePoints', (TType.STRUCT, [VisPoint, None], False), None, ),  # 11
)
fix_spec(all_structs)
del all_structs
