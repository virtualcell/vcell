#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Face:
  Xm = 0
  Xp = 1
  Ym = 2
  Yp = 3
  Zm = 4
  Zp = 5

  _VALUES_TO_NAMES = {
    0: "Xm",
    1: "Xp",
    2: "Ym",
    3: "Yp",
    4: "Zm",
    5: "Zp",
  }

  _NAMES_TO_VALUES = {
    "Xm": 0,
    "Xp": 1,
    "Ym": 2,
    "Yp": 3,
    "Zm": 4,
    "Zp": 5,
  }


class Vect3D:
  """
  Attributes:
   - x
   - y
   - z
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'x', None, None, ), # 1
    (2, TType.DOUBLE, 'y', None, None, ), # 2
    (3, TType.DOUBLE, 'z', None, None, ), # 3
  )

  def __init__(self, x=None, y=None, z=None,):
    self.x = x
    self.y = y
    self.z = z

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.x = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.y = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.z = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Vect3D')
    if self.x is not None:
      oprot.writeFieldBegin('x', TType.DOUBLE, 1)
      oprot.writeDouble(self.x)
      oprot.writeFieldEnd()
    if self.y is not None:
      oprot.writeFieldBegin('y', TType.DOUBLE, 2)
      oprot.writeDouble(self.y)
      oprot.writeFieldEnd()
    if self.z is not None:
      oprot.writeFieldBegin('z', TType.DOUBLE, 3)
      oprot.writeDouble(self.z)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.x is None:
      raise TProtocol.TProtocolException(message='Required field x is unset!')
    if self.y is None:
      raise TProtocol.TProtocolException(message='Required field y is unset!')
    if self.z is None:
      raise TProtocol.TProtocolException(message='Required field z is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.x)
    value = (value * 31) ^ hash(self.y)
    value = (value * 31) ^ hash(self.z)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class VisPoint:
  """
  Attributes:
   - x
   - y
   - z
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'x', None, None, ), # 1
    (2, TType.DOUBLE, 'y', None, None, ), # 2
    (3, TType.DOUBLE, 'z', None, None, ), # 3
  )

  def __init__(self, x=None, y=None, z=None,):
    self.x = x
    self.y = y
    self.z = z

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.x = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.y = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.z = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('VisPoint')
    if self.x is not None:
      oprot.writeFieldBegin('x', TType.DOUBLE, 1)
      oprot.writeDouble(self.x)
      oprot.writeFieldEnd()
    if self.y is not None:
      oprot.writeFieldBegin('y', TType.DOUBLE, 2)
      oprot.writeDouble(self.y)
      oprot.writeFieldEnd()
    if self.z is not None:
      oprot.writeFieldBegin('z', TType.DOUBLE, 3)
      oprot.writeDouble(self.z)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.x is None:
      raise TProtocol.TProtocolException(message='Required field x is unset!')
    if self.y is None:
      raise TProtocol.TProtocolException(message='Required field y is unset!')
    if self.z is None:
      raise TProtocol.TProtocolException(message='Required field z is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.x)
    value = (value * 31) ^ hash(self.y)
    value = (value * 31) ^ hash(self.z)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ChomboVolumeIndex:
  """
  Attributes:
   - level
   - boxNumber
   - boxIndex
   - fraction
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'level', None, None, ), # 1
    (2, TType.I32, 'boxNumber', None, None, ), # 2
    (3, TType.I32, 'boxIndex', None, None, ), # 3
    (4, TType.DOUBLE, 'fraction', None, None, ), # 4
  )

  def __init__(self, level=None, boxNumber=None, boxIndex=None, fraction=None,):
    self.level = level
    self.boxNumber = boxNumber
    self.boxIndex = boxIndex
    self.fraction = fraction

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.level = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.boxNumber = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.boxIndex = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.fraction = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ChomboVolumeIndex')
    if self.level is not None:
      oprot.writeFieldBegin('level', TType.I32, 1)
      oprot.writeI32(self.level)
      oprot.writeFieldEnd()
    if self.boxNumber is not None:
      oprot.writeFieldBegin('boxNumber', TType.I32, 2)
      oprot.writeI32(self.boxNumber)
      oprot.writeFieldEnd()
    if self.boxIndex is not None:
      oprot.writeFieldBegin('boxIndex', TType.I32, 3)
      oprot.writeI32(self.boxIndex)
      oprot.writeFieldEnd()
    if self.fraction is not None:
      oprot.writeFieldBegin('fraction', TType.DOUBLE, 4)
      oprot.writeDouble(self.fraction)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.level is None:
      raise TProtocol.TProtocolException(message='Required field level is unset!')
    if self.boxNumber is None:
      raise TProtocol.TProtocolException(message='Required field boxNumber is unset!')
    if self.boxIndex is None:
      raise TProtocol.TProtocolException(message='Required field boxIndex is unset!')
    if self.fraction is None:
      raise TProtocol.TProtocolException(message='Required field fraction is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.level)
    value = (value * 31) ^ hash(self.boxNumber)
    value = (value * 31) ^ hash(self.boxIndex)
    value = (value * 31) ^ hash(self.fraction)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ChomboSurfaceIndex:
  """
  Attributes:
   - index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'index', None, None, ), # 1
  )

  def __init__(self, index=None,):
    self.index = index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ChomboSurfaceIndex')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 1)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.index is None:
      raise TProtocol.TProtocolException(message='Required field index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MovingBoundarySurfaceIndex:
  """
  Attributes:
   - index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'index', None, None, ), # 1
  )

  def __init__(self, index=None,):
    self.index = index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MovingBoundarySurfaceIndex')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 1)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.index is None:
      raise TProtocol.TProtocolException(message='Required field index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MovingBoundaryVolumeIndex:
  """
  Attributes:
   - index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'index', None, None, ), # 1
  )

  def __init__(self, index=None,):
    self.index = index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MovingBoundaryVolumeIndex')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 1)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.index is None:
      raise TProtocol.TProtocolException(message='Required field index is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.index)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FiniteVolumeIndex:
  """
  Attributes:
   - globalIndex
   - regionIndex
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'globalIndex', None, None, ), # 1
    (2, TType.I32, 'regionIndex', None, None, ), # 2
  )

  def __init__(self, globalIndex=None, regionIndex=None,):
    self.globalIndex = globalIndex
    self.regionIndex = regionIndex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.globalIndex = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.regionIndex = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FiniteVolumeIndex')
    if self.globalIndex is not None:
      oprot.writeFieldBegin('globalIndex', TType.I32, 1)
      oprot.writeI32(self.globalIndex)
      oprot.writeFieldEnd()
    if self.regionIndex is not None:
      oprot.writeFieldBegin('regionIndex', TType.I32, 2)
      oprot.writeI32(self.regionIndex)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.globalIndex is None:
      raise TProtocol.TProtocolException(message='Required field globalIndex is unset!')
    if self.regionIndex is None:
      raise TProtocol.TProtocolException(message='Required field regionIndex is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.globalIndex)
    value = (value * 31) ^ hash(self.regionIndex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class VisPolygon:
  """
  Attributes:
   - pointIndices
   - chomboVolumeIndex
   - finiteVolumeIndex
   - movingBoundaryVolumeIndex
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'pointIndices', (TType.I32,None), None, ), # 1
    (2, TType.STRUCT, 'chomboVolumeIndex', (ChomboVolumeIndex, ChomboVolumeIndex.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'finiteVolumeIndex', (FiniteVolumeIndex, FiniteVolumeIndex.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'movingBoundaryVolumeIndex', (MovingBoundaryVolumeIndex, MovingBoundaryVolumeIndex.thrift_spec), None, ), # 4
  )

  def __init__(self, pointIndices=None, chomboVolumeIndex=None, finiteVolumeIndex=None, movingBoundaryVolumeIndex=None,):
    self.pointIndices = pointIndices
    self.chomboVolumeIndex = chomboVolumeIndex
    self.finiteVolumeIndex = finiteVolumeIndex
    self.movingBoundaryVolumeIndex = movingBoundaryVolumeIndex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.pointIndices = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readI32();
            self.pointIndices.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.chomboVolumeIndex = ChomboVolumeIndex()
          self.chomboVolumeIndex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.finiteVolumeIndex = FiniteVolumeIndex()
          self.finiteVolumeIndex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.movingBoundaryVolumeIndex = MovingBoundaryVolumeIndex()
          self.movingBoundaryVolumeIndex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('VisPolygon')
    if self.pointIndices is not None:
      oprot.writeFieldBegin('pointIndices', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.pointIndices))
      for iter6 in self.pointIndices:
        oprot.writeI32(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.chomboVolumeIndex is not None:
      oprot.writeFieldBegin('chomboVolumeIndex', TType.STRUCT, 2)
      self.chomboVolumeIndex.write(oprot)
      oprot.writeFieldEnd()
    if self.finiteVolumeIndex is not None:
      oprot.writeFieldBegin('finiteVolumeIndex', TType.STRUCT, 3)
      self.finiteVolumeIndex.write(oprot)
      oprot.writeFieldEnd()
    if self.movingBoundaryVolumeIndex is not None:
      oprot.writeFieldBegin('movingBoundaryVolumeIndex', TType.STRUCT, 4)
      self.movingBoundaryVolumeIndex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.pointIndices is None:
      raise TProtocol.TProtocolException(message='Required field pointIndices is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pointIndices)
    value = (value * 31) ^ hash(self.chomboVolumeIndex)
    value = (value * 31) ^ hash(self.finiteVolumeIndex)
    value = (value * 31) ^ hash(self.movingBoundaryVolumeIndex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PolyhedronFace:
  """
  Attributes:
   - vertices
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'vertices', (TType.I32,None), None, ), # 1
  )

  def __init__(self, vertices=None,):
    self.vertices = vertices

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.vertices = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readI32();
            self.vertices.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PolyhedronFace')
    if self.vertices is not None:
      oprot.writeFieldBegin('vertices', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.vertices))
      for iter13 in self.vertices:
        oprot.writeI32(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.vertices is None:
      raise TProtocol.TProtocolException(message='Required field vertices is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vertices)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class VisIrregularPolyhedron:
  """
  Attributes:
   - polyhedronFaces
   - chomboVolumeIndex
   - finiteVolumeIndex
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'polyhedronFaces', (TType.STRUCT,(PolyhedronFace, PolyhedronFace.thrift_spec)), None, ), # 1
    (2, TType.STRUCT, 'chomboVolumeIndex', (ChomboVolumeIndex, ChomboVolumeIndex.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'finiteVolumeIndex', (FiniteVolumeIndex, FiniteVolumeIndex.thrift_spec), None, ), # 3
  )

  def __init__(self, polyhedronFaces=None, chomboVolumeIndex=None, finiteVolumeIndex=None,):
    self.polyhedronFaces = polyhedronFaces
    self.chomboVolumeIndex = chomboVolumeIndex
    self.finiteVolumeIndex = finiteVolumeIndex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.polyhedronFaces = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = PolyhedronFace()
            _elem19.read(iprot)
            self.polyhedronFaces.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.chomboVolumeIndex = ChomboVolumeIndex()
          self.chomboVolumeIndex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.finiteVolumeIndex = FiniteVolumeIndex()
          self.finiteVolumeIndex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('VisIrregularPolyhedron')
    if self.polyhedronFaces is not None:
      oprot.writeFieldBegin('polyhedronFaces', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.polyhedronFaces))
      for iter20 in self.polyhedronFaces:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.chomboVolumeIndex is not None:
      oprot.writeFieldBegin('chomboVolumeIndex', TType.STRUCT, 2)
      self.chomboVolumeIndex.write(oprot)
      oprot.writeFieldEnd()
    if self.finiteVolumeIndex is not None:
      oprot.writeFieldBegin('finiteVolumeIndex', TType.STRUCT, 3)
      self.finiteVolumeIndex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.polyhedronFaces is None:
      raise TProtocol.TProtocolException(message='Required field polyhedronFaces is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.polyhedronFaces)
    value = (value * 31) ^ hash(self.chomboVolumeIndex)
    value = (value * 31) ^ hash(self.finiteVolumeIndex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class VisVoxel:
  """
  Attributes:
   - pointIndices
   - chomboVolumeIndex
   - finiteVolumeIndex
   - movingBoundaryVolumeIndex
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'pointIndices', (TType.I32,None), None, ), # 1
    (2, TType.STRUCT, 'chomboVolumeIndex', (ChomboVolumeIndex, ChomboVolumeIndex.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'finiteVolumeIndex', (FiniteVolumeIndex, FiniteVolumeIndex.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'movingBoundaryVolumeIndex', (MovingBoundaryVolumeIndex, MovingBoundaryVolumeIndex.thrift_spec), None, ), # 4
  )

  def __init__(self, pointIndices=None, chomboVolumeIndex=None, finiteVolumeIndex=None, movingBoundaryVolumeIndex=None,):
    self.pointIndices = pointIndices
    self.chomboVolumeIndex = chomboVolumeIndex
    self.finiteVolumeIndex = finiteVolumeIndex
    self.movingBoundaryVolumeIndex = movingBoundaryVolumeIndex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.pointIndices = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = iprot.readI32();
            self.pointIndices.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.chomboVolumeIndex = ChomboVolumeIndex()
          self.chomboVolumeIndex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.finiteVolumeIndex = FiniteVolumeIndex()
          self.finiteVolumeIndex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.movingBoundaryVolumeIndex = MovingBoundaryVolumeIndex()
          self.movingBoundaryVolumeIndex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('VisVoxel')
    if self.pointIndices is not None:
      oprot.writeFieldBegin('pointIndices', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.pointIndices))
      for iter27 in self.pointIndices:
        oprot.writeI32(iter27)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.chomboVolumeIndex is not None:
      oprot.writeFieldBegin('chomboVolumeIndex', TType.STRUCT, 2)
      self.chomboVolumeIndex.write(oprot)
      oprot.writeFieldEnd()
    if self.finiteVolumeIndex is not None:
      oprot.writeFieldBegin('finiteVolumeIndex', TType.STRUCT, 3)
      self.finiteVolumeIndex.write(oprot)
      oprot.writeFieldEnd()
    if self.movingBoundaryVolumeIndex is not None:
      oprot.writeFieldBegin('movingBoundaryVolumeIndex', TType.STRUCT, 4)
      self.movingBoundaryVolumeIndex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.pointIndices is None:
      raise TProtocol.TProtocolException(message='Required field pointIndices is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pointIndices)
    value = (value * 31) ^ hash(self.chomboVolumeIndex)
    value = (value * 31) ^ hash(self.finiteVolumeIndex)
    value = (value * 31) ^ hash(self.movingBoundaryVolumeIndex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class VisTetrahedron:
  """
  Attributes:
   - pointIndices
   - chomboVolumeIndex
   - finiteVolumeIndex
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'pointIndices', (TType.I32,None), None, ), # 1
    (2, TType.STRUCT, 'chomboVolumeIndex', (ChomboVolumeIndex, ChomboVolumeIndex.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'finiteVolumeIndex', (FiniteVolumeIndex, FiniteVolumeIndex.thrift_spec), None, ), # 3
  )

  def __init__(self, pointIndices=None, chomboVolumeIndex=None, finiteVolumeIndex=None,):
    self.pointIndices = pointIndices
    self.chomboVolumeIndex = chomboVolumeIndex
    self.finiteVolumeIndex = finiteVolumeIndex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.pointIndices = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = iprot.readI32();
            self.pointIndices.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.chomboVolumeIndex = ChomboVolumeIndex()
          self.chomboVolumeIndex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.finiteVolumeIndex = FiniteVolumeIndex()
          self.finiteVolumeIndex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('VisTetrahedron')
    if self.pointIndices is not None:
      oprot.writeFieldBegin('pointIndices', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.pointIndices))
      for iter34 in self.pointIndices:
        oprot.writeI32(iter34)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.chomboVolumeIndex is not None:
      oprot.writeFieldBegin('chomboVolumeIndex', TType.STRUCT, 2)
      self.chomboVolumeIndex.write(oprot)
      oprot.writeFieldEnd()
    if self.finiteVolumeIndex is not None:
      oprot.writeFieldBegin('finiteVolumeIndex', TType.STRUCT, 3)
      self.finiteVolumeIndex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.pointIndices is None:
      raise TProtocol.TProtocolException(message='Required field pointIndices is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pointIndices)
    value = (value * 31) ^ hash(self.chomboVolumeIndex)
    value = (value * 31) ^ hash(self.finiteVolumeIndex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class VisSurfaceTriangle:
  """
  Attributes:
   - pointIndices
   - face
   - chomboSurfaceIndex
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'pointIndices', (TType.I32,None), None, ), # 1
    (2, TType.I32, 'face', None, None, ), # 2
    (3, TType.STRUCT, 'chomboSurfaceIndex', (ChomboSurfaceIndex, ChomboSurfaceIndex.thrift_spec), None, ), # 3
  )

  def __init__(self, pointIndices=None, face=None, chomboSurfaceIndex=None,):
    self.pointIndices = pointIndices
    self.face = face
    self.chomboSurfaceIndex = chomboSurfaceIndex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.pointIndices = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = iprot.readI32();
            self.pointIndices.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.face = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.chomboSurfaceIndex = ChomboSurfaceIndex()
          self.chomboSurfaceIndex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('VisSurfaceTriangle')
    if self.pointIndices is not None:
      oprot.writeFieldBegin('pointIndices', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.pointIndices))
      for iter41 in self.pointIndices:
        oprot.writeI32(iter41)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.face is not None:
      oprot.writeFieldBegin('face', TType.I32, 2)
      oprot.writeI32(self.face)
      oprot.writeFieldEnd()
    if self.chomboSurfaceIndex is not None:
      oprot.writeFieldBegin('chomboSurfaceIndex', TType.STRUCT, 3)
      self.chomboSurfaceIndex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.pointIndices is None:
      raise TProtocol.TProtocolException(message='Required field pointIndices is unset!')
    if self.face is None:
      raise TProtocol.TProtocolException(message='Required field face is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pointIndices)
    value = (value * 31) ^ hash(self.face)
    value = (value * 31) ^ hash(self.chomboSurfaceIndex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class VisLine:
  """
  Attributes:
   - p1
   - p2
   - chomboSurfaceIndex
   - finiteVolumeIndex
   - movingBoundarySurfaceIndex
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'p1', None, None, ), # 1
    (2, TType.I32, 'p2', None, None, ), # 2
    (3, TType.STRUCT, 'chomboSurfaceIndex', (ChomboSurfaceIndex, ChomboSurfaceIndex.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'finiteVolumeIndex', (FiniteVolumeIndex, FiniteVolumeIndex.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'movingBoundarySurfaceIndex', (MovingBoundarySurfaceIndex, MovingBoundarySurfaceIndex.thrift_spec), None, ), # 5
  )

  def __init__(self, p1=None, p2=None, chomboSurfaceIndex=None, finiteVolumeIndex=None, movingBoundarySurfaceIndex=None,):
    self.p1 = p1
    self.p2 = p2
    self.chomboSurfaceIndex = chomboSurfaceIndex
    self.finiteVolumeIndex = finiteVolumeIndex
    self.movingBoundarySurfaceIndex = movingBoundarySurfaceIndex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.p1 = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.p2 = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.chomboSurfaceIndex = ChomboSurfaceIndex()
          self.chomboSurfaceIndex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.finiteVolumeIndex = FiniteVolumeIndex()
          self.finiteVolumeIndex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.movingBoundarySurfaceIndex = MovingBoundarySurfaceIndex()
          self.movingBoundarySurfaceIndex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('VisLine')
    if self.p1 is not None:
      oprot.writeFieldBegin('p1', TType.I32, 1)
      oprot.writeI32(self.p1)
      oprot.writeFieldEnd()
    if self.p2 is not None:
      oprot.writeFieldBegin('p2', TType.I32, 2)
      oprot.writeI32(self.p2)
      oprot.writeFieldEnd()
    if self.chomboSurfaceIndex is not None:
      oprot.writeFieldBegin('chomboSurfaceIndex', TType.STRUCT, 3)
      self.chomboSurfaceIndex.write(oprot)
      oprot.writeFieldEnd()
    if self.finiteVolumeIndex is not None:
      oprot.writeFieldBegin('finiteVolumeIndex', TType.STRUCT, 4)
      self.finiteVolumeIndex.write(oprot)
      oprot.writeFieldEnd()
    if self.movingBoundarySurfaceIndex is not None:
      oprot.writeFieldBegin('movingBoundarySurfaceIndex', TType.STRUCT, 5)
      self.movingBoundarySurfaceIndex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.p1 is None:
      raise TProtocol.TProtocolException(message='Required field p1 is unset!')
    if self.p2 is None:
      raise TProtocol.TProtocolException(message='Required field p2 is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.p1)
    value = (value * 31) ^ hash(self.p2)
    value = (value * 31) ^ hash(self.chomboSurfaceIndex)
    value = (value * 31) ^ hash(self.finiteVolumeIndex)
    value = (value * 31) ^ hash(self.movingBoundarySurfaceIndex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FiniteVolumeIndexData:
  """
  Attributes:
   - domainName
   - finiteVolumeIndices
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainName', None, None, ), # 1
    (2, TType.LIST, 'finiteVolumeIndices', (TType.STRUCT,(FiniteVolumeIndex, FiniteVolumeIndex.thrift_spec)), None, ), # 2
  )

  def __init__(self, domainName=None, finiteVolumeIndices=None,):
    self.domainName = domainName
    self.finiteVolumeIndices = finiteVolumeIndices

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.finiteVolumeIndices = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = FiniteVolumeIndex()
            _elem47.read(iprot)
            self.finiteVolumeIndices.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FiniteVolumeIndexData')
    if self.domainName is not None:
      oprot.writeFieldBegin('domainName', TType.STRING, 1)
      oprot.writeString(self.domainName)
      oprot.writeFieldEnd()
    if self.finiteVolumeIndices is not None:
      oprot.writeFieldBegin('finiteVolumeIndices', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.finiteVolumeIndices))
      for iter48 in self.finiteVolumeIndices:
        iter48.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainName is None:
      raise TProtocol.TProtocolException(message='Required field domainName is unset!')
    if self.finiteVolumeIndices is None:
      raise TProtocol.TProtocolException(message='Required field finiteVolumeIndices is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainName)
    value = (value * 31) ^ hash(self.finiteVolumeIndices)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ChomboIndexData:
  """
  Attributes:
   - domainName
   - chomboSurfaceIndices
   - chomboVolumeIndices
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainName', None, None, ), # 1
    (2, TType.LIST, 'chomboSurfaceIndices', (TType.STRUCT,(ChomboSurfaceIndex, ChomboSurfaceIndex.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'chomboVolumeIndices', (TType.STRUCT,(ChomboVolumeIndex, ChomboVolumeIndex.thrift_spec)), None, ), # 3
  )

  def __init__(self, domainName=None, chomboSurfaceIndices=None, chomboVolumeIndices=None,):
    self.domainName = domainName
    self.chomboSurfaceIndices = chomboSurfaceIndices
    self.chomboVolumeIndices = chomboVolumeIndices

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.chomboSurfaceIndices = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = ChomboSurfaceIndex()
            _elem54.read(iprot)
            self.chomboSurfaceIndices.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.chomboVolumeIndices = []
          (_etype58, _size55) = iprot.readListBegin()
          for _i59 in xrange(_size55):
            _elem60 = ChomboVolumeIndex()
            _elem60.read(iprot)
            self.chomboVolumeIndices.append(_elem60)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ChomboIndexData')
    if self.domainName is not None:
      oprot.writeFieldBegin('domainName', TType.STRING, 1)
      oprot.writeString(self.domainName)
      oprot.writeFieldEnd()
    if self.chomboSurfaceIndices is not None:
      oprot.writeFieldBegin('chomboSurfaceIndices', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.chomboSurfaceIndices))
      for iter61 in self.chomboSurfaceIndices:
        iter61.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.chomboVolumeIndices is not None:
      oprot.writeFieldBegin('chomboVolumeIndices', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.chomboVolumeIndices))
      for iter62 in self.chomboVolumeIndices:
        iter62.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainName is None:
      raise TProtocol.TProtocolException(message='Required field domainName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainName)
    value = (value * 31) ^ hash(self.chomboSurfaceIndices)
    value = (value * 31) ^ hash(self.chomboVolumeIndices)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MovingBoundaryIndexData:
  """
  Attributes:
   - domainName
   - timeIndex
   - movingBoundarySurfaceIndices
   - movingBoundaryVolumeIndices
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainName', None, None, ), # 1
    (2, TType.I32, 'timeIndex', None, None, ), # 2
    (3, TType.LIST, 'movingBoundarySurfaceIndices', (TType.STRUCT,(MovingBoundarySurfaceIndex, MovingBoundarySurfaceIndex.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'movingBoundaryVolumeIndices', (TType.STRUCT,(MovingBoundaryVolumeIndex, MovingBoundaryVolumeIndex.thrift_spec)), None, ), # 4
  )

  def __init__(self, domainName=None, timeIndex=None, movingBoundarySurfaceIndices=None, movingBoundaryVolumeIndices=None,):
    self.domainName = domainName
    self.timeIndex = timeIndex
    self.movingBoundarySurfaceIndices = movingBoundarySurfaceIndices
    self.movingBoundaryVolumeIndices = movingBoundaryVolumeIndices

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.timeIndex = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.movingBoundarySurfaceIndices = []
          (_etype66, _size63) = iprot.readListBegin()
          for _i67 in xrange(_size63):
            _elem68 = MovingBoundarySurfaceIndex()
            _elem68.read(iprot)
            self.movingBoundarySurfaceIndices.append(_elem68)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.movingBoundaryVolumeIndices = []
          (_etype72, _size69) = iprot.readListBegin()
          for _i73 in xrange(_size69):
            _elem74 = MovingBoundaryVolumeIndex()
            _elem74.read(iprot)
            self.movingBoundaryVolumeIndices.append(_elem74)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MovingBoundaryIndexData')
    if self.domainName is not None:
      oprot.writeFieldBegin('domainName', TType.STRING, 1)
      oprot.writeString(self.domainName)
      oprot.writeFieldEnd()
    if self.timeIndex is not None:
      oprot.writeFieldBegin('timeIndex', TType.I32, 2)
      oprot.writeI32(self.timeIndex)
      oprot.writeFieldEnd()
    if self.movingBoundarySurfaceIndices is not None:
      oprot.writeFieldBegin('movingBoundarySurfaceIndices', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.movingBoundarySurfaceIndices))
      for iter75 in self.movingBoundarySurfaceIndices:
        iter75.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.movingBoundaryVolumeIndices is not None:
      oprot.writeFieldBegin('movingBoundaryVolumeIndices', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.movingBoundaryVolumeIndices))
      for iter76 in self.movingBoundaryVolumeIndices:
        iter76.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainName is None:
      raise TProtocol.TProtocolException(message='Required field domainName is unset!')
    if self.timeIndex is None:
      raise TProtocol.TProtocolException(message='Required field timeIndex is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainName)
    value = (value * 31) ^ hash(self.timeIndex)
    value = (value * 31) ^ hash(self.movingBoundarySurfaceIndices)
    value = (value * 31) ^ hash(self.movingBoundaryVolumeIndices)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class VisMesh:
  """
  Attributes:
   - dimension
   - origin
   - extent
   - points
   - polygons
   - irregularPolyhedra
   - tetrahedra
   - visVoxels
   - surfaceTriangles
   - visLines
   - surfacePoints
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dimension', None, None, ), # 1
    (2, TType.STRUCT, 'origin', (Vect3D, Vect3D.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'extent', (Vect3D, Vect3D.thrift_spec), None, ), # 3
    (4, TType.LIST, 'points', (TType.STRUCT,(VisPoint, VisPoint.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'polygons', (TType.STRUCT,(VisPolygon, VisPolygon.thrift_spec)), None, ), # 5
    (6, TType.LIST, 'irregularPolyhedra', (TType.STRUCT,(VisIrregularPolyhedron, VisIrregularPolyhedron.thrift_spec)), None, ), # 6
    (7, TType.LIST, 'tetrahedra', (TType.STRUCT,(VisTetrahedron, VisTetrahedron.thrift_spec)), None, ), # 7
    (8, TType.LIST, 'visVoxels', (TType.STRUCT,(VisVoxel, VisVoxel.thrift_spec)), None, ), # 8
    (9, TType.LIST, 'surfaceTriangles', (TType.STRUCT,(VisSurfaceTriangle, VisSurfaceTriangle.thrift_spec)), None, ), # 9
    (10, TType.LIST, 'visLines', (TType.STRUCT,(VisLine, VisLine.thrift_spec)), None, ), # 10
    (11, TType.LIST, 'surfacePoints', (TType.STRUCT,(VisPoint, VisPoint.thrift_spec)), None, ), # 11
  )

  def __init__(self, dimension=None, origin=None, extent=None, points=None, polygons=None, irregularPolyhedra=None, tetrahedra=None, visVoxels=None, surfaceTriangles=None, visLines=None, surfacePoints=None,):
    self.dimension = dimension
    self.origin = origin
    self.extent = extent
    self.points = points
    self.polygons = polygons
    self.irregularPolyhedra = irregularPolyhedra
    self.tetrahedra = tetrahedra
    self.visVoxels = visVoxels
    self.surfaceTriangles = surfaceTriangles
    self.visLines = visLines
    self.surfacePoints = surfacePoints

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dimension = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.origin = Vect3D()
          self.origin.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.extent = Vect3D()
          self.extent.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.points = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = VisPoint()
            _elem82.read(iprot)
            self.points.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.polygons = []
          (_etype86, _size83) = iprot.readListBegin()
          for _i87 in xrange(_size83):
            _elem88 = VisPolygon()
            _elem88.read(iprot)
            self.polygons.append(_elem88)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.irregularPolyhedra = []
          (_etype92, _size89) = iprot.readListBegin()
          for _i93 in xrange(_size89):
            _elem94 = VisIrregularPolyhedron()
            _elem94.read(iprot)
            self.irregularPolyhedra.append(_elem94)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.tetrahedra = []
          (_etype98, _size95) = iprot.readListBegin()
          for _i99 in xrange(_size95):
            _elem100 = VisTetrahedron()
            _elem100.read(iprot)
            self.tetrahedra.append(_elem100)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.visVoxels = []
          (_etype104, _size101) = iprot.readListBegin()
          for _i105 in xrange(_size101):
            _elem106 = VisVoxel()
            _elem106.read(iprot)
            self.visVoxels.append(_elem106)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.surfaceTriangles = []
          (_etype110, _size107) = iprot.readListBegin()
          for _i111 in xrange(_size107):
            _elem112 = VisSurfaceTriangle()
            _elem112.read(iprot)
            self.surfaceTriangles.append(_elem112)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.LIST:
          self.visLines = []
          (_etype116, _size113) = iprot.readListBegin()
          for _i117 in xrange(_size113):
            _elem118 = VisLine()
            _elem118.read(iprot)
            self.visLines.append(_elem118)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.surfacePoints = []
          (_etype122, _size119) = iprot.readListBegin()
          for _i123 in xrange(_size119):
            _elem124 = VisPoint()
            _elem124.read(iprot)
            self.surfacePoints.append(_elem124)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('VisMesh')
    if self.dimension is not None:
      oprot.writeFieldBegin('dimension', TType.I32, 1)
      oprot.writeI32(self.dimension)
      oprot.writeFieldEnd()
    if self.origin is not None:
      oprot.writeFieldBegin('origin', TType.STRUCT, 2)
      self.origin.write(oprot)
      oprot.writeFieldEnd()
    if self.extent is not None:
      oprot.writeFieldBegin('extent', TType.STRUCT, 3)
      self.extent.write(oprot)
      oprot.writeFieldEnd()
    if self.points is not None:
      oprot.writeFieldBegin('points', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.points))
      for iter125 in self.points:
        iter125.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.polygons is not None:
      oprot.writeFieldBegin('polygons', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.polygons))
      for iter126 in self.polygons:
        iter126.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.irregularPolyhedra is not None:
      oprot.writeFieldBegin('irregularPolyhedra', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.irregularPolyhedra))
      for iter127 in self.irregularPolyhedra:
        iter127.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.tetrahedra is not None:
      oprot.writeFieldBegin('tetrahedra', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.tetrahedra))
      for iter128 in self.tetrahedra:
        iter128.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.visVoxels is not None:
      oprot.writeFieldBegin('visVoxels', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.visVoxels))
      for iter129 in self.visVoxels:
        iter129.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.surfaceTriangles is not None:
      oprot.writeFieldBegin('surfaceTriangles', TType.LIST, 9)
      oprot.writeListBegin(TType.STRUCT, len(self.surfaceTriangles))
      for iter130 in self.surfaceTriangles:
        iter130.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.visLines is not None:
      oprot.writeFieldBegin('visLines', TType.LIST, 10)
      oprot.writeListBegin(TType.STRUCT, len(self.visLines))
      for iter131 in self.visLines:
        iter131.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.surfacePoints is not None:
      oprot.writeFieldBegin('surfacePoints', TType.LIST, 11)
      oprot.writeListBegin(TType.STRUCT, len(self.surfacePoints))
      for iter132 in self.surfacePoints:
        iter132.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dimension is None:
      raise TProtocol.TProtocolException(message='Required field dimension is unset!')
    if self.origin is None:
      raise TProtocol.TProtocolException(message='Required field origin is unset!')
    if self.extent is None:
      raise TProtocol.TProtocolException(message='Required field extent is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dimension)
    value = (value * 31) ^ hash(self.origin)
    value = (value * 31) ^ hash(self.extent)
    value = (value * 31) ^ hash(self.points)
    value = (value * 31) ^ hash(self.polygons)
    value = (value * 31) ^ hash(self.irregularPolyhedra)
    value = (value * 31) ^ hash(self.tetrahedra)
    value = (value * 31) ^ hash(self.visVoxels)
    value = (value * 31) ^ hash(self.surfaceTriangles)
    value = (value * 31) ^ hash(self.visLines)
    value = (value * 31) ^ hash(self.surfacePoints)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
