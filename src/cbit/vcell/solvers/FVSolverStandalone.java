/*
 * Copyright (C) 1999-2011 University of Connecticut Health Center
 *
 * Licensed under the MIT License (the "License").
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *  http://www.opensource.org/licenses/mit-license.php
 */

package cbit.vcell.solvers;
import java.io.File;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.util.Vector;

import org.apache.commons.math.MathRuntimeException;
import org.vcell.chombo.ChomboSolverSpec;
import org.vcell.util.PropertyLoader;
import org.vcell.util.SessionLog;

import cbit.vcell.messaging.server.SimulationTask;
import cbit.vcell.solver.AnnotatedFunction;
import cbit.vcell.solver.Simulation;
import cbit.vcell.solver.SimulationJob;
import cbit.vcell.solver.SolverDescription;
import cbit.vcell.solver.SolverException;
import cbit.vcell.solver.server.SimulationMessage;
import cbit.vcell.solver.server.Solver;
import cbit.vcell.solver.server.SolverStatus;


/**
 * This interface was generated by a SmartGuide.
 * 
 */
public class FVSolverStandalone extends FVSolver implements Solver {

/**
 * This method was created by a SmartGuide.
 * @param mathDesc cbit.vcell.math.MathDescription
 * @param platform cbit.vcell.solvers.Platform
 * @param directory java.lang.String
 * @param simID java.lang.String
 * @param clientProxy cbit.vcell.solvers.ClientProxy
 */
public FVSolverStandalone (SimulationTask simTask, File dir, SessionLog sessionLog) throws SolverException {
	this(simTask, dir, sessionLog, true);
}
	
public FVSolverStandalone (SimulationTask simTask, File dir, SessionLog sessionLog, boolean arg_bMessaging) throws SolverException {
	super(simTask, dir, sessionLog, arg_bMessaging);
}

/**
 * This method was created by a SmartGuide.
 */
protected void initialize() throws SolverException {
	try {
		Simulation sim = simTask.getSimulation();
		if (sim.isSerialParameterScan()) {
			//write functions file for all the simulations in the scan
			for (int scan = 0; scan < sim.getScanCount(); scan ++) {
				SimulationJob simJob = new SimulationJob(sim, scan, simTask.getSimulationJob().getFieldDataIdentifierSpecs());
				// ** Dumping the functions of a simulation into a '.functions' file.
				String basename = new File(getSaveDirectory(), simJob.getSimulationJobID()).getPath();
				String functionFileName = basename + FUNCTIONFILE_EXTENSION;
				
				Vector<AnnotatedFunction> funcList = simJob.getSimulationSymbolTable().createAnnotatedFunctionsList(simTask.getSimulation().getMathDescription());				
				//Try to save existing user defined functions	
				try{
					File existingFunctionFile = new File(functionFileName);
					if (existingFunctionFile.exists()){
						Vector<AnnotatedFunction> oldFuncList = FunctionFileGenerator.readFunctionsFile(existingFunctionFile, simTask.getSimulationJobID());
						for(AnnotatedFunction func : oldFuncList){
							if(func.isOldUserDefined()){
								funcList.add(func);
							}
						}
					}
				}catch(Exception e){
					e.printStackTrace();
					//ignore
				}
				
				//Try to save existing user defined functions
				FunctionFileGenerator functionFileGenerator = new FunctionFileGenerator(functionFileName, funcList);

				try {
					functionFileGenerator.generateFunctionFile();
				}catch (Exception e){
					e.printStackTrace(System.out);
					throw new RuntimeException("Error creating .function file for "+functionFileGenerator.getBasefileName()+e.getMessage());
				}
			}
			
		} else {
			writeFunctionsFile();
		}
		
		// not for Chombo solver
		if (!simTask.getSimulation().getSolverTaskDescription().getSolverDescription().isChomboSolver())
		{
			writeVCGAndResampleFieldData();
		}
	
		setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING, SimulationMessage.MESSAGE_SOLVER_RUNNING_INIT));
		fireSolverStarting(SimulationMessage.MESSAGE_SOLVEREVENT_STARTING_INIT);
	
		setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING, SimulationMessage.MESSAGE_SOLVER_RUNNING_INPUT_FILE));
			
		File fvinputFile = new File(getInputFilename());
		PrintWriter pw = null;
		try {
			pw = new PrintWriter(new FileWriter(fvinputFile));
			new FiniteVolumeFileWriter(pw, simTask, getResampledGeometry(), getSaveDirectory(), bMessaging).write();
		} finally {
			if (pw != null) {
				pw.close();
			}
		}
	
		setMathExecutable(new MathExecutable(getMathExecutableCommand(), getSaveDirectory()));
	} catch (Exception ex) {
		ex.printStackTrace(System.out);
		throw new SolverException(ex.getMessage());
	}
}

private String getInputFilename(){
	return new File(getSaveDirectory(),cppCoderVCell.getBaseFilename()+".fvinput").getAbsolutePath();
}

@Override
public String[] getMathExecutableCommand() {
	String executableName = null;
	Simulation simulation = getSimulationJob().getSimulation();
	if (simulation.getSolverTaskDescription().getSolverDescription().isChomboSolver()) {
		int dimension = simulation.getMeshSpecification().getGeometry().getDimension();
		switch (dimension) {
		case 2:
			executableName = PropertyLoader.getRequiredProperty(PropertyLoader.VCellChomboExecutable2D);
			break;
		case 3:
			executableName = PropertyLoader.getRequiredProperty(PropertyLoader.VCellChomboExecutable3D);
			break;
		default:
			throw new IllegalArgumentException("VCell Chombo solver does not support " + dimension + "problems");
		}
		if (simulation.getSolverTaskDescription().isParallel()) {
			executableName += "parallel";
		}
	}
	else
	{
		executableName = PropertyLoader.getRequiredProperty(PropertyLoader.finiteVolumeExecutableProperty);
	}
	String inputFilename = getInputFilename();
	return new String[] { executableName, inputFilename };
}

}
