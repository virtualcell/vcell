/*
 * Copyright (C) 1999-2011 University of Connecticut Health Center
 *
 * Licensed under the MIT License (the "License").
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *  http://www.opensource.org/licenses/mit-license.php
 */

package cbit.vcell.math;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Optional;
import java.util.Random;
import java.util.Vector;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.function.Supplier;

import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.apache.log4j.Logger;
import org.vcell.util.BeanUtils;
import org.vcell.util.CommentStringTokenizer;
import org.vcell.util.Commented;
import org.vcell.util.Compare;
import org.vcell.util.Issue;
import org.vcell.util.Issue.IssueCategory;
import org.vcell.util.Issue.IssueSource;
import org.vcell.util.IssueContext;
import org.vcell.util.IssueContext.ContextType;
import org.vcell.util.Matchable;
import org.vcell.util.Token;
import org.vcell.util.VCAssert;
import org.vcell.util.document.BioModelChildSummary.MathType;
import org.vcell.util.document.KeyValue;
import org.vcell.util.document.Version;
import org.vcell.util.document.Versionable;

import cbit.vcell.geometry.Geometry;
import cbit.vcell.geometry.GeometryOwner;
import cbit.vcell.geometry.SubVolume;
import cbit.vcell.geometry.surface.GeometricRegion;
import cbit.vcell.geometry.surface.SurfaceGeometricRegion;
import cbit.vcell.geometry.surface.VolumeGeometricRegion;
import cbit.vcell.math.MathCompareResults.Decision;
import cbit.vcell.math.ParticleObservable.ObservableType;
import cbit.vcell.math.PdeEquation.BoundaryConditionValue;
import cbit.vcell.math.SubDomain.BoundaryConditionSpec;
import cbit.vcell.math.Variable.Domain;
import cbit.vcell.model.common.VCellErrorMessages;
import cbit.vcell.parser.Expression;
import cbit.vcell.parser.ExpressionBindingException;
import cbit.vcell.parser.ExpressionException;
import cbit.vcell.parser.ExpressionUtils;
import cbit.vcell.parser.SimpleSymbolTable;
import cbit.vcell.parser.SymbolTable;
import cbit.vcell.parser.SymbolTableEntry;
import cbit.vcell.parser.SymbolTableFunctionEntry;
/**
 * This class was generated by a SmartGuide.
 * 
 */
@SuppressWarnings("serial")
public class MathDescription implements Versionable, Matchable, SymbolTable, Serializable, ProblemRequirements, IssueSource {
	
	public final static String MATH_FUNC_INIT_SUFFIX_PREFIX = "_init_";
	
	protected transient java.util.ArrayList<ChangeListener> aChangeListener = null;
	private Version version = null;
	private ArrayList<SubDomain> subDomainList = new ArrayList<SubDomain>();
	private ArrayList<Variable> variableList = new ArrayList<Variable>();
	private HashMap<String, Variable> variableHashTable = new HashMap<String, Variable>();
	private Geometry geometry = null;
	private java.lang.String fieldName = new String("NoName");
	protected transient java.beans.VetoableChangeSupport vetoPropertyChange;
	protected transient java.beans.PropertyChangeSupport propertyChange;
	private java.lang.String fieldDescription = new String();
	private transient java.lang.String fieldWarning = null;
	private final PostProcessingBlock postProcessingBlock = new PostProcessingBlock(this);
	
	private ArrayList<Event> eventList = new ArrayList<Event>();

	private boolean bRegionSizeFunctionsUsed = false;
	
	/**
	 * {@link #getVCML()} will include comments
	 */
	private boolean commenting = false;

	private static final char NEWLINE_CHAR = '\n';

	private ArrayList<ParticleMolecularType> particleMolecularTypes = new ArrayList<ParticleMolecularType>();
	private static Logger lg = Logger.getLogger(MathDescription.class);
	
/**
 * MathDescription constructor comment.
 */
public MathDescription(Version argVersion) {
	super();
	this.version = argVersion;
	if (argVersion!=null){
		this.fieldName = argVersion.getName();
		this.fieldDescription = argVersion.getAnnot();
	}
}


/**
 * Insert the method's description here.
 * Creation date: (9/2/2004 3:05:54 PM)
 * @param mathDescription cbit.vcell.math.MathDescription
 */
public MathDescription(MathDescription mathDescription) {
	this.fieldName = mathDescription.getName();
	this.fieldDescription = mathDescription.getDescription();
	this.version = mathDescription.getVersion();
	this.geometry = mathDescription.getGeometry();
	try {
		read_database(new CommentStringTokenizer(mathDescription.getVCML_database()));
	}catch (MathException e){
		e.printStackTrace(System.out);
		throw new RuntimeException(e.getMessage());
	}
}


/**
 * MathDescription constructor comment.
 */
public MathDescription(String name) {
	this.fieldName = name;
	this.version = null;
}

/**
 * Add a javax.swing.event.ChangeListener.
 */
public void addChangeListener(ChangeListener newListener) {
	if (aChangeListener == null) {
		aChangeListener = new java.util.ArrayList<ChangeListener>();
	};
	if (! aChangeListener.contains(newListener)) {
		aChangeListener.add(newListener);
	}
}


/**
 * The addPropertyChangeListener method was generated to support the propertyChange field.
 */
public synchronized void addPropertyChangeListener(java.beans.PropertyChangeListener listener) {
	getPropertyChange().addPropertyChangeListener(listener);
}


/**
 * This method was created by a SmartGuide.
 * @param subDomain cbit.vcell.math.SubDomain
 * @exception java.lang.Exception The exception description.
 */
public void addSubDomain(SubDomain subDomain) throws MathException {
	addSubDomain0(subDomain);
	fireStateChanged();
}


/**
 * This method was created by a SmartGuide.
 * @param subDomain cbit.vcell.math.SubDomain
 * @exception java.lang.Exception The exception description.
 */
private void addSubDomain0(SubDomain subDomain) throws MathException {
	if (subDomain == null){
		throw new MathException("subdomain is null");
	}	
	if (subDomain instanceof CompartmentSubDomain){
		if (getCompartmentSubDomain(subDomain.getName()) != null){
			throw new MathException("subDomain "+subDomain.getName()+" already exists");
		}
	}else if (subDomain instanceof MembraneSubDomain){
		if (getMembraneSubDomain(subDomain.getName()) != null){
			throw new MathException("subDomain "+subDomain.getName()+" already exists");
		}
	}else if (subDomain instanceof FilamentSubDomain){
		if (getSubDomain(subDomain.getName()) != null){
			throw new MathException("subDomain "+subDomain.getName()+" already exists");
		}
	}	
	
	subDomainList.add(subDomain);
}


/**
 * This method was created by a SmartGuide.
 * @param var cbit.vcell.math.Variable
 */
public void addVariable(Variable var) throws MathException, ExpressionBindingException {
	addVariable0(var);
	fireStateChanged();
}


/**
 * This method was created by a SmartGuide.
 * @param var cbit.vcell.math.Variable
 */
private void addVariable0(Variable var) throws MathException, ExpressionBindingException {
	if (getVariable(var.getName()) != null){
		throw new MathException("variable "+var.getName()+" already exists");
	}
	variableList.add(var);
	variableHashTable.put(var.getName(), var);
	//var.bind(this);
	if (var instanceof VolVariable){
		//
		// for Volume Variables, also create an InsideVariable and an OutsideVariable for use in JumpConditions
		//
		InsideVariable inVar = new InsideVariable(var.getName()+InsideVariable.INSIDE_VARIABLE_SUFFIX, var.getName());
		variableList.add(inVar);
		variableHashTable.put(inVar.getName(), inVar);
		inVar.bind(this);
		OutsideVariable outVar = new OutsideVariable(var.getName()+OutsideVariable.OUTSIDE_VARIABLE_SUFFIX, var.getName());
		variableList.add(outVar);
		variableHashTable.put(outVar.getName(), outVar);
		outVar.bind(this);
	}
}


/**
 * The addVetoableChangeListener method was generated to support the vetoPropertyChange field.
 */
public synchronized void addVetoableChangeListener(java.beans.VetoableChangeListener listener) {
	getVetoPropertyChange().addVetoableChangeListener(listener);
}


/**
 * This method was created by a SmartGuide.
 */
private void clearAll() {
	subDomainList.clear();
	variableList.clear();
	variableHashTable.clear();
	eventList.clear();
}


/**
 * Insert the method's description here.
 * Creation date: (4/24/2003 3:32:01 PM)
 */
public void clearVersion() {
	version = null;
}


/**
 * This method was created in VisualAge.
 * @return boolean
 * @param mathDesc cbit.vcell.math.MathDescription
 */
public boolean compareEqual(Matchable object) {

	MathDescription mathDesc = null;
	if (object == null) {
		return false;
	}
	if (!(object instanceof MathDescription)) {
		return false;
	} else {
		mathDesc = (MathDescription) object;
	}

	if (!Compare.isEqual(getName(), mathDesc.getName())) {
		return false;
	}
	if (!Compare.isEqual(getDescription(), mathDesc.getDescription())) {
		return false;
	}
	//
	// compare subdomains
	//
	if (!Compare.isEqual(subDomainList, mathDesc.subDomainList)) {
		return false;
	}
	//
	// compare variables
	//
	if (!Compare.isEqual(variableList, mathDesc.variableList)) {
		return false;
	}
	//
	// compare geometry
	//
	if (!Compare.isEqualOrNull(geometry, mathDesc.geometry)) {
		return false;
	}

	//
	// compare events
	//
	if (!Compare.isEqual(eventList, mathDesc.eventList)) {
		return false;
	}
	//
	// compare particleMolecularTypes
	//
	if (!Compare.isEqual(particleMolecularTypes, mathDesc.particleMolecularTypes)) {
		return false;
	}

	if (!Compare.isEqualOrNull(postProcessingBlock, mathDesc.postProcessingBlock)) {
		return false;
	}

	return true;
}


/**
 * This method was created in VisualAge.
 * @return boolean
 * @param mathDesc cbit.vcell.math.MathDescription
 */
private MathCompareResults compareEquivalentCanonicalMath(MathDescription newMathDesc) {
	try {
		MathDescription oldMathDesc = this;
	    if (oldMathDesc.compareEqual(newMathDesc)){
		    return new MathCompareResults(Decision.MathEquivalent_FLATTENED);
		}else{
		    //if (!bSilent) System.out.println("------NATIVE MATHS ARE DIFFERENT----------------------");
			if (!oldMathDesc.postProcessingBlock.compareEqual(newMathDesc.postProcessingBlock)) {
				return new MathCompareResults(Decision.MathDifferent_DIFFERENT_PostProcessingBlock,"Post processing block does not match");
			}
			Variable oldVars[] = (Variable[])BeanUtils.getArray(oldMathDesc.getVariables(),Variable.class);
			Variable newVars[] = (Variable[])BeanUtils.getArray(newMathDesc.getVariables(),Variable.class);
			if (oldVars.length != newVars.length){
				//
				// number of state variables are not equal (canonical maths only have state variables)
				//
				return new MathCompareResults(Decision.MathDifferent_DIFFERENT_NUMBER_OF_VARIABLES);
			}
			if (!Compare.isEqual(oldVars,newVars)){
				//
				// variables are not strictly equal - must try to ignore domains and try again 
				//
				boolean bIgnoreMissingDomains = true;
				for (Variable oldVar : oldVars){
					boolean bFound = false;
					for (Variable newVar : newVars){
						if (oldVar.compareEqual(newVar, bIgnoreMissingDomains)){
							bFound = true;
							break;
						}
					}
					if (!bFound){
						//
						// variable names are not equivalent (nothing much we can do) ... what about change of variables???
						//
						return new MathCompareResults(Decision.MathDifferent_VARIABLES_DONT_MATCH,"variable '"+oldVar.getQualifiedName()+"' not matched");
					}
				}
				for (Variable newVar : newVars){
					boolean bFound = false;
					for (Variable oldVar : oldVars){
						if (newVar.compareEqual(oldVar, bIgnoreMissingDomains)){
							bFound = true;
							break;
						}
					}
					if (!bFound){
						//
						// variable names are not equivalent (nothing much we can do) ... what about change of variables???
						//
						return new MathCompareResults(Decision.MathDifferent_VARIABLES_DONT_MATCH,"variable '"+newVar.getQualifiedName()+"' not matched");
					}
				}
			}
			//
			// go through the list of SubDomains, and compare equations one by one and "correct" new one if possible
			//
			SubDomain subDomainsOld[] = (SubDomain[])BeanUtils.getArray(oldMathDesc.getSubDomains(),SubDomain.class);
			SubDomain subDomainsNew[] = (SubDomain[])BeanUtils.getArray(newMathDesc.getSubDomains(),SubDomain.class);
			if (subDomainsOld.length != subDomainsNew.length){
				return new MathCompareResults(Decision.MathDifferent_DIFFERENT_NUMBER_OF_SUBDOMAINS);
			}
			for (int i = 0; i < subDomainsOld.length; i++){
				// compare boundary type
				if (getGeometry().getDimension() > 0) {
					if (subDomainsOld[i] instanceof CompartmentSubDomain && subDomainsNew[i] instanceof CompartmentSubDomain) {
						CompartmentSubDomain csdOld = (CompartmentSubDomain)subDomainsOld[i];
						CompartmentSubDomain csdNew = (CompartmentSubDomain)subDomainsNew[i];
						if (!Compare.isEqualOrNull(csdOld.getBoundaryConditionXm(), csdNew.getBoundaryConditionXm())
								|| !Compare.isEqualOrNull(csdOld.getBoundaryConditionXp(), csdNew.getBoundaryConditionXp())
								|| !Compare.isEqualOrNull(csdOld.getBoundaryConditionYm(), csdNew.getBoundaryConditionYm())
								|| !Compare.isEqualOrNull(csdOld.getBoundaryConditionYp(), csdNew.getBoundaryConditionYp())
								|| !Compare.isEqualOrNull(csdOld.getBoundaryConditionZm(), csdNew.getBoundaryConditionZm())
								|| !Compare.isEqualOrNull(csdOld.getBoundaryConditionZp(), csdNew.getBoundaryConditionZp())
							) {
							return new MathCompareResults(Decision.MathDifferent_DIFFERENT_BC_TYPE);
						}					
					} else if (subDomainsOld[i] instanceof MembraneSubDomain && subDomainsNew[i] instanceof MembraneSubDomain) {
						MembraneSubDomain msdOld = (MembraneSubDomain)subDomainsOld[i];
						MembraneSubDomain msdNew = (MembraneSubDomain)subDomainsNew[i];
						if (!Compare.isEqualOrNull(msdOld.getBoundaryConditionXm(), msdNew.getBoundaryConditionXm())
								|| !Compare.isEqualOrNull(msdOld.getBoundaryConditionXp(), msdNew.getBoundaryConditionXp())
								|| !Compare.isEqualOrNull(msdOld.getBoundaryConditionYm(), msdNew.getBoundaryConditionYm())
								|| !Compare.isEqualOrNull(msdOld.getBoundaryConditionYp(), msdNew.getBoundaryConditionYp())
								|| !Compare.isEqualOrNull(msdOld.getBoundaryConditionZm(), msdNew.getBoundaryConditionZm())
								|| !Compare.isEqualOrNull(msdOld.getBoundaryConditionZp(), msdNew.getBoundaryConditionZp())
							) {
							return new MathCompareResults(Decision.MathDifferent_DIFFERENT_BC_TYPE);
						}					
						if (!compareUpdate(msdNew.getVelocityX( ), msdOld.getVelocityX( ),msdNew::setVelocityX)) {
							return new MathCompareResults(Decision.MathDifferent_DIFFERENT_VELOCITY, "x");
						}
						if (!compareUpdate(msdNew.getVelocityY( ), msdOld.getVelocityY( ),msdNew::setVelocityY)) {
							return new MathCompareResults(Decision.MathDifferent_DIFFERENT_VELOCITY, "y");
						}
					}
				}
				
				for (int j = 0; j < oldVars.length; j++){
					//
					// test equation for this subdomain and variable
					//
					{
					Equation oldEqu = subDomainsOld[i].getEquation(oldVars[j]);
					Equation newEqu = subDomainsNew[i].getEquation(oldVars[j]);
					if (!Compare.isEqualOrNull(oldEqu,newEqu)){
						boolean bFoundDifference = false;
						//
						// equation didn't compare exactly, lets try to evaluate some instead
						//
						if (oldEqu==null){
							//
							// only one MathDescription had Equation for this Variable.
							//
							return new MathCompareResults(Decision.MathDifferent_EQUATION_ADDED,
									"only one mathDescription had equation for '"+oldVars[j].getQualifiedName()+"' in SubDomain '"+subDomainsOld[i].getName()+"'");
						}
						if (newEqu==null){
							//
							// only one MathDescription had Equation for this Variable.
							//
							return new MathCompareResults(Decision.MathDifferent_EQUATION_REMOVED,
									"only one mathDescription had equation for '"+oldVars[j].getQualifiedName()+"' in SubDomain '"+subDomainsOld[i].getName()+"'");

						}
						ArrayList<Expression> oldExps = new ArrayList<Expression>();
						ArrayList<Expression> newExps = new ArrayList<Expression>();
						boolean bOdePdeMismatch = false;
						if (oldEqu instanceof PdeEquation && newEqu instanceof OdeEquation && oldEqu.getExpressions(newMathDesc).size()==3 && ((PdeEquation)oldEqu).getDiffusionExpression().isZero()){
							oldExps.add(oldEqu.getRateExpression());
							oldExps.add(oldEqu.getInitialExpression());
							newExps.add(newEqu.getRateExpression());
							newExps.add(newEqu.getInitialExpression());
							bOdePdeMismatch = true;
						}else if (oldEqu instanceof OdeEquation && newEqu instanceof PdeEquation && newEqu.getExpressions(newMathDesc).size()==3 && ((PdeEquation)newEqu).getDiffusionExpression().isZero()){
							oldExps.add(oldEqu.getRateExpression());
							oldExps.add(oldEqu.getInitialExpression());
							newExps.add(newEqu.getRateExpression());
							newExps.add(newEqu.getInitialExpression());
							bOdePdeMismatch = true;
						}else{
							oldExps.addAll(oldEqu.getExpressions(oldMathDesc));
							newExps.addAll(newEqu.getExpressions(newMathDesc));
						}
						if (oldExps.size() != newExps.size()){
							return new MathCompareResults(Decision.MathDifferent_DIFFERENT_NUMBER_OF_EXPRESSIONS,"equations have different number of expressions");
						}
						for (int k = 0; k < oldExps.size(); k++){
							if (!oldExps.get(k).compareEqual(newExps.get(k))){
								bFoundDifference = true;
								if (!ExpressionUtils.functionallyEquivalent(oldExps.get(k),newExps.get(k))){
									//
									// difference couldn't be reconciled
									//
									return new MathCompareResults(Decision.MathDifferent_DIFFERENT_EXPRESSION,
											"expressions are different Old: '"+oldExps.get(k)+"'\n"+"expressions are different New: '"+newExps.get(k)+"'");
								}else{
									//if (!bSilent) System.out.println("expressions are equivalent Old: '"+oldExps[k]+"'\n"+
													   //"expressions are equivalent New: '"+newExps[k]+"'");
								}
							}
						}
						if (!oldEqu.getVariable().compareEqual(newEqu.getVariable())){
							bFoundDifference = true;
							boolean bIgnoreMissingDomains = true;
							if (!oldEqu.getVariable().compareEqual(newEqu.getVariable(),bIgnoreMissingDomains)){
								return new MathCompareResults(Decision.MathDifferent_DIFFERENT_VARIABLE_IN_EQUATION,
										"var1='"+oldEqu.getVariable().getQualifiedName()+"', var2='"+newEqu.getVariable().getQualifiedName()+"'");
							}
						}
						//
						// equation was not strictly "equal" but passed all tests, replace with old equation and move on
						//
						if (bFoundDifference || bOdePdeMismatch){
							subDomainsNew[i].replaceEquation(oldEqu);
						}else{
							//
							// couldn't find the smoking gun, just plain bad
							//
							return new MathCompareResults(Decision.MathDifferent_UNKNOWN_DIFFERENCE_IN_EQUATION,
									"couldn't find problem with equation for "+oldVars[j].getName()+" in compartment "+subDomainsOld[i].getName());
						}
					}
					}
					
					{
						ParticleProperties oldPP = subDomainsOld[i].getParticleProperties(oldVars[j]);
						ParticleProperties newPP = subDomainsNew[i].getParticleProperties(oldVars[j]);
						if (!Compare.isEqualOrNull(oldPP, newPP)){
							return new MathCompareResults(Decision.MathDifferent_DIFFERENT_PARTICLE_PROPERTIES);
						}
					}
					//
					// if a membrane, test jumpCondition for this subdomain and variable
					//
					if (subDomainsOld[i] instanceof MembraneSubDomain && oldVars[j] instanceof VolVariable){
						JumpCondition oldJumpCondition = ((MembraneSubDomain)subDomainsOld[i]).getJumpCondition((VolVariable)oldVars[j]);
						JumpCondition newJumpCondition = ((MembraneSubDomain)subDomainsNew[i]).getJumpCondition((VolVariable)oldVars[j]);
						if (!Compare.isEqualOrNull(oldJumpCondition,newJumpCondition)){
							boolean bFoundDifference = false;
							//
							// equation didn't compare exactly, lets try to evaluate some instead
							//
							if (oldJumpCondition==null){
								//
								// only one MathDescription had Equation for this Variable.
								//
								return new MathCompareResults(Decision.MathDifferent_EQUATION_ADDED);
							}
							if (newJumpCondition==null){
								//
								// only one MathDescription had Equation for this Variable.
								//
								return new MathCompareResults(Decision.MathDifferent_EQUATION_REMOVED);
							}
							final Vector<Expression> oldJC = oldJumpCondition.getExpressions(oldMathDesc);
							Expression oldExps[] = oldJC.toArray(new Expression[oldJC.size()]);
							final Vector<Expression> newJC = newJumpCondition.getExpressions(newMathDesc);
							Expression newExps[] = newJC.toArray(new Expression[newJC.size()]);
							if (oldExps.length != newExps.length){
								return new MathCompareResults(Decision.MathDifferent_DIFFERENT_NUMBER_OF_EXPRESSIONS,"jump condition has different number of expressions");
							}
							for (int k = 0; k < oldExps.length; k++){
								if (!oldExps[k].compareEqual(newExps[k])){
									bFoundDifference = true;
									if (!ExpressionUtils.functionallyEquivalent(oldExps[k],newExps[k])){
										//
										// difference couldn't be reconciled
										//
										return new MathCompareResults(Decision.MathDifferent_DIFFERENT_EXPRESSION,
												"expressions are different Old: '"+oldExps[k]+"'\n"+
											   "expressions are different New: '"+newExps[k]+"'");
									}else{
										//if (!bSilent) System.out.println("expressions are equivalent Old: '"+oldExps[k]+"'\n"+
														   //"expressions are equivalent New: '"+newExps[k]+"'");
									}
								}
							}
							//
							// equation was not strictly "equal" but passed all tests, replace with old equation and move on
							//
							if (bFoundDifference){
								((MembraneSubDomain)subDomainsNew[i]).replaceJumpCondition(oldJumpCondition);
							}else{
								//
								// couldn't find the smoking gun, just plain bad
								//
								return new MathCompareResults(Decision.MathDifferent_UNKNOWN_DIFFERENCE_IN_EQUATION,
										"couldn't find problem with jumpCondition for "+oldVars[j].getName()+" in compartment "+subDomainsOld[i].getName());
							}
						}
					}
				}
				//
				// test fast system for subdomain
				//
				FastSystem oldFastSystem = subDomainsOld[i].getFastSystem();
				FastSystem newFastSystem = subDomainsNew[i].getFastSystem();
				if (!Compare.isEqualOrNull(oldFastSystem,newFastSystem)){
					boolean bFoundDifference = false;
					//
					// fastSystems didn't compare exactly, lets try to evaluate some expressions instead
					//
					if (oldFastSystem==null){
						//
						// only one MathDescription had Equation for this Variable.
						//
						return new MathCompareResults(Decision.MathDifferent_EQUATION_ADDED);
					}
					if (newFastSystem==null){
						//
						// only one MathDescription had Equation for this Variable.
						//
						return new MathCompareResults(Decision.MathDifferent_EQUATION_REMOVED);
					}
					Enumeration<Expression> oldFastInvExpEnum = oldFastSystem.getFastInvariantExpressions();
					Enumeration<Expression> newFastInvExpEnum = newFastSystem.getFastInvariantExpressions();
					Expression[] oldFastInvariantExps = (Expression[])BeanUtils.getArray(oldFastInvExpEnum, Expression.class);
					Expression[] newFastInvariantExps = (Expression[])BeanUtils.getArray(newFastInvExpEnum, Expression.class);
					if (oldFastInvariantExps.length != newFastInvariantExps.length){
						return new MathCompareResults(Decision.MathDifferent_DIFFERENT_NUMBER_OF_EXPRESSIONS,"fast invariants have different number of expressions");
					}
					for (int k = 0; k < oldFastInvariantExps.length; k++){
						if (!oldFastInvariantExps[k].compareEqual(newFastInvariantExps[k])){
							bFoundDifference = true;
							if (!ExpressionUtils.functionallyEquivalent(oldFastInvariantExps[k],newFastInvariantExps[k])){
								//
								// difference couldn't be reconciled
								// ... for fast invariants, it is ok if the two equations are different by a scale factor (e.g. if X+Y is conserved, so is 2*X+2*Y, or 2*(X+Y))
								//
								// estimate proportionality factor (average of 5 evaluations)
								// 
								// ratio = old/new
								//
								// then compare old with ratio*new.
								//
								Expression ratioExp = Expression.mult(oldFastInvariantExps[k], Expression.invert(newFastInvariantExps[k]));
								String[] symbols = ratioExp.getSymbols();
								SimpleSymbolTable symbolTable = new SimpleSymbolTable(symbols);
								double[] values = new double[symbols.length];
								ratioExp.bindExpression(symbolTable);
								Random random = new Random(0);
								double ratioAccum = 0.0;
								final int NUM_TRIALS = 5;
								for (int m = 0; m < NUM_TRIALS; m++){
									for (int j = 0; j < values.length; j++) {
										values[j] = random.nextDouble()+1.0;
									}
									ratioAccum += ratioExp.evaluateVector(values);
								}								
								double estimatedRatio = ratioAccum/NUM_TRIALS;
								Expression scaled_newFastInvariantExp = Expression.mult(new Expression(estimatedRatio),newFastInvariantExps[k]);
								System.out.println("MathDescription.compareEquivalent(): comparing "+oldFastInvariantExps[k].infix()+" with "+scaled_newFastInvariantExp.infix());
								if (!ExpressionUtils.functionallyEquivalent(oldFastInvariantExps[k], scaled_newFastInvariantExp)){
									return new MathCompareResults(Decision.MathDifferent_DIFFERENT_FASTINV_EXPRESSION,
											"fast invariant expressions are different Old: '"+oldFastInvariantExps[k]+"'\n"+
											 "fast invariant expressions are different New: '"+newFastInvariantExps[k]+"'");
								}
								//if (!bSilent) System.out.println("fast invariant expressions are proportional Old: '"+oldFastInvariantExps[k]+"'\n"+
								//   "fast invariant expressions are proportional New: '"+newFastInvariantExps[k]+"'");
							}else{
								//if (!bSilent) System.out.println("expressions are equivalent Old: '"+oldExps[k]+"'\n"+
												   //"expressions are equivalent New: '"+newExps[k]+"'");
							}
						}
					}
					Enumeration<Expression> oldFastRateExpEnum = oldFastSystem.getFastRateExpressions();
					Enumeration<Expression> newFastRateExpEnum = newFastSystem.getFastRateExpressions();
					Expression[] oldFastRateExps = (Expression[])BeanUtils.getArray(oldFastRateExpEnum, Expression.class);
					Expression[] newFastRateExps = (Expression[])BeanUtils.getArray(newFastRateExpEnum, Expression.class);
					if (oldFastRateExps.length != newFastRateExps.length){
						return new MathCompareResults(Decision.MathDifferent_DIFFERENT_NUMBER_OF_EXPRESSIONS,"fast rates have different number of expressions");
					}
					for (int k = 0; k < oldFastRateExps.length; k++){
						if (!oldFastRateExps[k].compareEqual(newFastRateExps[k])){
							bFoundDifference = true;
							if (!ExpressionUtils.functionallyEquivalent(oldFastRateExps[k],newFastRateExps[k])){
								//
								// difference couldn't be reconciled
								//
								return new MathCompareResults(Decision.MathDifferent_DIFFERENT_FASTRATE_EXPRESSION,
										"fast rate expressions are different Old: '"+oldFastRateExps[k]+"'\n"+
										"fast rate expressions are different New: '"+newFastRateExps[k]+"'");
							}else{
								//if (!bSilent) System.out.println("expressions are equivalent Old: '"+oldExps[k]+"'\n"+
												   //"expressions are equivalent New: '"+newExps[k]+"'");
							}
						}
					}
					//
					// equation was not strictly "equal" but passed all tests, replace with old equation and move on
					//
					if (bFoundDifference){
						subDomainsNew[i].setFastSystem(oldFastSystem);
					}else{
						//
						// couldn't find the smoking gun, just plain bad
						//
						return new MathCompareResults(Decision.MathDifferent_UNKNOWN_DIFFERENCE_IN_EQUATION,
								"couldn't find problem with FastSystem for compartment "+subDomainsOld[i].getName());
					}
				}
				
				List<ParticleJumpProcess> oldPjpList = subDomainsOld[i].getParticleJumpProcesses();
				List<ParticleJumpProcess> newPjpList = subDomainsNew[i].getParticleJumpProcesses();
				if (oldPjpList.size() != newPjpList.size()) {
					return new MathCompareResults(Decision.MathDifferent_DIFFERENT_NUMBER_OF_PARTICLE_JUMP_PROCESS);
				}
				for (ParticleJumpProcess oldPjp : oldPjpList) {
					boolean bEqual = false;
					for (ParticleJumpProcess newPjp : newPjpList) {
						if (oldPjp.getName().equals(newPjp.getName())) {
							if (oldPjp.compareEqual(newPjp)) {
								bEqual = true;
							}
							break;
						}
					}
					if (!bEqual) {
						return new MathCompareResults(Decision.MathDifferent_DIFFERENT_PARTICLE_JUMP_PROCESS);
					}
				}
			}

			//
			// after repairing aspects of MathDescription, now see if same
			//
			return oldMathDesc.compareInvariantAttributes(newMathDesc,true);
		}
	}catch (Throwable e){
		e.printStackTrace(System.out);
		return new MathCompareResults(Decision.MathDifferent_FAILURE_UNKNOWN);
	}
}

/**
 * compare two expressions; if different but functionally equivalent, set the new to be the same as the old 
 * @param nExp
 * @param oExp
 * @param newSet nExp setter, non null
 * @return true if both null, or equal / equivalent 
 */
private static boolean compareUpdate(Expression nExp, Expression oExp, Consumer<Expression> newSet) {
	
	Objects.requireNonNull(newSet);
	switch (Compare.nullState(nExp, oExp) ) {
		case BOTH_NULL:
			return true;
		case FIRST_NULL: 
		case SECOND_NULL: 
			return false;
		case NEITHER_NULL:
			//fall-through
	}
	
	if (Compare.isEqual(nExp,oExp)) {
		return true;
	}
	if (ExpressionUtils.functionallyEquivalent(nExp,oExp)) {
		newSet.accept(oExp);
	}
	return false;
}




/**
 * This method was created in VisualAge.
 * @return boolean
 * @param mathDesc cbit.vcell.math.MathDescription
 */
private MathCompareResults compareInvariantAttributes(MathDescription newMathDesc, boolean bAlreadyFlattened){
	//
	// making cannonical math descriptions is expensive, so the idea is to quickly identify those differences that are invariant of any cannonical form.
	//

	
	//
	// compare subdomain names and types only SubDomain.compareEqual() would recursively compare all of the equations.
	//
	if (subDomainList.size()!=newMathDesc.subDomainList.size()){
		return new MathCompareResults(Decision.MathDifferent_DIFFERENT_NUMBER_OF_SUBDOMAINS);
	}
	for (int i = 0; i < subDomainList.size(); i++){
		SubDomain subDomain = subDomainList.get(i);
		SubDomain otherSubDomain = newMathDesc.getSubDomain(subDomain.getName());
		if (otherSubDomain==null || !otherSubDomain.getClass().equals(subDomain.getClass())){
			return new MathCompareResults(Decision.MathDifferent_SUBDOMAINS_DONT_MATCH);
		}		
	}
	
	//
	// compare state variables (make sure number of state variables are equal).
	//
	HashSet<String> thisStateVarHash = getStateVariableNames();
	HashSet<String> otherStateVarHash = newMathDesc.getStateVariableNames();
	if (thisStateVarHash.size() != otherStateVarHash.size()){
		return new MathCompareResults(Decision.MathDifferent_DIFFERENT_NUMBER_OF_VARIABLES);
	}
	//
	// disregard vars present in both sets (for efficiency).
	//
	HashSet<String> intersectionStateVarHash = new HashSet<String>(thisStateVarHash);
	intersectionStateVarHash.retainAll(otherStateVarHash);
	//
	// if intersection of state variables is smaller than entire set, 
	// then must make sure that each missing state variable exists as a Function (dependent variable).
	//
	if (intersectionStateVarHash.size()!=thisStateVarHash.size()){
		// trim both sets to remove intersection
		thisStateVarHash.removeAll(intersectionStateVarHash);
		otherStateVarHash.removeAll(intersectionStateVarHash);
		//
		// check this MathDescription's (extra) state variables are present in other MathDescription (as Function).
		//
		Iterator<String> iter = thisStateVarHash.iterator();
		while (iter.hasNext()){
			String varName = iter.next();
			Variable var = newMathDesc.getVariable(varName);
			if (var==null || !(var instanceof Function)){
				return new MathCompareResults(Decision.MathDifferent_VARIABLE_NOT_FOUND_AS_FUNCTION);
			}
		}
		//
		// check other MathDescription's (extra) state variables are present in this MathDescription (as Function).
		//
		iter = otherStateVarHash.iterator();
		while (iter.hasNext()){
			String varName = iter.next();
			Variable var = getVariable(varName);
			if (var==null || !(var instanceof Function)){
				return new MathCompareResults(Decision.MathDifferent_VARIABLE_NOT_FOUND_AS_FUNCTION);
			}
		}
	}
	
	//
	// compare geometry
	//
	if (!Compare.isEqualOrNull(
			(geometry != null?geometry.getGeometrySpec():null),
			(newMathDesc.geometry != null?newMathDesc.geometry.getGeometrySpec():null))) {
		return new MathCompareResults(Decision.MathDifferent_GEOMETRYSPEC_DIFFERENT);
	}

	if (bAlreadyFlattened){
		return new MathCompareResults(Decision.MathEquivalent_FLATTENED);
	}else{
		return new MathCompareResults(Decision.MathEquivalent_NATIVE);
	}
}


/**
 * Insert the method's description here.
 * Creation date: (10/9/2002 10:54:06 PM)
 * @return cbit.vcell.math.MathDescription
 */
public static MathDescription createCanonicalMathDescription(MathSymbolTableFactory mathSymbolTableFactory, MathDescription originalMathDescription) throws MathException, ExpressionException {
	//
	// clone current mathdescription
	//
	MathDescription newMath = new MathDescription(originalMathDescription);

	newMath.makeCanonical(mathSymbolTableFactory);

	return newMath;
}


/**
 * Insert the method's description here.
 * Creation date: (10/9/2002 10:54:06 PM)
 * @return cbit.vcell.math.MathDescription
 */
public static MathDescription createMathWithExpandedEquations(MathDescription originalMathDescription, HashSet<String> varNamesToKeep) throws MathException, ExpressionException {
	//
	// clone current mathdescription
	//
	MathDescription newMath = new MathDescription(originalMathDescription);

	//
	// for any dependent variables in the "varNamesToKeep" list, create appropriate Variable/Equation
	//
	// this assumes that the dependent 'Function' is a linear combination of existing state variables
	//  e.g. Function depVar = K0 + K1*indepVar1 + K2*indepVar2 + ... + Kn*indepVarN
	// if it doesn't fit this form, then math's are not equivalent.
	//
	HashSet<String> stateVarSet = newMath.getStateVariableNames();
	for (int i = 0; i < newMath.variableList.size(); i++){
		Variable tmp_var = newMath.variableList.get(i);
		if (varNamesToKeep.contains(tmp_var.getName()) && tmp_var instanceof Function){
			Function function = (Function)tmp_var;
			//
			// get list of symbols that are state variables
			//
			ArrayList<Variable> indepVarList = new ArrayList<Variable>();         // holds the "indepVar's"
			ArrayList<Expression> coefficientList = new ArrayList<Expression>();      // holds the "K's"
			Expression exp = function.getExpression();
			exp.bindExpression(null);
			Expression K0 = new Expression(exp);
			K0.bindExpression(null);
			String symbols[] = exp.getSymbols();
			for (int j = 0; j < symbols.length; j++){
				if (stateVarSet.contains(symbols[j])){
					//
					// store the independent variable (indepVar_i)
					//
					indepVarList.add(newMath.getVariable(symbols[j]));
					Expression differential = exp.differentiate(symbols[j]);
					differential = differential.flatten();
					//
					// store the coefficient (K_i)
					//
					coefficientList.add(differential);
					//
					// remove this term from the "constant" term (K0)
					// (e.g. for expression "K0 + K1*V1 + ... + Ki*Vi + ... + Kn*Vn", Vi set to 0.0 and flattened)
					// after each term is removed, only K0 is left
					//
					K0.substituteInPlace(new Expression(symbols[j]),new Expression(0.0));
					K0 = K0.flatten();
				}
			}
			//
			// either all independent vars should be Volume, all should be Membrane, or all should be Filament 
			//
			int countVolumeVars = 0;
			int countMembraneVars = 0;
			int countFilamentVars = 0;
			int countPointVars = 0;
			for (int j = 0; j < indepVarList.size(); j++){
				if (indepVarList.get(j) instanceof VolVariable){
					countVolumeVars++;
				}else if (indepVarList.get(j) instanceof MemVariable){
					countMembraneVars++;
				}else if (indepVarList.get(j) instanceof FilamentVariable){
					countFilamentVars++;
				}else if (indepVarList.get(j) instanceof PointVariable){
					countPointVars++;
				}else{
					throw new RuntimeException("create canonicalMath cannot handle dependent vars of type '"+indepVarList.get(j).getClass().getName()+"'");
				}
			}
			//
			// case: Volume Variable
			// create VolVariable
			// for each CompartmentSubDomain, create OdeEquation
			// remove Function
			//
			if (countVolumeVars == indepVarList.size()){
				VolVariable volVariable = new VolVariable(function.getName(),function.getDomain());
				newMath.variableList.remove(function);
				newMath.variableList.add(volVariable);
				newMath.variableHashTable.remove(function.getName());
				newMath.variableHashTable.put(volVariable.getName(), volVariable);
				for (int j = 0; j < newMath.subDomainList.size(); j++){
					SubDomain subDomain = newMath.subDomainList.get(j);
					if (subDomain instanceof CompartmentSubDomain){
						//
						// add an ODE where 
						//    initial value = K0 + Sum(coefficient_i*Var_i.init)
						//    rate value = Sum(coefficient_i*Var_i.rate)
						//
						Expression initExp = new Expression(K0);
						Expression rateExp = new Expression(0.0);
						for (int k = 0; k < indepVarList.size(); k++){
							Variable indepVar = indepVarList.get(k);
							Equation indepVarEqu = subDomain.getEquation(indepVar);
							Expression coefficient = coefficientList.get(k);
							initExp = Expression.add(initExp,Expression.mult(new Expression(coefficient),new Expression(indepVarEqu.getInitialExpression())));
							rateExp = Expression.add(rateExp,Expression.mult(new Expression(coefficient),new Expression(indepVarEqu.getRateExpression())));
						}
						Variable initVariable = null;
						for (int k=0;k<newMath.variableList.size();k++){
							if (newMath.variableList.get(k).getName().startsWith(function.getName()+MATH_FUNC_INIT_SUFFIX_PREFIX)){
								initVariable = newMath.variableList.get(i);
								initExp = new Expression(initVariable,null);
								break;
							}
						}
						OdeEquation odeEquation = new OdeEquation(volVariable, initExp.flatten(), rateExp.flatten());
						subDomain.addEquation(odeEquation);
					}
				}
			//
			// case: Membrane Variable
			//
			}else if (countMembraneVars == indepVarList.size()){
				MemVariable memVariable = new MemVariable(function.getName(),function.getDomain());
				newMath.variableList.remove(function);
				newMath.variableList.add(memVariable);
				newMath.variableHashTable.remove(function.getName());
				newMath.variableHashTable.put(memVariable.getName(), memVariable);				
				for (int j = 0; j < newMath.subDomainList.size(); j++){
					SubDomain subDomain = newMath.subDomainList.get(j);
					if (subDomain instanceof MembraneSubDomain){
						//
						// add an ODE where 
						//    initial value = K0 + Sum(coefficient_i*Var_i.init)
						//    rate value = Sum(coefficient_i*Var_i.rate)
						//
						Expression initExp = new Expression(K0);
						Expression rateExp = new Expression(0.0);
						for (int k = 0; k < indepVarList.size(); k++){
							Variable indepVar = indepVarList.get(k);
							Equation indepVarEqu = subDomain.getEquation(indepVar);
							Expression coefficient = coefficientList.get(k);
							initExp = Expression.add(initExp,Expression.mult(new Expression(coefficient),new Expression(indepVarEqu.getInitialExpression())));
							rateExp = Expression.add(rateExp,Expression.mult(new Expression(coefficient),new Expression(indepVarEqu.getRateExpression())));
						}
						Variable initVariable = null;
						for (int k=0;k<newMath.variableList.size();k++){
							if (newMath.variableList.get(k).getName().startsWith(function.getName()+MATH_FUNC_INIT_SUFFIX_PREFIX)){
								initVariable = newMath.variableList.get(i);
								initExp = new Expression(initVariable,null);
								break;
							}
						}
						OdeEquation odeEquation = new OdeEquation(memVariable, initExp.flatten(), rateExp.flatten());
						subDomain.addEquation(odeEquation);
					}
				}
			//
			// case: Filament Variable
			//
			}else if (countFilamentVars == indepVarList.size()){
				throw new RuntimeException("create canonicalMath cannot handle function of variables of type 'FilamentVariable'");
				
			//
			// case: Point Variable
			//
			}else if (countPointVars == indepVarList.size()){
				throw new RuntimeException("create canonicalMath cannot handle function of variables of type 'PointVariable'");

			//
			//
			//
			}else{
				throw new RuntimeException("create canonicalMath cannot handle mixture of dependent vars types");
			}
		}	
	}
	
	return newMath;
}

/**
 * The firePropertyChange method was generated to support the propertyChange field.
 */
public void firePropertyChange(java.lang.String propertyName, java.lang.Object oldValue, java.lang.Object newValue) {
	getPropertyChange().firePropertyChange(propertyName, oldValue, newValue);
}

/**
 * Method to support listener events.
 */
protected void fireStateChanged() {
	if (aChangeListener != null) {
		ChangeEvent e = new ChangeEvent(this);
		for ( ChangeListener listener : aChangeListener) {
			listener.stateChanged(e);
		}
	}
}

/**
 * The fireVetoableChange method was generated to support the vetoPropertyChange field.
 */
public void fireVetoableChange(java.lang.String propertyName, java.lang.Object oldValue, java.lang.Object newValue) throws java.beans.PropertyVetoException {
	getVetoPropertyChange().fireVetoableChange(propertyName, oldValue, newValue);
}

/**
 * This method was created by a SmartGuide.
 * @param tokens java.util.StringTokenizer
 * @exception java.lang.Exception The exception description.
 */
public static MathDescription fromEditor(MathDescription oldMathDesc, String vcml) throws MathException, java.beans.PropertyVetoException {
	
	CommentStringTokenizer tokens = new CommentStringTokenizer(vcml);
	MathDescription mathDesc = new MathDescription(oldMathDesc.getVersion());
	mathDesc.clearAll();
	mathDesc.setGeometry0(oldMathDesc.getGeometry());
	mathDesc.read_database(tokens);

	//
	// compute warning string (if necessary)
	//
	if (!mathDesc.isValid()){
		System.out.println("Math is invalid, warning = '"+mathDesc.getWarning()+"'");
	}
	
	return mathDesc;
}


/**
 * This method was created by a SmartGuide.
 * @return cbit.vcell.math.SubDomain
 * @param handle int
 */
public CompartmentSubDomain getCompartmentSubDomain(String name) {
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()){
		SubDomain subDomain = enum1.nextElement();
		if (subDomain instanceof CompartmentSubDomain){
			CompartmentSubDomain compartment = (CompartmentSubDomain)subDomain;
			if (compartment.getName().equals(name)){
				return compartment;
			}
		}	
	}
	return null;		
}


/**
 * Insert the method's description here.
 * Creation date: (8/21/00 1:14:56 PM)
 * @return java.util.Enumeration
 */
public Enumeration<Constant> getConstants() {
	return new Enumeration<Constant>() {
	    int count = 0;

	    public boolean hasMoreElements() {
		    for (int i=count;i<variableList.size();i++){
			    if (variableList.get(i) instanceof Constant){
				    return true;
			    }
		    }
		    return false;
	    }

	    public Constant nextElement() {
			synchronized (variableList) {
			    for (int i=count;i<variableList.size();i++){
				    if (variableList.get(i) instanceof Constant){
					    count = i+1;
					    return (Constant)variableList.get(i);
				    }
			    }
			}
			throw new NoSuchElementException("ArrayList Enumeration (Constant)");
	    }
	};
}


/**
 * Gets the description property (java.lang.String) value.
 * @return The description property value.
 * @see #setDescription
 */
public java.lang.String getDescription() {
	return fieldDescription;
}


/**
 * This method was created by a SmartGuide.
 * @return cbit.vcell.parser.SymbolTableEntry
 * @param id java.lang.String
 * @param qualifier java.lang.String
 * @exception java.lang.Exception The exception description.
 */
public SymbolTableEntry getEntry(String id) {
	SymbolTableEntry entry = null;
	
	entry = ReservedMathSymbolEntries.getEntry(id,false);
	if (entry != null){
		if (entry instanceof SymbolTableFunctionEntry){
			if (entry.equals(MathFunctionDefinitions.Function_regionArea_current)
				|| entry.equals(MathFunctionDefinitions.Function_regionArea_indexed)
				|| entry.equals(MathFunctionDefinitions.Function_regionVolume_current)
				|| entry.equals(MathFunctionDefinitions.Function_regionVolume_indexed)) {
				bRegionSizeFunctionsUsed = true;
			}
		}
		return entry;
	}
	
	entry = getVariable(id);
	if (entry != null){
		return entry;
	}
	
	return null;
}


/**
 * Insert the method's description here.
 * Creation date: (8/21/00 1:14:56 PM)
 * @return java.util.Enumeration
 */
public Enumeration<FilamentVariable> getFilamentVariables() {
	return new Enumeration<FilamentVariable>() {
	    int count = 0;

	    public boolean hasMoreElements() {
		    for (int i=count;i<variableList.size();i++){
			    if (variableList.get(i) instanceof FilamentVariable){
				    return true;
			    }
		    }
		    return false;
	    }

	    public FilamentVariable nextElement() {
			synchronized (variableList) {
			    for (int i=count;i<variableList.size();i++){
				    if (variableList.get(i) instanceof FilamentVariable){
					    count = i+1;
					    return (FilamentVariable)variableList.get(i);
				    }
			    }
			}
			throw new NoSuchElementException("ArrayList Enumeration (FilamentVariable)");
	    }
	};
}


/**
 * Insert the method's description here.
 * Creation date: (10/9/2002 10:54:06 PM)
 * @return cbit.vcell.math.MathDescription
 */
public static Function[] getFlattenedFunctions(MathSymbolTableFactory mathSymbolTableFactory, MathDescription originalMathDescription, String functionNames[]) throws MathException, ExpressionException {
	//
	// clone current mathdescription
	//
	MathDescription newMath = new MathDescription(originalMathDescription);

	//
	// make a "identity" simulation (no overrides), this will help to substitute/flatten expressions.
	//
	MathSymbolTable simSymbolTable = mathSymbolTableFactory.createMathSymbolTable(newMath);
	Function functions[] = new Function[functionNames.length];
	for (int i = 0; i < functionNames.length; i++){
		for (int j = 0; j < originalMathDescription.variableList.size(); j++){
			Variable var = originalMathDescription.variableList.get(j);
			if (var.getName().equals(functionNames[i])){
				if (var instanceof Function){
					Function function = (Function)var;
					Expression exp1 = new Expression(function.getExpression());
					try {
						exp1 = simSymbolTable.substituteFunctions(exp1);
						functions[i] = new Function(function.getName(),exp1.flatten(),function.getDomain());
					} catch (MathException e) {
						e.printStackTrace(System.out);
						throw new RuntimeException("Substitute function failed on function "+function.getName()+" "+e.getMessage());
					}
				}
			}
		}
	}
	return functions;
}


/**
 * Insert the method's description here.
 * Creation date: (8/21/00 1:14:56 PM)
 * @return java.util.Enumeration
 */
public Enumeration<Function> getFunctions() {
	return new Enumeration<Function>() {
	    int count = 0;

	    public boolean hasMoreElements() {
		    for (int i=count;i<variableList.size();i++){
			    if (variableList.get(i) instanceof Function){
				    return true;
			    }
		    }
		    return false;
	    }

	    public Function nextElement() {
			synchronized (variableList) {
			    for (int i=count;i<variableList.size();i++){
				    if (variableList.get(i) instanceof Function){
					    count = i+1;
					    return (Function)variableList.get(i);
				    }
			    }
			}
			throw new NoSuchElementException("ArrayList Enumeration (Function)");
	    }
	};
}


/**
 * This method was created in VisualAge.
 * @return cbit.vcell.geometry.Geometry
 */
public Geometry getGeometry() {
	return geometry;
}


/**
 * This method was created in VisualAge.
 * @return int
 * @param compartmentSubDomain cbit.vcell.math.CompartmentSubDomain
 * @throws MathException 
 */
public int getHandle(CompartmentSubDomain compartmentSubDomain) throws MathException  {
	SubVolume subVolume = geometry.getGeometrySpec().getSubVolume(compartmentSubDomain.getName());
	if (subVolume ==null){
		throw new MathException("couldn't find a subVolume named "+compartmentSubDomain+" in Geometry");
	}
	return subVolume.getHandle();
}

/**
 * This method was created in VisualAge.
 * @return KeyValue
 */
public KeyValue getKey() {
	return (getVersion()!=null)?getVersion().getVersionKey():null;
}


/**
 * This method was created by a SmartGuide.
 * @return cbit.vcell.math.SubDomain
 * @param name java.lang.String
 * @exception java.lang.Exception The exception description.
 */
public MembraneSubDomain getMembraneSubDomain(CompartmentSubDomain compartment1, CompartmentSubDomain compartment2) {
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()){
		SubDomain subDomain = enum1.nextElement();
		if (subDomain instanceof MembraneSubDomain){
			MembraneSubDomain membraneSubDomain = (MembraneSubDomain)subDomain;
			if ((membraneSubDomain.getInsideCompartment()==compartment1 && membraneSubDomain.getOutsideCompartment()==compartment2) ||
				(membraneSubDomain.getInsideCompartment()==compartment2 && membraneSubDomain.getOutsideCompartment()==compartment1)){
				return membraneSubDomain;
			}
		}	
	}
	return null;
}


/**
 * This method was created by a SmartGuide.
 * @return cbit.vcell.math.SubDomain
 * @param name java.lang.String
 * @exception java.lang.Exception The exception description.
 */
private MembraneSubDomain getMembraneSubDomain(String membraneName) {
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()){
		SubDomain subDomain = enum1.nextElement();
		if (subDomain instanceof MembraneSubDomain){
			MembraneSubDomain membrane = (MembraneSubDomain)subDomain;
			if (membrane.getName().equalsIgnoreCase(membraneName)){
				return membrane;
			}
		}	
	}
	return null;		
}


/**
 * This method was created by a SmartGuide.
 * @return cbit.vcell.math.SubDomain
 * @param name java.lang.String
 * @exception java.lang.Exception The exception description.
 */
public MembraneSubDomain[] getMembraneSubDomains(CompartmentSubDomain compartment) {
	ArrayList<MembraneSubDomain> membraneSubDomainList = new ArrayList<MembraneSubDomain>();
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()){
		SubDomain subDomain = enum1.nextElement();
		if (subDomain instanceof MembraneSubDomain){
			MembraneSubDomain membraneSubDomain = (MembraneSubDomain)subDomain;
			if ((membraneSubDomain.getInsideCompartment() == compartment) || (membraneSubDomain.getOutsideCompartment() == compartment)){
				membraneSubDomainList.add(membraneSubDomain);
			}
		}	
	}
	return membraneSubDomainList.toArray(new MembraneSubDomain[membraneSubDomainList.size( )]);
}


/**
 * Gets the name property (java.lang.String) value.
 * @return The name property value.
 * @see #setName
 */
public java.lang.String getName() {
	return fieldName;
}


/**
 * Insert the method's description here.
 * Creation date: (4/22/2001 7:18:42 PM)
 * @return int
 */
public int getNumVariables() {
	return variableList.size();
}


/**
 * Accessor for the propertyChange field.
 */
protected java.beans.PropertyChangeSupport getPropertyChange() {
	if (propertyChange == null) {
		propertyChange = new java.beans.PropertyChangeSupport(this);
	};
	return propertyChange;
}

/**
 * Insert the method's description here.
 * Creation date: (11/24/2004 7:20:17 AM)
 * @return cbit.vcell.math.Variable[]
 */
public HashSet<String> getStateVariableNames() {
	HashSet<String> stateVarNameSet = new HashSet<String>();
	for (int i = 0; i < variableList.size(); i++){
		Variable var = variableList.get(i);
		if (var instanceof VolVariable || var instanceof MemVariable || var instanceof FilamentVariable ||
			var instanceof VolumeRegionVariable || var instanceof MembraneRegionVariable || var instanceof FilamentRegionVariable){
			stateVarNameSet.add(var.getName());
		}
	}
	return stateVarNameSet;
}


/**
 * This method was created by a SmartGuide.
 * @return cbit.vcell.math.SubDomain
 * @param name java.lang.String
 * @exception java.lang.Exception The exception description.
 */
public SubDomain getSubDomain(String name) {
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()){
		SubDomain subDomain = enum1.nextElement();
		if (subDomain.getName().equals(name)){
			return subDomain;
		}	
	}
	return null;		
}


/**
 * This method was created by a SmartGuide.
 * @return java.util.Enumeration
 */
public Enumeration<SubDomain> getSubDomains() {
	return Collections.enumeration(subDomainList);
}

/**
 * Collection equivalent of {@link #getSubDomains()}
 * @return unmodifiable collection
 */
public Collection<SubDomain> getSubDomainCollection() {
	return Collections.unmodifiableCollection(subDomainList);
}

/**
 * This method was created by a SmartGuide.
 * @return cbit.vcell.math.Variable
 * @param name java.lang.String
 */
public Variable getVariable(String name) {
	return variableHashTable.get(name);	
}


/**
 * This method was created by a SmartGuide.
 * @return java.util.Enumeration
 */
public Enumeration<Variable> getVariables() {
	return Collections.enumeration(variableList);
}

public Iterator<Event> getEvents() {
	return eventList.iterator();
}

public int getNumEvents() {
	return eventList.size();
}

/**
 * Insert the method's description here.
 * Creation date: (11/29/00 12:39:15 PM)
 * @return java.lang.String
 */
public String getVCML() throws MathException {
	return getVCML_database();
}

private String getVCML(VCMLProvider obj) throws MathException {
	final char SPACE = ' ';
	if (commenting) {
		String before = obj.getBeforeComment();
		String after = obj.getAfterComment();
		StringBuilder sb = new StringBuilder();
		if (before != null) {
			sb.append(SPACE);
			sb.append(Commented.BEFORE_COMMENT);
			sb.append(SPACE);
			sb.append(before);
			sb.append(SPACE);
			sb.append(Commented.END_BEFORE_COMMENT);
			sb.append(NEWLINE_CHAR);
		}
		if (after == null) {
			sb.append(obj.getVCML());
		}
		else {
			String baseVCML = obj.getVCML().trim( );
			
			//look for newline at very end of String, but don't flag newlines in the midst of the text
			int newlinePos = Commented.CHAR_NOT_FOUND; 
			int scan = baseVCML.length() - 1;
			while (baseVCML.charAt(scan) == NEWLINE_CHAR) {
				newlinePos = scan;
				--scan;
				if (scan == 0) {
					throw new MathException(obj.getClass().getSimpleName() + "#getVCML( ) returned empty String");
				}
			}
			boolean hasNewline = newlinePos != Commented.CHAR_NOT_FOUND;
			if (hasNewline) { //if new line present, remove for now
				baseVCML = baseVCML.substring(0,newlinePos);
			}
			sb.append(baseVCML);
			sb.append(SPACE);
			sb.append(Commented.AFTER_COMMENT);
			sb.append(SPACE);
			sb.append(after);
			if (hasNewline) { //now add newline back if it was present
				sb.append(NEWLINE_CHAR);
			}
		}
		return sb.toString();
	}
	return obj.getVCML();

}
/**
 * add variables of specific type to output. Add newline if any variables added. 
 * @param clzz class or superclass of desired variable
 * @param buffer where to add output
 * @param needsNewline TODO
 * @throws MathException from {@link Variable#getVCML()}
 */
private <T extends Variable> void addVariablesOfType(Class<T> clzz, StringBuilder buffer, boolean needsNewline) throws MathException {
	int start = buffer.length();
	for (Variable var: variableList) {
		if (clzz.isAssignableFrom(var.getClass())) {
			buffer.append(getVCML(var));
			if (needsNewline) {
				buffer.append(NEWLINE_CHAR);
			}
		}
	}
	if (buffer.length( ) !=  start) {
		buffer.append(NEWLINE_CHAR);
	}
}

/**
 * @return {@link #getVCML_database(boolean)} with comments on
 * @throws MathException
 */
public String getVCML_database() throws MathException {
	return getVCML_database(true);
}

/**
 * get VCML representation
 * @param includeComments if true, includes comments for elements
 * @return VCML
 * @throws MathException
 */
public String getVCML_database(boolean includeComments) throws MathException {
	commenting = includeComments;
		
	//
	// regular VCML exception, no name, and no geometry
	//
	StringBuilder buffer = new StringBuilder();
	buffer.append(VCML.MathDescription+" {\n");
	buffer.append("\n");
	
	addVariablesOfType(ParameterVariable.class,buffer, true);
	addVariablesOfType(Constant.class,buffer, true);
	addVariablesOfType(VolVariable.class,buffer, true);
	addVariablesOfType(MemVariable.class,buffer, true);
	addVariablesOfType(VolumeRegionVariable.class,buffer, true);
	addVariablesOfType(MembraneRegionVariable.class,buffer, true);
	addVariablesOfType(FilamentVariable.class,buffer, true);
	addVariablesOfType(FilamentRegionVariable.class,buffer, true);
	addVariablesOfType(PointVariable.class,buffer, true);
	addVariablesOfType(StochVolVariable.class,buffer, false);
	addVariablesOfType(VolumeParticleVariable.class,buffer, false);
	addVariablesOfType(MembraneParticleVariable.class,buffer, false);
	// ParticleMolecularType
	boolean bSpaceNeeded = false;
	for (ParticleMolecularType particleMolecularType : particleMolecularTypes){
		buffer.append(particleMolecularType.getVCML());
		bSpaceNeeded = true;
	}
	if (bSpaceNeeded){
		buffer.append("\n");
		bSpaceNeeded = false;
	}

	addVariablesOfType(ParticleSpeciesPattern.class,buffer, false);
	addVariablesOfType(ParticleObservable.class,buffer, false);
	addVariablesOfType(Function.class,buffer, true);
	addVariablesOfType(RandomVariable.class,buffer, true);
	
	// Event
	for (Event event : eventList) {
		buffer.append(getVCML(event)+"\n");
	}
//	if (eventList.size() > 0) {
//		buffer.append("\n");
//	}
	
	// Post Processing block
	if (postProcessingBlock.getNumDataGenerators() > 0) {
		buffer.append(postProcessingBlock.getVCML() + "\n");
	}
		
	final int dimension = getGeometry().getDimension();
	Enumeration<SubDomain> enum2 = getSubDomains();
	while (enum2.hasMoreElements()){
		SubDomain subDomain = enum2.nextElement();
		buffer.append( getVCML(subDomain.getVCMLProvider(dimension)) + "\n");
	}
	buffer.append("}\n");
	final String rval = buffer.toString();		
	lg.trace(rval);
	return rval;
}

/**
 * This method was created in VisualAge.
 * @return cbit.sql.Version
 */
public Version getVersion() {
	return version;
}


/**
 * Accessor for the vetoPropertyChange field.
 */
protected java.beans.VetoableChangeSupport getVetoPropertyChange() {
	if (vetoPropertyChange == null) {
		vetoPropertyChange = new java.beans.VetoableChangeSupport(this);
	};
	return vetoPropertyChange;
}


/**
 * Gets the warning property (java.lang.String) value.
 * @return The warning property value.
 * @see #setWarning
 */
public java.lang.String getWarning() {
	return fieldWarning;
}


/**
 * This method was created in VisualAge.
 * @return boolean
 */
public boolean hasFastSystems() {

	//
	// Check each subDomain for FastSystems
	//
	for (int i = 0; i < subDomainList.size(); i++) {
		SubDomain subDomain = subDomainList.get(i);
		if (subDomain.getFastSystem() != null) {
			return true;
		}
	}
	return false;
}


public boolean hasPeriodicBoundaryCondition() {

	//
	// Check each subDomain for Periodic Boundary Condition
	//
	for (int i = 0; i < subDomainList.size(); i++) {
		SubDomain subDomain = subDomainList.get(i);
		BoundaryConditionType[] bctypes = new BoundaryConditionType[0];
		if (subDomain instanceof CompartmentSubDomain) {
			CompartmentSubDomain dom = (CompartmentSubDomain)subDomain;
			bctypes = new BoundaryConditionType[] {
					dom.getBoundaryConditionXm(),
					dom.getBoundaryConditionXp(),
					dom.getBoundaryConditionYm(),
					dom.getBoundaryConditionYp(),
					dom.getBoundaryConditionZm(),
					dom.getBoundaryConditionZp()
			};
		} else if (subDomain instanceof MembraneSubDomain) {
			MembraneSubDomain dom = (MembraneSubDomain)subDomain;
			bctypes = new BoundaryConditionType[] {
					dom.getBoundaryConditionXm(),
					dom.getBoundaryConditionXp(),
					dom.getBoundaryConditionYm(),
					dom.getBoundaryConditionYp(),
					dom.getBoundaryConditionZm(),
					dom.getBoundaryConditionZp()
			};
		}
		for (BoundaryConditionType bct : bctypes) {
			if (bct.isPERIODIC()) {
				return true;
			}
		}
	}
	return false;
}

/**
 * The hasListeners method was generated to support the propertyChange field.
 */
public synchronized boolean hasListeners(java.lang.String propertyName) {
	return getPropertyChange().hasListeners(propertyName);
}



/**
 * This method was created by a SmartGuide.
 * @return boolean
 * @param volVariable cbit.vcell.math.VolVariable
 */
public boolean hasVelocity(VolVariable volVariable) {
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()){
		SubDomain subDomain = enum1.nextElement();
		if (subDomain instanceof CompartmentSubDomain){
			Equation equation = subDomain.getEquation(volVariable);
			if (equation instanceof PdeEquation){
				PdeEquation pdeEqn = (PdeEquation)equation;
				if ((pdeEqn.getVelocityX() != null && !pdeEqn.getVelocityX().isZero()) 
					|| (pdeEqn.getVelocityY() != null && !pdeEqn.getVelocityY().isZero())
					|| (pdeEqn.getVelocityZ() != null && !pdeEqn.getVelocityZ().isZero())) {
					return true;
				}
			}	
		}
	}
	return false;		
}

public boolean hasVelocity() {
	for (Variable var : variableList) {
		if (var instanceof VolVariable) {
			if (hasVelocity((VolVariable)var)) {
				return true;
			}
		}
	}
	return false;		
}

public boolean hasGradient() {
	for (Variable var : variableList) {
		if (var instanceof VolVariable) {
			if (hasGradient((VolVariable)var)) {
				return true;
			}
		}
	}
	return false;
}

public boolean hasGradient(VolVariable volVariable) {
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()){
		SubDomain subDomain = enum1.nextElement();
		if (subDomain instanceof CompartmentSubDomain){
			Equation equation = subDomain.getEquation(volVariable);
			if (equation instanceof PdeEquation){
				PdeEquation pdeEqn = (PdeEquation)equation;
				if ((pdeEqn.getGradientX() != null && !pdeEqn.getGradientX().isZero()) 
					|| (pdeEqn.getGradientY() != null && !pdeEqn.getGradientY().isZero())
					|| (pdeEqn.getGradientZ() != null && !pdeEqn.getGradientZ().isZero())) {
					return true;
				}
			}
		}
	}
	return false;
}

/**
 * This method was created by a SmartGuide.
 * @return boolean
 * @param volVariable cbit.vcell.math.VolVariable
 */
public boolean isPDE(MemVariable memVariable) {
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()){
		SubDomain subDomain = enum1.nextElement();
		if (subDomain instanceof MembraneSubDomain){
			Equation equation = subDomain.getEquation(memVariable);
			if (equation instanceof PdeEquation){
				return true;
			}	
		}
	}
	return false;		
}


/**
 * This method was created by a SmartGuide.
 * @return boolean
 * @param volVariable cbit.vcell.math.VolVariable
 */
public boolean isPDE(VolVariable volVariable) {
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()){
		SubDomain subDomain = enum1.nextElement();
		if (subDomain instanceof CompartmentSubDomain){
			Equation equation = subDomain.getEquation(volVariable);
			if (equation instanceof PdeEquation){
				return true;
			}	
		}
	}
	return false;		
}

/**
 * This method was created by a SmartGuide.
 * @return boolean
 * @param volVariable cbit.vcell.math.VolVariable
 */
public boolean isPdeSteady(VolVariable volVariable) {	
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()){
		SubDomain subDomain = enum1.nextElement();
		if (subDomain instanceof CompartmentSubDomain){
			Equation equation = subDomain.getEquation(volVariable);
			if (equation instanceof PdeEquation){
				if (((PdeEquation)equation).isSteady()) {
					return true;
				}
			}	
		}
	}
	return false;		
}

/**
 * This method was created in VisualAge.
 * @return boolean
 */
public boolean isSpatial() {
	if (getGeometry()==null) {
		return false;
	}
	return (getGeometry().getDimension()>0);
}


public boolean isNonSpatialStoch() {
	if (getGeometry().getDimension() != 0) {
		return false;
	}
	Enumeration<Variable> enum1 = getVariables();
	while (enum1.hasMoreElements()) {
		Variable var = enum1.nextElement();
		if (var instanceof StochVolVariable) {
			return true;
		}
		if (!(var instanceof Constant || var instanceof Function)) {
			return false;
		} 
	}
	return false;	
}


public boolean isRuleBased(){
	if (particleMolecularTypes.size()>0){
		return true;
	}
	return false;
}

public boolean isSpatialHybrid() {
	if (getGeometry().getDimension() == 0) {
		return false;
	}
	boolean bHasParticleVariable = false;
	boolean bHasPdeVariable = false;	
	Enumeration<Variable> enum1 = getVariables();
	while (enum1.hasMoreElements()) {
		Variable var = enum1.nextElement();
		if (var instanceof ParticleVariable) {
			bHasParticleVariable = true;
		} else if (var instanceof VolVariable || var instanceof MemVariable) {
			bHasPdeVariable = true;
		} else if (var instanceof InsideVariable || var instanceof OutsideVariable) {			
		} else if (!(var instanceof Constant) && !(var instanceof Function)) {
			return false;
		} 
	}
	return bHasParticleVariable && bHasPdeVariable;		
}

public boolean isSpatialStoch() {
	if (getGeometry().getDimension() == 0) {
		return false;
	}
	boolean hasParticle = false;
	Enumeration<Variable> enum1 = getVariables();
	while (enum1.hasMoreElements()) {
		Variable var = enum1.nextElement();	
		if(var instanceof ParticleVariable){
			hasParticle = true;
		}
		if (!(var instanceof ParticleVariable || var instanceof Constant || var instanceof Function)) {
			return false;
		}
	} 
	return hasParticle;
}

public boolean isValid() {
	IssueContext issueContext = new IssueContext(ContextType.MathDescription,this,null);
	ArrayList<Issue> issueList = new ArrayList<Issue>();
	gatherIssues(issueContext, issueList);
	if (issueList.size() > 0) {
		setWarning(issueList.get(0).getMessage());
	}
	return issueList.size() == 0;
}
/**
 * This method was created in VisualAge.
 * @return boolean
 */
public void gatherIssues(IssueContext issueContext, List<Issue> issueList) {
	issueContext = issueContext.newChildContext(ContextType.MathDescription, this);
	setWarning(null);
	if (geometry==null){
		Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_NoGeometry, VCellErrorMessages.MATH_DESCRIPTION_GEOMETRY_1, Issue.SEVERITY_ERROR);
		issueList.add(issue);
	}

	if(isSpatialStoch() && geometry.getDimension() != 3)
	{
		Issue issue = new Issue(geometry, issueContext, IssueCategory.Smoldyn_Geometry_3DWarning, "VCell spatial stochastic models only support 3D geometry.", Issue.SEVERITY_ERROR);
		issueList.add(issue);
	}
	
	// check Constant are really constants
	for (int i=0;i<variableList.size();i++){
		Variable var = variableList.get(i);
		if (var instanceof Constant){
			try {
				((Constant)var).getExpression().evaluateConstant();
			} catch (Exception ex) {
				ex.printStackTrace(System.out);
				Issue issue = new Issue(var, issueContext, IssueCategory.MathDescription_Constant_NotANumber, VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_CONSTANT, var.getExpression().infix()), Issue.SEVERITY_ERROR);
				issueList.add(issue);
			}
		}
	}
	
	//
	// count number of variables of each type
	//
	int volVarCount = 0;
	int memVarCount = 0;
	int filVarCount = 0;
	int volRegionVarCount = 0;
	int memRegionVarCount = 0;
	int filRegionVarCount = 0;
	int stochVarCount = 0;
	for (int i=0;i<variableList.size();i++){
		Variable var = variableList.get(i);
		if (var instanceof VolVariable){
			volVarCount++;
		}else if (var instanceof MemVariable){
			memVarCount++;
		}else if (var instanceof FilamentVariable){
			filVarCount++;
		}else if (var instanceof VolumeRegionVariable){
			volRegionVarCount++;
		}else if (var instanceof MembraneRegionVariable){
			memRegionVarCount++;
		}else if (var instanceof FilamentRegionVariable){
			filRegionVarCount++;
		}else if (var instanceof StochVolVariable){
			stochVarCount++;
		}
	}
	//
	// check that all equation rates and initial conditions ... etc can be bound to this MathDescription (e.g. no unresolved identifiers).
	//
	for (int i = 0; i < subDomainList.size(); i++){
		try {
			SubDomain subDomain = subDomainList.get(i);
			Enumeration<Equation> equEnum = subDomain.getEquations();
			while (equEnum.hasMoreElements()){
				Equation equ = equEnum.nextElement();
				equ.checkValid(this,subDomain);
				equ.bind(this);
			}
			FastSystem fastSystem = subDomain.getFastSystem();
			if (fastSystem!=null){
				Enumeration<FastRate> frEnum = fastSystem.getFastRates();
				while (frEnum.hasMoreElements()){
					FastRate fr = frEnum.nextElement();
					fr.bind(this);
				}
				Enumeration<FastInvariant> fiEnum = fastSystem.getFastInvariants();
				while (fiEnum.hasMoreElements()){
					FastInvariant fi = fiEnum.nextElement();
					fi.bind(this);
				}
			}
			for (ParticleProperties pp : subDomain.getParticleProperties()) {
				pp.bind(this);
			}
			for (ParticleJumpProcess pjp : subDomain.getParticleJumpProcesses()) {
				pjp.bind(this);
				
				Expression rateDefinition = null;
				JumpProcessRateDefinition jprd = pjp.getParticleRateDefinition();
				if(jprd instanceof MacroscopicRateConstant) {
					rateDefinition = MathUtilities.substituteFunctions(((MacroscopicRateConstant) jprd).getExpression(), this);
				} else if(jprd instanceof InteractionRadius) {
					rateDefinition = MathUtilities.substituteFunctions(((InteractionRadius) jprd).getExpression(), this);
				} else {
					new RuntimeException("The jump process rate definition is not supported");
				}
				
				String symbols[] = rateDefinition.getSymbols();
				if(symbols != null)	
				{
					for (String symbol : symbols) { //throw exception for particle variables, particle variable cannot be referenced
						Variable var = getVariable(symbol);
						if (var instanceof ParticleVariable) {
							throw new MathException("Stochastic variables can not be referenced in functions and equations.");
						}
						if(subDomain instanceof CompartmentSubDomain)
						{
							if ((var instanceof MembraneRegionVariable || var instanceof MemVariable)) {
								throw new MathException("Volume reaction: "+ pjp.getName() +" cannot reference membrane variable: " + var.getName() + ".");
							}
						}
					}
				}
			}	
		}catch (ExpressionBindingException e){
			Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_ExpressionBindingException, e.getMessage(), Issue.SEVERITY_ERROR);
			issueList.add(issue);	
		}catch (ExpressionException e){
			Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_ExpressionException, e.getMessage(), Issue.SEVERITY_ERROR);
			issueList.add(issue);	
		}catch (MathException e){
			Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_MathException, e.getMessage(), Issue.SEVERITY_ERROR);
			issueList.add(issue);	
		}
	}
	//
	// ODE only
	//
	if (geometry.getDimension()==0){
		//
		// Check that only 1 subdomain is defined and that it is a volumeSubdomain
		//
		if (subDomainList.size()!=1){
			Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_CompartmentalModel, VCellErrorMessages.MATH_DESCRIPTION_COMPARTMENT_MODEL_1, Issue.SEVERITY_ERROR);
			issueList.add(issue);
		} else if (subDomainList.size() == 1) {
			if (!(subDomainList.get(0) instanceof CompartmentSubDomain)){
				Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_CompartmentalModel, VCellErrorMessages.MATH_DESCRIPTION_COMPARTMENT_MODEL_2, Issue.SEVERITY_ERROR);
				issueList.add(issue);
			}
			CompartmentSubDomain subDomain = (CompartmentSubDomain)subDomainList.get(0);
			//distinguish ODE model and stochastic model
			if(isNonSpatialStoch())
			{
				if(stochVarCount == 0) {
					Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_StochasticModel, VCellErrorMessages.MATH_DESCRIPTION_COMPARTMENT_STOCHASTIC_MODEL_1, Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}	
				if(subDomain.getJumpProcesses().size() == 0)
				{
					Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_StochasticModel, VCellErrorMessages.MATH_DESCRIPTION_COMPARTMENT_STOCHASTIC_MODEL_2, Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}
				//check variable initial condition
				for (VarIniCondition varIniCondition : subDomain.getVarIniConditions()) {
					Expression iniExp = varIniCondition.getIniVal();
					try{
						iniExp.bindExpression(this);
					}catch(Exception ex){
						ex.printStackTrace(System.out);
						setWarning(ex.getMessage());
					}				
				}
				//check probability rate
				for (JumpProcess jumpProcess : subDomain.getJumpProcesses()) {
					Expression probExp = jumpProcess.getProbabilityRate();
					try{
						probExp.bindExpression(this);
					}catch(Exception ex){
						ex.printStackTrace(System.out);
						setWarning(ex.getMessage());
					}
				}
			} else if (isRuleBased()) {
			} else {
				// ODE model
				//
				// Check that all equations are ODEs 
				//
				int odeCount = 0;
				Enumeration<Equation> enum_equ = subDomain.getEquations();
				while (enum_equ.hasMoreElements()){
					Equation equ = enum_equ.nextElement();
					if (equ instanceof OdeEquation){
						odeCount ++;
					} else {
						Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_CompartmentalModel, 
								VCellErrorMessages.MATH_DESCRIPTION_COMPARTMENT_MODEL_3, Issue.SEVERITY_ERROR);
						issueList.add(issue);
					}
				}
				if (odeCount==0){
					Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_CompartmentalModel, 
							VCellErrorMessages.MATH_DESCRIPTION_COMPARTMENT_MODEL_4, Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}
	
				if (volVarCount!=odeCount){
					Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_CompartmentalModel, 
							VCellErrorMessages.MATH_DESCRIPTION_COMPARTMENT_MODEL_5, Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}
				if (memVarCount>0){
					Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_CompartmentalModel, 
							VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_COMPARTMENT_MODEL_6, VCML.MembraneVariable), Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}
				if (filVarCount>0){
					Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_CompartmentalModel, 
							VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_COMPARTMENT_MODEL_6, VCML.FilamentVariable), Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}
				if (volRegionVarCount>0){
					Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_CompartmentalModel, 
							VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_COMPARTMENT_MODEL_6, VCML.VolumeRegionVariable), Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}
				if (memRegionVarCount>0){
					Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_CompartmentalModel, 
							VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_COMPARTMENT_MODEL_6, VCML.MembraneRegionVariable), Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}
				if (filRegionVarCount>0){
					Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_CompartmentalModel, 
							VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_COMPARTMENT_MODEL_6, VCML.FilamentRegionVariable), Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}
			}
		}
	//
	// spatial (PDE and ODE)
	//
	}else{
		//
		// Check that the number of CompartmentSubdomains equals the number of VolumeSubVolumes in the Geometry
		// Check that the number of FilamentSubdomains equals the number of Filaments in the Geometry
		//
		int compartmentCount = 0;
		int membraneCount = 0;
		int filamentCount = 0;
		for (int i=0;i<subDomainList.size();i++){
			SubDomain subDomain = (SubDomain)subDomainList.get(i);
			if (subDomain instanceof CompartmentSubDomain){
				if (geometry.getGeometrySpec().getSubVolume(subDomain.getName()) == null) {
					Issue issue = new Issue(subDomain, issueContext, IssueCategory.MathDescription_SpatialModel_Subdomain, 
							VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_1, subDomain.getName()), Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}
				compartmentCount++;
			}else if (subDomain instanceof MembraneSubDomain){
				membraneCount++;
			}else if (subDomain instanceof FilamentSubDomain){
				filamentCount++;
			}else{
				Issue issue = new Issue(subDomain, issueContext, IssueCategory.MathDescription_SpatialModel_Subdomain, 
						VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_2, subDomain.getName()), Issue.SEVERITY_ERROR);
				issueList.add(issue);
			}
		}
		if (geometry.getGeometrySpec().getNumSubVolumes()!=compartmentCount){
			Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_SpatialModel, 
				VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_3, geometry.getGeometrySpec().getNumSubVolumes(), compartmentCount), Issue.SEVERITY_ERROR);
			issueList.add(issue);
		}
		if (geometry.getGeometrySpec().getFilamentGroup().getFilamentCount()!=filamentCount){
//			setWarning("Spatial model, there are "+geometry.getGeometrySpec().getFilamentGroup().getFilamentCount()+" filaments in geometry, but "+filamentCount+" "+VCML.FilamentSubDomain+"'s, must be equal");
//			return false;
		}
		if (filamentCount==0 && (filVarCount>0 || filRegionVarCount>0)){
			Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_SpatialModel, 
					VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_4, Issue.SEVERITY_ERROR);
			issueList.add(issue);
		}
		if (membraneCount==0 && (memVarCount>0 || memRegionVarCount>0)){
			Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_SpatialModel, 
					VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_5, Issue.SEVERITY_ERROR);
			issueList.add(issue);
		}
		//
		// Check that there are no duplicate Subdomains and that priorities are unique
		//
		for (int i = 0; i < subDomainList.size(); i++){
			SubDomain subDomain1 = (SubDomain)subDomainList.get(i);
			for (int j = 0; j < subDomainList.size(); j++){
				if (i!=j){
					SubDomain subDomain2 = (SubDomain)subDomainList.get(j);
					if (subDomain1.getName().equals(subDomain2.getName())){
						Issue issue = new Issue(subDomain1, issueContext, IssueCategory.MathDescription_SpatialModel_Subdomain, 
								VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_6, subDomain1.getName(), subDomain2.getName()), Issue.SEVERITY_ERROR);
						issueList.add(issue);
					}
					if (subDomain1 instanceof MembraneSubDomain && subDomain2 instanceof MembraneSubDomain){
						MembraneSubDomain memSubDomain1 = (MembraneSubDomain)subDomain1;
						MembraneSubDomain memSubDomain2 = (MembraneSubDomain)subDomain2;
						if ((memSubDomain1.getInsideCompartment()==memSubDomain2.getInsideCompartment() && memSubDomain1.getOutsideCompartment()==memSubDomain2.getOutsideCompartment()) ||
							(memSubDomain1.getInsideCompartment()==memSubDomain2.getOutsideCompartment() && memSubDomain1.getOutsideCompartment()==memSubDomain2.getInsideCompartment())){
							Issue issue = new Issue(subDomain1, issueContext, IssueCategory.MathDescription_SpatialModel_Subdomain, 
								VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_7, memSubDomain1.getInsideCompartment().getName(), memSubDomain1.getOutsideCompartment().getName()), Issue.SEVERITY_ERROR);
							issueList.add(issue);
						}
					}
				}
			}
			
		}
		// check periodic boundary conditons
		for (int i = 0; i < subDomainList.size(); i++){
			SubDomain subDomain = (SubDomain)subDomainList.get(i);
			if (subDomain instanceof CompartmentSubDomain) {
				CompartmentSubDomain compartmentSubDomain = (CompartmentSubDomain)subDomain;
				BoundaryConditionType bctM = compartmentSubDomain.getBoundaryConditionXm();
				BoundaryConditionType bctP = compartmentSubDomain.getBoundaryConditionXp();
				if (bctM.isPERIODIC() && !bctP.isPERIODIC() || !bctM.isPERIODIC() && bctP.isPERIODIC()) {
					Issue issue = new Issue(subDomain, issueContext, IssueCategory.MathDescription_SpatialModel_Subdomain, 
						VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_9, "Xm", "Xp", subDomain.getName()), Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}
				bctM = compartmentSubDomain.getBoundaryConditionYm();
				bctP = compartmentSubDomain.getBoundaryConditionYp();
				if (bctM.isPERIODIC() && !bctP.isPERIODIC() || !bctM.isPERIODIC() && bctP.isPERIODIC()) {
					Issue issue = new Issue(subDomain, issueContext, IssueCategory.MathDescription_SpatialModel_Subdomain, 
						VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_9, "Ym", "Yp", subDomain.getName()), Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}
				bctM = compartmentSubDomain.getBoundaryConditionZm();
				bctP = compartmentSubDomain.getBoundaryConditionZp();
				if (bctM.isPERIODIC() && !bctP.isPERIODIC() || !bctM.isPERIODIC() && bctP.isPERIODIC()) {
					Issue issue = new Issue(subDomain, issueContext, IssueCategory.MathDescription_SpatialModel_Subdomain, 
						VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_9, "Zm", "Zp", subDomain.getName()), Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}				
			}else if (subDomain instanceof MembraneSubDomain){
				MembraneSubDomain membraneSubDomain = (MembraneSubDomain)subDomain;
				BoundaryConditionType bctM = membraneSubDomain.getBoundaryConditionXm();
				BoundaryConditionType bctP = membraneSubDomain.getBoundaryConditionXp();
				if (bctM.isPERIODIC() && !bctP.isPERIODIC() || !bctM.isPERIODIC() && bctP.isPERIODIC()) {
					Issue issue = new Issue(subDomain, issueContext, IssueCategory.MathDescription_SpatialModel_Subdomain, 
						VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_9, "Xm", "Xp", subDomain.getName()), Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}
				bctM = membraneSubDomain.getBoundaryConditionYm();
				bctP = membraneSubDomain.getBoundaryConditionYp();
				if (bctM.isPERIODIC() && !bctP.isPERIODIC() || !bctM.isPERIODIC() && bctP.isPERIODIC()) {
					Issue issue = new Issue(subDomain, issueContext, IssueCategory.MathDescription_SpatialModel_Subdomain, 
						VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_9, "Ym", "Yp", subDomain.getName()), Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}
				bctM = membraneSubDomain.getBoundaryConditionZm();
				bctP = membraneSubDomain.getBoundaryConditionZp();
				if (bctM.isPERIODIC() && !bctP.isPERIODIC() || !bctM.isPERIODIC() && bctP.isPERIODIC()) {
					Issue issue = new Issue(subDomain, issueContext, IssueCategory.MathDescription_SpatialModel_Subdomain, 
						VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_9, "Zm", "Zp", subDomain.getName()), Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}
			}		
		}
		
		try {
			if (geometry.getGeometrySpec().getDimension() > 0) {
				//
				// Check that there is a MembraneSubdomain for each unique subVolume-subVolume interface in Geometry
				// each ResolvedSurfaceLocation is an instance of a subVolume-subVolume interface (one-to-one with region boundaries).
				//
				GeometricRegion regions[] = geometry.getGeometrySurfaceDescription().getGeometricRegions();
				//if (regions==null){
					//try {
						//geometry.getGeometrySurfaceDescription().updateAll();
						//regions = geometry.getGeometrySurfaceDescription().getGeometricRegions();
					//}catch (Exception e){
						//e.printStackTrace(System.out);
					//}
				//}
				if (regions==null){
					Issue issue = new Issue(geometry, issueContext, IssueCategory.MathDescription_SpatialModel_Geometry, 
							VCellErrorMessages.MATH_DESCRIPTION_GEOMETRY_2, Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}
				else {
					for (int i = 0; i < regions.length; i++){
						if (regions[i] instanceof SurfaceGeometricRegion){
							SurfaceGeometricRegion surfaceRegion = (SurfaceGeometricRegion)regions[i];
							SubVolume subVolume1 = ((VolumeGeometricRegion)surfaceRegion.getAdjacentGeometricRegions()[0]).getSubVolume();
							CompartmentSubDomain compartment1 = getCompartmentSubDomain(subVolume1.getName());
							if(compartment1 == null){
								Issue issue = new Issue(geometry, issueContext, IssueCategory.MathDescription_SpatialModel_Geometry,
										VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_GEOMETRY_3, getGeometry().getName(), subVolume1.getName()), Issue.SEVERITY_ERROR);
								issueList.add(issue);
							}
							SubVolume subVolume2 = ((VolumeGeometricRegion)surfaceRegion.getAdjacentGeometricRegions()[1]).getSubVolume();
							CompartmentSubDomain compartment2 = getCompartmentSubDomain(subVolume2.getName());
							if(compartment2 == null){
								Issue issue = new Issue(geometry, issueContext, IssueCategory.MathDescription_SpatialModel_Geometry, 
										VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_GEOMETRY_3, getGeometry().getName(), subVolume2.getName()), Issue.SEVERITY_ERROR);
								issueList.add(issue);
							}
							MembraneSubDomain membraneSubDomain = getMembraneSubDomain(compartment1,compartment2);
							if (compartment2 != null && compartment1 != null && membraneSubDomain==null){
								Issue issue = new Issue(geometry, issueContext, IssueCategory.MathDescription_SpatialModel_Geometry, 
										VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_GEOMETRY_4, compartment1.getName(), compartment2.getName()), Issue.SEVERITY_ERROR);
								issueList.add(issue);
							}
						}
					}
					//
					// Check that for each MembraneSubdomain there exists an actual surface in the geometry
					//
					for (int i = 0; i < subDomainList.size(); i++){
						if (subDomainList.get(i) instanceof MembraneSubDomain){
							MembraneSubDomain membraneSubDomain = (MembraneSubDomain)subDomainList.get(i);
							boolean bFoundSurfaceInGeometry = false;
							for (int j = 0; j < regions.length; j++){
								if (regions[j] instanceof SurfaceGeometricRegion){
									SurfaceGeometricRegion surfaceRegion = (SurfaceGeometricRegion)regions[j];
									VolumeGeometricRegion volumeRegion1 = (VolumeGeometricRegion)surfaceRegion.getAdjacentGeometricRegions()[0];
									VolumeGeometricRegion volumeRegion2 = (VolumeGeometricRegion)surfaceRegion.getAdjacentGeometricRegions()[1];
									String memInsideName = membraneSubDomain.getInsideCompartment().getName();
									String memOutsideName = membraneSubDomain.getOutsideCompartment().getName();
									if ((memInsideName.equals(volumeRegion1.getSubVolume().getName()) && memOutsideName.equals(volumeRegion2.getSubVolume().getName()))||
											(memInsideName.equals(volumeRegion2.getSubVolume().getName()) && memOutsideName.equals(volumeRegion1.getSubVolume().getName()))){
										bFoundSurfaceInGeometry=true;
										break;
									}
								}
							}
							if (!bFoundSurfaceInGeometry){
								Issue issue = new Issue(geometry, issueContext, IssueCategory.MathDescription_SpatialModel_Geometry, 
										VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_GEOMETRY_5, membraneSubDomain.getInsideCompartment().getName(), membraneSubDomain.getOutsideCompartment().getName()), Issue.SEVERITY_ERROR);
								issueList.add(issue);
							}
						}
					}
				}
				}
		//}catch (GeometryException e){
			//e.printStackTrace(System.out);
			//setWarning("error validating MathDescription: "+e.getMessage());
			//return false;
		//}catch (ImageException e){
			//e.printStackTrace(System.out);
			//setWarning("error validating MathDescription: "+e.getMessage());
			//return false;
		//}catch (ExpressionException e){
			//e.printStackTrace(System.out);
			//setWarning("error validating MathDescription: "+e.getMessage());
			//return false;
		}catch (Exception e){
			e.printStackTrace(System.out);
			Issue issue = new Issue(geometry, issueContext, IssueCategory.MathDescription_SpatialModel_Geometry,	e.getMessage(), Issue.SEVERITY_ERROR);
			issueList.add(issue);
		}
		//
		// Check that all equations for the same VolVariable are the same type (ODE or PDE)
		// ... and that all PDE equations have jump conditions defined on the appropriate membranes
		//
		for (int i=0;i<variableList.size();i++){
			Variable var = variableList.get(i);
			String varName = var.getName();
			if (var instanceof VolVariable){
				VolVariable volVar = (VolVariable)var;
				
				int pdeRefCount = 0;
				int odeRefCount = 0;
				int steadyPdeCount = 0;
				for (int j=0;j<subDomainList.size();j++){
					SubDomain subDomain = subDomainList.get(j);
					Equation equ = subDomain.getEquation(volVar);
					if (equ instanceof PdeEquation){
						if (((PdeEquation)equ).isSteady()) {
							steadyPdeCount ++;
						} else {
							pdeRefCount++;
						}
						//
						// for each PDE, make sure that a jump condition all membranes that border this compartment
						//
						for (int k = 0; k < subDomainList.size(); k++){
							SubDomain subDomain2 = subDomainList.get(k);
							if (subDomain2 instanceof MembraneSubDomain){
								MembraneSubDomain membraneSubDomain = (MembraneSubDomain)subDomain2;
								if (membraneSubDomain.getInsideCompartment() == subDomain || membraneSubDomain.getOutsideCompartment() == subDomain){
									JumpCondition jumpCondition = membraneSubDomain.getJumpCondition(volVar);
									BoundaryConditionValue boundaryValue = ((PdeEquation)equ).getBoundaryConditionValue(membraneSubDomain.getName());
									// if PDE variable does not have jump condition OR boundaryValue (neither or both are not allowed), its an error.  
									if ((jumpCondition==null && boundaryValue == null) || (jumpCondition != null && boundaryValue != null)){
										Issue issue = new Issue(equ, issueContext, IssueCategory.MathDescription_SpatialModel_Equation, 
											VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_10, varName, subDomain.getName(), membraneSubDomain.getName()), Issue.SEVERITY_ERROR);
										issueList.add(issue);
									}
									if (boundaryValue != null && (subDomain.getBoundaryConditionSpec(membraneSubDomain.getName()) == null)) {
										Issue issue = new Issue(equ, issueContext, IssueCategory.MathDescription_SpatialModel_Equation, 
												VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_10A, varName, subDomain.getName(), membraneSubDomain.getName(), membraneSubDomain.getName(), subDomain.getName()), Issue.SEVERITY_ERROR);
											issueList.add(issue);
									}
								}
							}
						}
					}else if (equ instanceof OdeEquation){
						odeRefCount++;
					}
					//
					// for each JumpCondition, make sure that there is at least one PDE defined in inside or outside compartment
					// and for each side, if the PDE is missing, then the corresponding flux term should be identically zero.
					//
					if (subDomain instanceof MembraneSubDomain){
						MembraneSubDomain memSubDomain = (MembraneSubDomain)subDomain;
						JumpCondition jumpCondition = memSubDomain.getJumpCondition(volVar);
						if (jumpCondition != null){
							boolean bInsidePresent = (memSubDomain.getInsideCompartment().getEquation(volVar) instanceof PdeEquation);
							boolean bOutsidePresent = (memSubDomain.getOutsideCompartment().getEquation(volVar) instanceof PdeEquation);
							if (!bInsidePresent && !bOutsidePresent){
								Issue issue = new Issue(equ, issueContext, IssueCategory.MathDescription_SpatialModel_Equation, 
										VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_11, varName, memSubDomain.getName(), memSubDomain.getInsideCompartment().getName(), memSubDomain.getOutsideCompartment().getName()), Issue.SEVERITY_ERROR);
								issueList.add(issue);			
							}
							//
							// if either side is missing, then flux term should be identically zero.
							//
							if (!bInsidePresent && !jumpCondition.getInFluxExpression().isZero()){
								Issue issue = new Issue(equ, issueContext, IssueCategory.MathDescription_SpatialModel_Equation,
									VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_12, varName, memSubDomain.getName(), memSubDomain.getInsideCompartment().getName()), Issue.SEVERITY_ERROR);
								issueList.add(issue);	
							}
							if (!bOutsidePresent && !jumpCondition.getOutFluxExpression().isZero()){
								Issue issue = new Issue(equ, issueContext, IssueCategory.MathDescription_SpatialModel_Equation, 
									VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_13, varName, memSubDomain.getName(), memSubDomain.getOutsideCompartment().getName()), Issue.SEVERITY_ERROR);
								issueList.add(issue);	
							}
								
						}
					}
				}
				if (odeRefCount>0 && pdeRefCount>0){
					Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_SpatialModel, 
						VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_14, varName), Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}
				if (steadyPdeCount>0 && pdeRefCount>0){
					Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_SpatialModel, 
						VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_15, varName), Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}
				if (odeRefCount==0 && pdeRefCount==0 && steadyPdeCount == 0){
					Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_SpatialModel, 
						VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_16, varName), Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}
			}
		
			//
			// Check that there is an equation (OdeEquation) for a given MembraneVariable on each membrane.
			//
			else if (var instanceof MemVariable){
				int pdeRefCount = 0;
				int odeRefCount = 0;
				int steadyPdeCount = 0;
				for (int j=0;j<subDomainList.size();j++){
					SubDomain subDomain = subDomainList.get(j);
					Equation equ = subDomain.getEquation(var);
					if (equ instanceof PdeEquation){
						if (((PdeEquation)equ).isSteady()) {
							steadyPdeCount ++;
						} else {
							pdeRefCount++;
						}
					}else if (equ instanceof OdeEquation){
						odeRefCount++;
					}
				}
				if (odeRefCount>0 && pdeRefCount>0){
					Issue issue = new Issue(var, issueContext, IssueCategory.MathDescription_SpatialModel_Variable, 
						VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_14, varName), Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}
				if (steadyPdeCount>0 && pdeRefCount>0){
					Issue issue = new Issue(var, issueContext, IssueCategory.MathDescription_SpatialModel_Variable, 
						VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_15, varName), Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}
				if (odeRefCount==0 && pdeRefCount==0 && steadyPdeCount == 0){
					Issue issue = new Issue(var, issueContext, IssueCategory.MathDescription_SpatialModel_Variable, 
						VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_16, varName), Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}
			}
			//
			// Check that there is an equation (OdeEquation) for a given FilamentVariable on each FilamentSubDomain.
			//
			else if (var instanceof FilamentVariable){
				for (int j=0;j<subDomainList.size();j++){
					SubDomain subDomain = subDomainList.get(j);
					if (subDomain instanceof FilamentSubDomain){
						Equation equ = subDomain.getEquation(var);
						if (!(equ instanceof OdeEquation)){
							Issue issue = new Issue(var, issueContext, IssueCategory.MathDescription_SpatialModel_Variable,
								VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_21, varName, subDomain.getName()), Issue.SEVERITY_ERROR);
							issueList.add(issue);
						}
					}
				}
			}
			//
			// Check that there is a region equation (VolumeRegionEquation) for a given VolumeRegionVariable on each CompartmentSubDomain.
			//
			else if (var instanceof VolumeRegionVariable){
				VolumeRegionVariable volRegionVar = (VolumeRegionVariable)var;
				int count = 0;
				for (int j=0;j<subDomainList.size();j++){
					SubDomain subDomain = subDomainList.get(j);
					if (subDomain instanceof CompartmentSubDomain){
						Equation equ = subDomain.getEquation(volRegionVar);
						if (equ instanceof VolumeRegionEquation){
							count ++;
					
							//
							// for each VolumeRegionEquation, make sure that a jump condition all membranes that border this compartment
							//
							for (int k = 0; k < subDomainList.size(); k++){
								SubDomain subDomain2 = subDomainList.get(k);
								if (subDomain2 instanceof MembraneSubDomain){
									MembraneSubDomain membraneSubDomain = (MembraneSubDomain)subDomain2;
									if (membraneSubDomain.getInsideCompartment() == subDomain || membraneSubDomain.getOutsideCompartment() == subDomain){
										if (membraneSubDomain.getJumpCondition(volRegionVar)==null){
											Issue issue = new Issue(var, issueContext, IssueCategory.MathDescription_SpatialModel_Variable,
												VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_17, varName, subDomain.getName(), membraneSubDomain.getName()), Issue.SEVERITY_ERROR);
											issueList.add(issue);											
										}
									}
								}
							}
						}
					}
				}
				if (count == 0) {
					Issue issue = new Issue(var, issueContext, IssueCategory.MathDescription_SpatialModel_Variable, 
							VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_18, varName), Issue.SEVERITY_ERROR);
					issueList.add(issue);
				}
			}
			//
			// Check that there is a region equation (MembraneRegionEquation) for a given MembraneRegionVariable on each MembraneSubDomain.
			//
			else if (var instanceof MembraneRegionVariable){
				int count = 0;
				for (int j=0;j<subDomainList.size();j++){
					SubDomain subDomain = subDomainList.get(j);
					if (subDomain instanceof MembraneSubDomain){
						Equation equ = subDomain.getEquation(var);
						if (equ instanceof MembraneRegionEquation){
							count ++;
						}
					}
				}
				if (count == 0) {
					Issue issue = new Issue(var, issueContext, IssueCategory.MathDescription_SpatialModel_Variable, 
							VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_19, varName), Issue.SEVERITY_ERROR);
					issueList.add(issue);					
				}
			}
			//
			// Check that there is a region equation (FilamentRegionEquation) for a given FilamentRegionVariable on each FilamentSubDomain.
			//
			else if (var instanceof FilamentRegionVariable){
				for (int j=0;j<subDomainList.size();j++){
					SubDomain subDomain = subDomainList.get(j);
					if (subDomain instanceof FilamentSubDomain){
						Equation equ = subDomain.getEquation(var);
						if (!(equ instanceof FilamentRegionEquation)){
							Issue issue = new Issue(var, issueContext, IssueCategory.MathDescription_SpatialModel_Variable, 
								VCellErrorMessages.getErrorMessage(VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_20, varName, subDomain.getName()), Issue.SEVERITY_ERROR);
							issueList.add(issue);							
						}
					}
				}
			}
		}
	}
	if (eventList.size() > 0 && isSpatial()) {
		Issue issue = new Issue(this, issueContext, IssueCategory.MathDescription_SpatialModel, VCellErrorMessages.MATH_DESCRIPTION_SPATIAL_MODEL_22, Issue.SEVERITY_ERROR);
		issueList.add(issue);
	}
	for (Event event : eventList) {
		try {
			event.bind(this);
		}catch (ExpressionBindingException e){
			Issue issue = new Issue(event, issueContext, IssueCategory.MathDescription_SpatialModel_Event, e.getMessage(), Issue.SEVERITY_ERROR);
			issueList.add(issue);
		}		
	}
	
	for (DataGenerator dataGenerator : postProcessingBlock.getDataGeneratorList()) {
		try {
			dataGenerator.bind(this);
		}catch (ExpressionBindingException e){
			Issue issue = new Issue(dataGenerator, issueContext, IssueCategory.MathDescription_SpatialModel_PostProcessingBlock, e.getMessage(), Issue.SEVERITY_ERROR);
			issueList.add(issue);
		}		
	}
}


/**
 * Insert the method's description here.
 * Creation date: (10/9/2002 10:54:06 PM)
 * @return cbit.vcell.math.MathDescription
 */
void makeCanonical(MathSymbolTableFactory mathSymbolTableFactory) throws MathException, ExpressionException {
	
	// this method operates on argument; call createCanonicalMathDescription to make new one
	MathDescription newMath = this;
	
	boolean bRoundCoefficients = false;

	//
	// make a "identity" simulation (no overrides), this will help to substitute/flatten expressions.
	//
	MathSymbolTable mathSymbolTable = mathSymbolTableFactory.createMathSymbolTable(newMath);
	
	//
	// for top-level objects, substitute all events, 
	//
	for (Event event : eventList){
		event.flatten(mathSymbolTable,bRoundCoefficients);
	}

	for (Variable var : variableList) { 
		if (var instanceof RandomVariable){
			((RandomVariable)var).flatten(mathSymbolTable,bRoundCoefficients);
		}
	}
	
	//
	// for each subdomain, substitute all rates, initial conditions, boundary conditions, jump conditions
	//
	for (int i = 0; i < newMath.subDomainList.size(); i++){
		SubDomain subDomain = newMath.subDomainList.get(i);
		Enumeration<Equation> equEnum = subDomain.getEquations();
		while (equEnum.hasMoreElements()){
			Equation equ = equEnum.nextElement();
			equ.flatten(mathSymbolTable,bRoundCoefficients);
		}
		for (VarIniCondition varIniCondition : subDomain.getVarIniConditions()){
			varIniCondition.flatten(mathSymbolTable,bRoundCoefficients);
		}
		for (JumpProcess jumpProcess : subDomain.getJumpProcesses()){
			jumpProcess.flatten(mathSymbolTable,bRoundCoefficients);
		}
		for (ParticleJumpProcess jumpProcess : subDomain.getParticleJumpProcesses()){
			jumpProcess.flatten(mathSymbolTable,bRoundCoefficients);
		}
		for (ParticleProperties particleProperty : subDomain.getParticleProperties()){
			particleProperty.flatten(mathSymbolTable,bRoundCoefficients);
		}
		if (subDomain instanceof MembraneSubDomain){
			Enumeration<JumpCondition> jcEnum = ((MembraneSubDomain)subDomain).getJumpConditions();
			while (jcEnum.hasMoreElements()){
				JumpCondition jc = jcEnum.nextElement();
				jc.flatten(mathSymbolTable,bRoundCoefficients);
			}
		}
	}

	//
	// remove all "dummy" equations (rate=0,initial=0)
	// remove all Priorities (shouldn't be used in BioModels)
	//
	for (int i = 0; i < newMath.subDomainList.size(); i++){
		SubDomain subDomain = newMath.subDomainList.get(i);
		subDomain.trimTrivialEquations(newMath);
	}

	//
	// substitute all fast rates, fast invariants
	//
	for (int i = 0; i < newMath.subDomainList.size(); i++){
		SubDomain subDomain = newMath.subDomainList.get(i);
		FastSystem fastSystem = subDomain.getFastSystem();
		if (fastSystem != null){
			fastSystem.flatten(mathSymbolTable,bRoundCoefficients);
		}
	}

	//
	// get rid of all non-variables (functions, constants).
	//
	ArrayList<Variable> newVarList = new ArrayList<Variable>(newMath.variableList);
	Iterator<Variable> newVarListIter = newVarList.iterator();
	while (newVarListIter.hasNext()){
		Variable var = newVarListIter.next();
		if (var instanceof Constant || var instanceof Function || var instanceof InsideVariable || var instanceof OutsideVariable){
			newVarListIter.remove();
		}
	}
	Variable newVariables[] = newVarList.toArray(new Variable[newVarList.size()]);
	newMath.setAllVariables(newVariables);

	//
	// rebind all mathDescription
	//	
	for (int i = 0; i < newMath.subDomainList.size(); i++){
		SubDomain subDomain = newMath.subDomainList.get(i);
		FastSystem fastSystem = subDomain.getFastSystem();
		if (fastSystem != null){
			fastSystem.rebind();
		}
		Enumeration<Equation> equEnum = subDomain.getEquations();
		while (equEnum.hasMoreElements()){
			Equation equ = equEnum.nextElement();
			equ.bind(mathSymbolTable);
		}
		if (subDomain instanceof MembraneSubDomain){
			Enumeration<JumpCondition> jcEnum = ((MembraneSubDomain)subDomain).getJumpConditions();
			while (jcEnum.hasMoreElements()){
				JumpCondition jc = jcEnum.nextElement();
				jc.bind(mathSymbolTable);
			}
		}
	}
}

/**
 * conditionally transcribe comments from tokens to provider, if provider implements {@link Commented}
 * @param provider
 * @param token
 */
private void transcribeComments(Object provider, Token token){
	if (provider instanceof Commented) {
		Commented c = (Commented) provider;
		c.setBeforeComment(token.getBeforeComment());
		c.setAfterComment(token.getAfterComment());
	}
}


/**
 * This method was created by a SmartGuide.
 * @param tokens java.util.StringTokenizer
 * @exception java.lang.Exception The exception description.
 */
public void read_database(CommentStringTokenizer tokens) throws MathException {
							
	clearAll();
	
	VariableHash varHash = new VariableHash();	
	try {
		Token token = tokens.next();
		if (token.getValue().equalsIgnoreCase(VCML.MathDescription)){
			//token = tokens.nextToken();
			//setName(token);
			//CHECK THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			//if(!token.equals(argName)){
			//	throw new DataAccessException("MathDescription Version Name and Token Name Don't match");
			//}
			String tokenStr = tokens.nextToken();
			if (!tokenStr.equalsIgnoreCase(VCML.BeginBlock)){
				throw new MathException("unexpected token "+tokenStr+" expecting "+VCML.BeginBlock);
			}
		}	
		while (tokens.hasMoreTokens()){
			token = tokens.next();
			String tokenStr = token.getValue(); 
			if (tokenStr.equalsIgnoreCase(VCML.EndBlock)){
				break;
			}			
			if (tokenStr.equalsIgnoreCase(VCML.VolumeVariable)){
				tokenStr = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(tokenStr);
				String name = Variable.getNameFromCombinedIdentifier(tokenStr);
				VolVariable var = new VolVariable(name,domain);
				transcribeComments(var, token);
				varHash.addVariable(var);
//
// done in addVariable0()
//
//			InsideVariable inside = new InsideVariable(token+"_INSIDE", token);
//			addVariable0(inside);
//			OutsideVariable outside = new OutsideVariable(token+"_OUTSIDE", token);
//			addVariable0(outside);
				continue;
			}
			//
			// this is still here to gracefully read old mathDescriptions
			//
			if (tokenStr.equalsIgnoreCase(VCML.Task)){
				while (tokens.hasMoreTokens()){
					tokenStr = tokens.nextToken(); // toss away until end of block
					if (tokenStr.equalsIgnoreCase(VCML.EndBlock)){
						break;
					}			
				}
				continue;
			}			
			if (tokenStr.equalsIgnoreCase(VCML.MembraneVariable)){
				tokenStr = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(tokenStr);
				String name = Variable.getNameFromCombinedIdentifier(tokenStr);
				MemVariable var = new MemVariable(name,domain);
				transcribeComments(var, token);
				varHash.addVariable(var);
				continue;
			}
			if (tokenStr.equalsIgnoreCase(VCML.FilamentVariable)){
				tokenStr = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(tokenStr);
				String name = Variable.getNameFromCombinedIdentifier(tokenStr);
				FilamentVariable var = new FilamentVariable(name,domain);
				transcribeComments(var, token);
				varHash.addVariable(var);
				continue;
			}
			if (tokenStr.equalsIgnoreCase(VCML.PointVariable)){
				tokenStr = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(tokenStr);
				String name = Variable.getNameFromCombinedIdentifier(tokenStr);
				PointVariable var = new PointVariable(name,domain);
				transcribeComments(var, token);
				varHash.addVariable(var);
				continue;
			}
			if (tokenStr.equalsIgnoreCase(VCML.VolumeRegionVariable)){
				tokenStr = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(tokenStr);
				String name = Variable.getNameFromCombinedIdentifier(tokenStr);
				VolumeRegionVariable var = new VolumeRegionVariable(name,domain);
				transcribeComments(var, token);
				varHash.addVariable(var);
				continue;
			}
			if (tokenStr.equalsIgnoreCase(VCML.MembraneRegionVariable)){
				tokenStr = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(tokenStr);
				String name = Variable.getNameFromCombinedIdentifier(tokenStr);
				MembraneRegionVariable var = new MembraneRegionVariable(name,domain);
				transcribeComments(var, token);
				varHash.addVariable(var);
				continue;
			}
			if (tokenStr.equalsIgnoreCase(VCML.FilamentRegionVariable)){
				tokenStr = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(tokenStr);
				String name = Variable.getNameFromCombinedIdentifier(tokenStr);
				FilamentRegionVariable var = new FilamentRegionVariable(name,domain);
				transcribeComments(var, token);
				varHash.addVariable(var);
				continue;
			}
			if (tokenStr.equalsIgnoreCase(VCML.Constant)){
				tokenStr = tokens.nextToken();
				Expression exp = MathFunctionDefinitions.fixFunctionSyntax(tokens);
				Constant constant = new Constant(tokenStr,exp);
				transcribeComments(constant, token);
				varHash.addVariable(constant);
				continue;
			}
			if (tokenStr.equalsIgnoreCase("Parameter")){
				tokenStr = tokens.nextToken();
				ParameterVariable pv = new ParameterVariable(tokenStr);
				transcribeComments(pv, token);
				varHash.addVariable(pv);
				continue;
			}
			//stochastic variable
			if (tokenStr.equalsIgnoreCase(VCML.StochVolVariable))
			{
				tokenStr = tokens.nextToken();
				String name = Variable.getNameFromCombinedIdentifier(tokenStr);
				StochVolVariable var = new StochVolVariable(name);
				transcribeComments(var, token);
				varHash.addVariable(var);
				continue;
			}
			if (tokenStr.equalsIgnoreCase(VCML.VolumeParticleVariable))
			{
				tokenStr = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(tokenStr);
				String name = Variable.getNameFromCombinedIdentifier(tokenStr);
				VolumeParticleVariable var = new VolumeParticleVariable(name,domain);
				transcribeComments(var, token);
				varHash.addVariable(var);
				continue;
			}
			if (tokenStr.equalsIgnoreCase(VCML.MembraneParticleVariable))
			{
				tokenStr = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(tokenStr);
				String name = Variable.getNameFromCombinedIdentifier(tokenStr);
				MembraneParticleVariable var = new MembraneParticleVariable(name,domain);
				transcribeComments(var, token);
				varHash.addVariable(var);
				continue;
			}
			if (tokenStr.equalsIgnoreCase(VCML.ParticleMolecularType))
			{
				tokenStr = tokens.nextToken();
				String name = tokenStr;
				ParticleMolecularType particleMolecularType = new ParticleMolecularType(name);
				particleMolecularType.read(tokens);
				addParticleMolecularType(particleMolecularType);
				continue;
			}
			if (tokenStr.equalsIgnoreCase(VCML.VolumeParticleObservable)) {
				tokenStr = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(tokenStr);
				String name = Variable.getNameFromCombinedIdentifier(tokenStr);
				VolumeParticleObservable particle = new VolumeParticleObservable(name, domain, ObservableType.Molecules);
				// TODO: here
				particle.read(this, tokens, varHash);
				varHash.addVariable(particle);
				continue;
			}
			if (tokenStr.equalsIgnoreCase(VCML.VolumeParticleSpeciesPattern))
			{
				tokenStr = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(tokenStr);
				String name = Variable.getNameFromCombinedIdentifier(tokenStr);
				VolumeParticleSpeciesPattern var = new VolumeParticleSpeciesPattern(name,domain,null); // will set the locationName inside .read()
				var.read(this,tokens);
				// this is not really a variable and shouldn't be in the hash
				// sadly the way we check consistency for compartments makes in necessary
				varHash.addVariable(var);
				continue;
			}
			if (tokenStr.equalsIgnoreCase(VCML.Function)){
				tokenStr = tokens.nextToken();
				Expression exp = MathFunctionDefinitions.fixFunctionSyntax(tokens);
				Domain domain = Variable.getDomainFromCombinedIdentifier(tokenStr);
				String name = Variable.getNameFromCombinedIdentifier(tokenStr);
				
/** ---------------------------------------------------------------
 * ATTENTATION: this is a quick fix for a specific user to load his model
 * with a function name as "ATP/ADP".  This syntax is not allowed. 
-----------------------------------------------------------------------*/
if(name.equals("ATP/ADP"))
{
	name = "ATP_ADP_renamed";
	System.err.print("Applying species function name change ATP/ADP to ATP_ADP for a specific user (key=2288008)");
	Thread.dumpStack();
}
				
				Function function = new Function(name,exp,domain);
				transcribeComments(function, token);
				varHash.addVariable(function);
				continue;
			}
			if (tokenStr.equalsIgnoreCase(VCML.CompartmentSubDomain)){
				if (variableList.size() == 0) {
					setAllVariables(varHash.getAlphabeticallyOrderedVariables());
				}
				CompartmentSubDomain subDomain = new CompartmentSubDomain(token,this,tokens);
				addSubDomain0(subDomain);
				continue;
			}			
			if (tokenStr.equalsIgnoreCase(VCML.MembraneSubDomain)){
				if (variableList.size() == 0) {
					setAllVariables(varHash.getAlphabeticallyOrderedVariables());
				}
				MembraneSubDomain subDomain = MembraneSubDomain.create(this,token,tokens);
				addSubDomain0(subDomain);
				continue;
			}			
			if (tokenStr.equalsIgnoreCase(VCML.FilamentSubDomain)){
				if (variableList.size() == 0) {
					setAllVariables(varHash.getAlphabeticallyOrderedVariables());
				}
				tokenStr = tokens.nextToken();
				String subDomainName = tokenStr;
				tokenStr = tokens.nextToken();
				CompartmentSubDomain outsideCompartment = getCompartmentSubDomain(tokenStr);
				if (outsideCompartment == null){
					throw new MathFormatException("defined membrane subdomain without a corresponding outside volume subdomain first");
				}	
				FilamentSubDomain subDomain = new FilamentSubDomain(subDomainName,outsideCompartment);
				subDomain.read(this,tokens);
				addSubDomain0(subDomain);
				continue;
			}
			if (tokenStr.equalsIgnoreCase(VCML.PointSubDomain)){
				if (variableList.size() == 0) {
					setAllVariables(varHash.getAlphabeticallyOrderedVariables());
				}
				tokenStr = tokens.nextToken();
				String subDomainName = tokenStr;
				PointSubDomain subDomain = new PointSubDomain(subDomainName);
				subDomain.parseBlock(this, tokens);
				addSubDomain0(subDomain);
				continue;
			}
			//
			// this is here so that old mathDescriptions are read gracefully.
			//
			if (tokenStr.equalsIgnoreCase(VCML.Mesh)){
				while (tokens.hasMoreTokens()){
					tokenStr = tokens.nextToken(); // toss away until end of block
					if (tokenStr.equalsIgnoreCase(VCML.EndBlock)){
						break;
					}			
				}
				continue;
			}
			
			if (tokenStr.equalsIgnoreCase(VCML.Event)) {
				if (variableList.size() == 0) {
					setAllVariables(varHash.getAlphabeticallyOrderedVariables());
				}
				//Event event = new Event(tokenStr, this, tokens);
				Event event = new Event(token, this, tokens);
				eventList.add(event);
				continue;
			}
			if (tokenStr.equalsIgnoreCase(VCML.VolumeRandomVariable)) {
				tokenStr = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(tokenStr);
				String name = Variable.getNameFromCombinedIdentifier(tokenStr);
				RandomVariable randomVariable = new VolumeRandomVariable(name, this, tokens, domain);
				transcribeComments(randomVariable, token);
				varHash.addVariable(randomVariable);
				continue;
			}
			if (tokenStr.equalsIgnoreCase(VCML.MembraneRandomVariable)) {
				tokenStr = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(tokenStr);
				String name = Variable.getNameFromCombinedIdentifier(tokenStr);
				RandomVariable randomVariable = new MembraneRandomVariable(name, this, tokens, domain);
				transcribeComments(randomVariable, token);
				varHash.addVariable(randomVariable);
				continue;
			}
			if (tokenStr.equalsIgnoreCase(VCML.PostProcessingBlock)) {
				postProcessingBlock.read(tokens);
				continue;
			}
			throw new MathFormatException("unexpected identifier "+tokenStr);
		}		
	}catch (Throwable e){
		e.printStackTrace(System.out);
		throw new MathException("line #" + tokens.lineIndex() + " Exception: "+e.getMessage());
	}
	refreshDependencies();
	fireStateChanged();
}


public void addParticleMolecularType(ParticleMolecularType particleMolecularType) {
	if (!particleMolecularTypes.contains(particleMolecularType)){
		particleMolecularTypes .add(particleMolecularType);
	}
}


public void refreshDependencies() {
	for (SubDomain subDomain : this.subDomainList){
		subDomain.refreshDependencies(this);
	}
}


/**
 * Remove a javax.swing.event.ChangeListener.
 */
public void removeChangeListener(javax.swing.event.ChangeListener newListener) {
	if (aChangeListener != null) {
		aChangeListener.remove(newListener);
	};
}


/**
 * The removePropertyChangeListener method was generated to support the propertyChange field.
 */
public synchronized void removePropertyChangeListener(java.beans.PropertyChangeListener listener) {
	getPropertyChange().removePropertyChangeListener(listener);
}

/**
 * The removeVetoableChangeListener method was generated to support the vetoPropertyChange field.
 */
public synchronized void removeVetoableChangeListener(java.beans.VetoableChangeListener listener) {
	getVetoPropertyChange().removeVetoableChangeListener(listener);
}


/**
 * This method was created by a SmartGuide.
 * @param var cbit.vcell.math.Variable
 */
public void setAllVariables(Variable vars[]) throws MathException, ExpressionBindingException {
	// make sure it's OK
	VariableHash hash = new VariableHash();
	for (int i = 0; i < vars.length; i++){
		hash.addVariable(vars[i]);
	}	
	hash.getTopologicallyReorderedVariables();
	
	variableList.clear();
	variableHashTable.clear();
	// adding without binding
	for (Variable var : vars){
		if (var instanceof InsideVariable || var instanceof OutsideVariable) { // if vars has inside and outside already, ignore
			continue;
		}
		if (getVariable(var.getName()) != null){
			throw new MathException("variable "+var.getName()+" already exists");
		}
		variableList.add(var);
		variableHashTable.put(var.getName(), var);
		if (var instanceof VolVariable || var instanceof VolumeRegionVariable){
			//
			// for Volume Variables, also create an InsideVariable and an OutsideVariable for use in JumpConditions
			//
			InsideVariable inVar = new InsideVariable(var.getName()+InsideVariable.INSIDE_VARIABLE_SUFFIX, var.getName());
			variableList.add(inVar);
			variableHashTable.put(inVar.getName(), inVar);
			OutsideVariable outVar = new OutsideVariable(var.getName()+OutsideVariable.OUTSIDE_VARIABLE_SUFFIX, var.getName());
			variableList.add(outVar);
			variableHashTable.put(outVar.getName(), outVar);
		}
	}
	// bind each variable
	Iterator<Variable> iter = variableList.iterator();
	while (iter.hasNext()) {
		iter.next().bind(this);
	}
	
	for (int i = 0; i < subDomainList.size(); i++){
		SubDomain subDomain = subDomainList.get(i);
		Enumeration<Equation> equEnum = subDomain.getEquations();
		while (equEnum.hasMoreElements()){
			Equation equ = equEnum.nextElement();
			equ.bind(this);
		}
		FastSystem fastSystem = subDomain.getFastSystem();
		if (fastSystem!=null){
			Enumeration<FastRate> frEnum = fastSystem.getFastRates();
			while (frEnum.hasMoreElements()){
				FastRate fr = frEnum.nextElement();
				fr.bind(this);
			}
			Enumeration<FastInvariant> fiEnum = fastSystem.getFastInvariants();
			while (fiEnum.hasMoreElements()){
				FastInvariant fi = fiEnum.nextElement();
				fi.bind(this);
			}
		}
	}
	for (Event event : eventList) {
		event.bind(this);
	}
	fireStateChanged();
}


/**
 * Sets the description property (java.lang.String) value.
 * @param description The new value for the property.
 * @exception java.beans.PropertyVetoException The exception description.
 * @see #getDescription
 */
public void setDescription(java.lang.String description) throws java.beans.PropertyVetoException {
	String oldValue = fieldDescription;
	fireVetoableChange("description", oldValue, description);
	fieldDescription = description;
	firePropertyChange("description", oldValue, description);
}


/**
 * This method was created in VisualAge.
 * @param geometry cbit.vcell.geometry.Geometry
 */
public void setGeometry(Geometry argGeometry) throws java.beans.PropertyVetoException {
	Geometry oldValue = this.geometry;
	fireVetoableChange(GeometryOwner.PROPERTY_NAME_GEOMETRY, oldValue, argGeometry);
//	this.geometry = argGeometry;
	setGeometry0(argGeometry);
	firePropertyChange(GeometryOwner.PROPERTY_NAME_GEOMETRY, oldValue, argGeometry);
	fireStateChanged();
	//
	// compute warning string (if necessary)
	//
	isValid();

}


/**
 * This method was created in VisualAge.
 * @param geometry cbit.vcell.geometry.Geometry
 */
private void setGeometry0(Geometry geometry) {
	if (this.geometry != geometry){
		this.geometry = geometry;
	}
}

/**
 * Sets the name property (java.lang.String) value.
 * @param name The new value for the property.
 * @exception java.beans.PropertyVetoException The exception description.
 * @see #getName
 */
public void setName(java.lang.String name) throws java.beans.PropertyVetoException {
	String oldValue = fieldName;
	fireVetoableChange("name", oldValue, name);
	fieldName = name;
	firePropertyChange("name", oldValue, name);
}


/**
 * Sets the warning property (java.lang.String) value.
 * @param warning The new value for the property.
 * @see #getWarning
 */
private void setWarning(java.lang.String warning) {
	String oldValue = fieldWarning;
	fieldWarning = warning;
	firePropertyChange("warning", oldValue, warning);
}


/**
 * Insert the method's description here.
 * Creation date: (10/9/2002 10:54:06 PM)
 * @return cbit.vcell.math.MathDescription
 */
void substituteInPlace(MathSymbolTableFactory mathSymbolTableFactory, Function functionsToSubstitute[]) throws MathException, ExpressionException {
	//
	// make a "identity" simulation (no overrides), this will help to substitute/flatten expressions.
	//
	for (int i = 0; i < functionsToSubstitute.length; i++){
		//variableList.insertElementAt(functionsToSubstitute[i], 0);
		variableList.add(0, functionsToSubstitute[i]); 
		variableHashTable.put(functionsToSubstitute[i].getName(), functionsToSubstitute[i]);
	}
	MathSymbolTable simSymbolTable = mathSymbolTableFactory.createMathSymbolTable(this);
	MathDescription newMath = this;
	boolean bRoundCoefficients = false;
	//
	// substitute all rates, initial conditions, boundary conditions, jump conditions, fast rates, fast invariants
	//
	for (int i = 0; i < newMath.subDomainList.size(); i++){
		SubDomain subDomain = newMath.subDomainList.get(i);
		FastSystem fastSystem = subDomain.getFastSystem();
		if (fastSystem != null){
			fastSystem.flatten(simSymbolTable,bRoundCoefficients);
		}
		Enumeration<Equation> equEnum = subDomain.getEquations();
		while (equEnum.hasMoreElements()){
			Equation equ = equEnum.nextElement();
			equ.flatten(simSymbolTable,bRoundCoefficients);
		}
		if (subDomain instanceof MembraneSubDomain){
			Enumeration<JumpCondition> jcEnum = ((MembraneSubDomain)subDomain).getJumpConditions();
			while (jcEnum.hasMoreElements()){
				JumpCondition jc = jcEnum.nextElement();
				jc.flatten(simSymbolTable,bRoundCoefficients);
			}
		}
	}

	//
	// rebind all mathDescription
	//
	for (int i = 0; i < newMath.subDomainList.size(); i++){
		SubDomain subDomain = newMath.subDomainList.get(i);
		FastSystem fastSystem = subDomain.getFastSystem();
		if (fastSystem != null){
			fastSystem.rebind();
		}
		Enumeration<Equation> equEnum = subDomain.getEquations();
		while (equEnum.hasMoreElements()){
			Equation equ = equEnum.nextElement();
			equ.bind(simSymbolTable);
		}
		if (subDomain instanceof MembraneSubDomain){
			Enumeration<JumpCondition> jcEnum = ((MembraneSubDomain)subDomain).getJumpConditions();
			while (jcEnum.hasMoreElements()){
				JumpCondition jc = jcEnum.nextElement();
				jc.bind(simSymbolTable);
			}
		}
	}
}


/**
 * Insert the method's description here.
 * Creation date: (9/28/2004 5:50:22 PM)
 * @return java.lang.String
 * @param memoryMathDescription cbit.vcell.math.MathDescription
 * @param databaseMathDescription cbit.vcell.math.MathDescription
 */
public static MathCompareResults testEquivalency(MathSymbolTableFactory mathSymbolTableFactory, MathDescription mathDescription1, MathDescription mathDescription2) {

	try {
		MathCompareResults invariantResults = mathDescription2.compareInvariantAttributes(mathDescription1,false);
		if (!invariantResults.isEquivalent()){
			//
			// can't be equivalent or equal
			//
			return invariantResults;
		}else if (mathDescription2.compareEqual(mathDescription1)){
			return new MathCompareResults(Decision.MathEquivalent_NATIVE);
		}else{
			//
			// must test for equivalence
			//
			HashSet<String> indepVars1 = mathDescription1.getStateVariableNames();
			HashSet<String> indepVars2 = mathDescription2.getStateVariableNames();
			HashSet<String> union = new HashSet<String>(indepVars1);
			union.addAll(indepVars2);
			
			MathDescription canonicalMath1 = MathDescription.createCanonicalMathDescription(mathSymbolTableFactory,createMathWithExpandedEquations(mathDescription1,union));
			MathDescription canonicalMath2 = MathDescription.createCanonicalMathDescription(mathSymbolTableFactory,createMathWithExpandedEquations(mathDescription2,union));

			HashSet<String> depVarsToSubstitute = new HashSet<String>(union);
			depVarsToSubstitute.removeAll(indepVars1);
			if (depVarsToSubstitute.size()>0){
				String depVarNames[] = (String[])depVarsToSubstitute.toArray(new String[depVarsToSubstitute.size()]);
				Function functionsToSubstitute[] = MathDescription.getFlattenedFunctions(mathSymbolTableFactory,mathDescription1,depVarNames);
				canonicalMath1.substituteInPlace(mathSymbolTableFactory,functionsToSubstitute);
				canonicalMath2.substituteInPlace(mathSymbolTableFactory,functionsToSubstitute);
			}
			// flatten again
			canonicalMath1.makeCanonical(mathSymbolTableFactory);
			canonicalMath2.makeCanonical(mathSymbolTableFactory);
			// now compare
			return canonicalMath2.compareEquivalentCanonicalMath(canonicalMath1);
		}
	}catch (MathException e){
		e.printStackTrace(System.out);
		throw new RuntimeException(e.getMessage());
	}catch (ExpressionException e){
		e.printStackTrace(System.out);
		throw new RuntimeException(e.getMessage());
	}
}

public boolean hasDiscontinuities() throws ExpressionException {
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()) {		
		SubDomain sd = enum1.nextElement();
		Enumeration<Equation> enum_equ = sd.getEquations();
		while (enum_equ.hasMoreElements()){
			Equation equation = enum_equ.nextElement();
			if (equation.hasDiscontinuities(this)) {
				return true;
			}
		}
		if (sd.getFastSystem() != null) {
			Expression[] exps = sd.getFastSystem().getExpressions();
			for (int i = 0; i < exps.length; i++) {
				if (exps[i].getDiscontinuities().size() > 0) {
					return true;
				}
			}
		}
	}
	for (Variable var : variableList) {
		Expression expression = var.getExpression();
		if (expression != null && expression.getDiscontinuities().size() > 0) {
			return true;			
		}
	}
	return false;
}


/**
 * This method was created by a SmartGuide.
 * @return java.lang.String
 */
public String toString() {
	return "Math@"+Integer.toHexString(hashCode())+"("+version+")";
}


public MathType getMathType()
{
	if (isNonSpatialStoch() || isSpatialStoch() || isSpatialHybrid()){
		return MathType.Stochastic;
	} else if (isRuleBased()){
		return MathType.RuleBased;
	}else{
		return MathType.Deterministic;
	}
}


public void getEntries(Map<String, SymbolTableEntry> entryMap) {
	ReservedMathSymbolEntries.getAll(entryMap,false);
	for (Variable v : variableList) {
		entryMap.put(v.getName(), v);
	}
}

public void addEvent(Event event) throws MathException {
	if (getEvent(event.getName()) != null) {
		throw new MathException("Event '" + event.getName() + "' already exists.");
	}
	eventList.add(event);
}

public Event getEvent(String name) {
	for (Event e : eventList) {
		if (e.getName().equals(name)) {
			return e;
		}
	}	
	return null;
}

public boolean hasEvents() {
	return eventList.size() > 0;
}

public boolean hasRandomVariables() {
	for (Variable var : variableList) {
		if (var instanceof RandomVariable) {
			return true;
		}
	}
	return false;
}

public boolean hasVolumeRegionEquations() {
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()){
		SubDomain subDomain = enum1.nextElement();
		if (subDomain instanceof CompartmentSubDomain){
			Enumeration<Equation> equations = subDomain.getEquations();
			while (equations.hasMoreElements()) {
				if (equations.nextElement() instanceof VolumeRegionEquation){
					return true;
				}
			}
		}
	}
	return false;		
}


public boolean hasRegionSizeFunctions() {
	return bRegionSizeFunctionsUsed;
}


public final PostProcessingBlock getPostProcessingBlock() {
	return postProcessingBlock;
}


public boolean hasDirichletAtMembrane() {
	for (SubDomain subDomain : subDomainList) {
		if (subDomain instanceof CompartmentSubDomain) {
			List<BoundaryConditionSpec> bcsList = ((CompartmentSubDomain)subDomain).getBoundaryconditionSpecs();
			for (BoundaryConditionSpec boundaryConditionSpec : bcsList) {
				if (boundaryConditionSpec.getBoundaryConditionType().isDIRICHLET()) {
					return true;
				}
			}
		}
	}
	return false;
}


public ParticleMolecularType getParticleMolecularType(String molecularTypeName) {
	for (ParticleMolecularType particleMolecularType : particleMolecularTypes){
		if (particleMolecularType.getName().equals(molecularTypeName)){
			return particleMolecularType;
		}
	}
	return null;
}

public List<ParticleMolecularType> getParticleMolecularTypes() {
	return Collections.unmodifiableList(particleMolecularTypes);
}


// if at least one species observable is present 
// the solver will need a -cb flag in its command line
public boolean hasSpeciesObservable() {
	Enumeration<Variable> enum1 = getVariables();
	while (enum1.hasMoreElements()){
		Variable var = enum1.nextElement();
		if (var instanceof ParticleObservable){
			if(((ParticleObservable)var).getType() == ObservableType.Species) {
				return true;
			}
		}
	}
	return false;
}

@Override
public boolean isMovingMembrane( ) {
	Predicate<SubDomain> movingMembrane = s ->  {
		MembraneSubDomain m = BeanUtils.downcast(MembraneSubDomain.class, s);
		return m != null && m.isMoving();
	};
	return subDomainList.stream().filter(movingMembrane).findAny().isPresent();
}

}
