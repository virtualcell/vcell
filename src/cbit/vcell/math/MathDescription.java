package cbit.vcell.math;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Random;
import java.util.Vector;

import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.vcell.util.BeanUtils;
import org.vcell.util.CommentStringTokenizer;
import org.vcell.util.Compare;
import org.vcell.util.Matchable;
import org.vcell.util.document.BioModelChildSummary;
import org.vcell.util.document.ExternalDataIdentifier;
import org.vcell.util.document.KeyValue;
import org.vcell.util.document.Version;
import org.vcell.util.document.Versionable;

import cbit.vcell.document.GeometryOwner;
import cbit.vcell.field.FieldFunctionArguments;
import cbit.vcell.field.FieldFunctionContainer;
import cbit.vcell.field.FieldUtilities;
import cbit.vcell.geometry.Geometry;
import cbit.vcell.geometry.SubVolume;
import cbit.vcell.geometry.surface.GeometricRegion;
import cbit.vcell.geometry.surface.SurfaceGeometricRegion;
import cbit.vcell.geometry.surface.VolumeGeometricRegion;
import cbit.vcell.mapping.MappingException;
import cbit.vcell.mapping.VariableHash;
import cbit.vcell.math.Variable.Domain;
import cbit.vcell.parser.Expression;
import cbit.vcell.parser.ExpressionBindingException;
import cbit.vcell.parser.ExpressionException;
import cbit.vcell.parser.ExpressionUtils;
import cbit.vcell.parser.SimpleSymbolTable;
import cbit.vcell.parser.SymbolTable;
import cbit.vcell.parser.SymbolTableEntry;
import cbit.vcell.parser.SymbolTableFunctionEntry;
import cbit.vcell.solver.Simulation;
import cbit.vcell.solver.SimulationSymbolTable;
/**
 * This class was generated by a SmartGuide.
 * 
 */
public class MathDescription implements Versionable, Matchable, SymbolTable, Serializable,FieldFunctionContainer {
	protected transient java.util.Vector<ChangeListener> aChangeListener = null;
	private Version version = null;
	private Vector<SubDomain> subDomainList = new Vector<SubDomain>();
	private Vector<Variable> variableList = new Vector<Variable>();
	private HashMap<String, Variable> variableHashTable = new HashMap<String, Variable>();
	private Geometry geometry = null;
	private java.lang.String fieldName = new String("NoName");
	protected transient java.beans.VetoableChangeSupport vetoPropertyChange;
	protected transient java.beans.PropertyChangeSupport propertyChange;
	private java.lang.String fieldDescription = new String();
	private transient java.lang.String fieldWarning = null;
	
	private ArrayList<Event> eventList = new ArrayList<Event>();

	public final static String MATH_DIFFERENT = "different";
	public final static String MATH_EQUIVALENT = "equivalent";
	public final static String MATH_SAME = "same";
	
	private boolean bRegionSizeFunctionsUsed = false;

/**
 * MathDescription constructor comment.
 */
public MathDescription(Version argVersion) {
	super();
	this.version = argVersion;
	if (argVersion!=null){
		this.fieldName = argVersion.getName();
		this.fieldDescription = argVersion.getAnnot();
	}
}


/**
 * Insert the method's description here.
 * Creation date: (9/2/2004 3:05:54 PM)
 * @param mathDescription cbit.vcell.math.MathDescription
 */
public MathDescription(MathDescription mathDescription) {
	this.fieldName = mathDescription.getName();
	this.fieldDescription = mathDescription.getDescription();
	this.version = mathDescription.getVersion();
	this.geometry = mathDescription.getGeometry();
	try {
		read_database(new CommentStringTokenizer(mathDescription.getVCML_database()));
	}catch (MathException e){
		e.printStackTrace(System.out);
		throw new RuntimeException(e.getMessage());
	}
}


/**
 * MathDescription constructor comment.
 */
public MathDescription(String name) {
	this.fieldName = name;
	this.version = null;
}


/**
 * Add a javax.swing.event.ChangeListener.
 */
public void addChangeListener(ChangeListener newListener) {
	if (aChangeListener == null) {
		aChangeListener = new java.util.Vector<ChangeListener>();
	};
	if (! aChangeListener.contains(newListener)) {
		aChangeListener.addElement(newListener);
	}
}


/**
 * The addPropertyChangeListener method was generated to support the propertyChange field.
 */
public synchronized void addPropertyChangeListener(java.beans.PropertyChangeListener listener) {
	getPropertyChange().addPropertyChangeListener(listener);
}


/**
 * This method was created by a SmartGuide.
 * @param subDomain cbit.vcell.math.SubDomain
 * @exception java.lang.Exception The exception description.
 */
public void addSubDomain(SubDomain subDomain) throws MathException {
	addSubDomain0(subDomain);
	fireStateChanged();
}


/**
 * This method was created by a SmartGuide.
 * @param subDomain cbit.vcell.math.SubDomain
 * @exception java.lang.Exception The exception description.
 */
private void addSubDomain0(SubDomain subDomain) throws MathException {
	if (subDomain == null){
		throw new MathException("subdomain is null");
	}	
	if (subDomain instanceof CompartmentSubDomain){
		if (getCompartmentSubDomain(subDomain.getName()) != null){
			throw new MathException("subDomain "+subDomain.getName()+" already exists");
		}
	}else if (subDomain instanceof MembraneSubDomain){
		if (getMembraneSubDomain(subDomain.getName()) != null){
			throw new MathException("subDomain "+subDomain.getName()+" already exists");
		}
	}else if (subDomain instanceof FilamentSubDomain){
		if (getSubDomain(subDomain.getName()) != null){
			throw new MathException("subDomain "+subDomain.getName()+" already exists");
		}
	}	
	
	subDomainList.addElement(subDomain);
}


/**
 * This method was created by a SmartGuide.
 * @param var cbit.vcell.math.Variable
 */
public void addVariable(Variable var) throws MathException, ExpressionBindingException {
	addVariable0(var);
	fireStateChanged();
}


/**
 * This method was created by a SmartGuide.
 * @param var cbit.vcell.math.Variable
 */
private void addVariable0(Variable var) throws MathException, ExpressionBindingException {
	if (getVariable(var.getName()) != null){
		throw new MathException("variable "+var.getName()+" already exists");
	}
	variableList.addElement(var);
	variableHashTable.put(var.getName(), var);
	//var.bind(this);
	if (var instanceof VolVariable){
		//
		// for Volume Variables, also create an InsideVariable and an OutsideVariable for use in JumpConditions
		//
		InsideVariable inVar = new InsideVariable(var.getName()+InsideVariable.INSIDE_VARIABLE_SUFFIX, var.getName());
		variableList.addElement(inVar);
		variableHashTable.put(inVar.getName(), inVar);
		inVar.bind(this);
		OutsideVariable outVar = new OutsideVariable(var.getName()+OutsideVariable.OUTSIDE_VARIABLE_SUFFIX, var.getName());
		variableList.addElement(outVar);
		variableHashTable.put(outVar.getName(), outVar);
		outVar.bind(this);
	}
}


/**
 * The addVetoableChangeListener method was generated to support the vetoPropertyChange field.
 */
public synchronized void addVetoableChangeListener(java.beans.VetoableChangeListener listener) {
	getVetoPropertyChange().addVetoableChangeListener(listener);
}


/**
 * This method was created by a SmartGuide.
 */
private void clearAll() {
	subDomainList.clear();
	variableList.clear();
	variableHashTable.clear();
	eventList.clear();
}


/**
 * Insert the method's description here.
 * Creation date: (4/24/2003 3:32:01 PM)
 */
public void clearVersion() {
	version = null;
}


/**
 * This method was created in VisualAge.
 * @return boolean
 * @param mathDesc cbit.vcell.math.MathDescription
 */
public boolean compareEqual(Matchable object) {

	MathDescription mathDesc = null;
	if (object == null) {
		return false;
	}
	if (!(object instanceof MathDescription)) {
		return false;
	} else {
		mathDesc = (MathDescription) object;
	}

	if (!Compare.isEqual(getName(), mathDesc.getName())) {
		return false;
	}
	if (!Compare.isEqual(getDescription(), mathDesc.getDescription())) {
		return false;
	}
	//
	// compare subdomains
	//
	if (!Compare.isEqual(subDomainList, mathDesc.subDomainList)) {
		return false;
	}
	//
	// compare variables
	//
	if (!Compare.isEqual(variableList, mathDesc.variableList)) {
		return false;
	}
	//
	// compare geometry
	//
	if (!Compare.isEqualOrNull(geometry, mathDesc.geometry)) {
		return false;
	}

	//
	// compare events
	//
	if (!Compare.isEqual(eventList, mathDesc.eventList)) {
		return false;
	}

	return true;
}


/**
 * This method was created in VisualAge.
 * @return boolean
 * @param mathDesc cbit.vcell.math.MathDescription
 */
public boolean compareEquivalent(MathDescription newMathDesc, StringBuffer reasonForDecision,boolean bSilent) {
	final String NATIVE_MATHS_ARE_SAME =			" MathsEquivalent:Native ";
	final String MATHS_ARE_NUMERICALLY_EQUIVALENT =	" MathsEquivalent:Numerically ";
	final String DIFFERENT_NUMBER_OF_VARIABLES =	" MathsDifferent:DifferentNumberOfVariables ";
	final String VARIABLES_DONT_MATCH =				" MathsDifferent:VariablesDontMatch ";
	final String DIFFERENT_NUMBER_OF_EXPRESSIONS =	" MathsDifferent:DifferentNumberOfExpressions ";
	final String EQUATION_ADDED =					" MathsDifferent:EquationAdded ";
	final String EQUATION_REMOVED =					" MathsDifferent:EquationRemoved ";
	final String EXPRESSION_IS_DIFFERENT =			" MathsDifferent:ExpressionIsDifferent ";
	final String FASTRATE_EXPRESSION_IS_DIFFERENT =	" MathsDifferent:FastRateExpressionIsDifferent ";
	final String FASTINVARIANT_EXPRESSION_IS_DIFFERENT = " MathsDifferent:FastInvariantExpressionIsDifferent ";
	final String UNKNOWN_DIFFERENCE_IN_EQUATION =	" MathsDifferent:UnknownDifferenceInEquation ";
	final String DIFFERENT_NUMBER_OF_SUBDOMAINS =	" MathsDifferent:DifferentNumberOfSubdomains ";
	final String FAILURE_DIV_BY_ZERO =			 	" MathsDifferent:FailedDivideByZero ";
	final String FAILURE_UNKNOWN = 					" MathsDifferent:FailedUnknown ";
	final String UNKNOWN_DIFFERENCE_IN_MATH =		" MathsDifferent:Unknown ";
	final String DIFFERENT_BOUNDARY_CONDITION_TYPE = " MathsDifferent:DifferentBoundaryConditionType ";
	try {
		MathDescription oldMathDesc = this;
	    if (oldMathDesc.compareEqual(newMathDesc)){
		    reasonForDecision.append(NATIVE_MATHS_ARE_SAME);
		    return true;
		}else{
		    //if (!bSilent) System.out.println("------NATIVE MATHS ARE DIFFERENT----------------------");
			Variable oldVars[] = (Variable[])BeanUtils.getArray(oldMathDesc.getVariables(),Variable.class);
			Variable newVars[] = (Variable[])BeanUtils.getArray(newMathDesc.getVariables(),Variable.class);
			if (oldVars.length != newVars.length){
				//
				// number of state variables are not equal (canonical maths only have state variables)
				//
				reasonForDecision.append(DIFFERENT_NUMBER_OF_VARIABLES);
				return false;
			}
			if (!Compare.isEqual(oldVars,newVars)){
				//
				// variable names are not equivalent (nothing much we can do)
				//
				reasonForDecision.append(VARIABLES_DONT_MATCH);
				return false;
			}
			//
			// go through the list of SubDomains, and compare equations one by one and "correct" new one if possible
			//
			SubDomain subDomainsOld[] = (SubDomain[])BeanUtils.getArray(oldMathDesc.getSubDomains(),SubDomain.class);
			SubDomain subDomainsNew[] = (SubDomain[])BeanUtils.getArray(newMathDesc.getSubDomains(),SubDomain.class);
			if (subDomainsOld.length != subDomainsNew.length){
				reasonForDecision.append(DIFFERENT_NUMBER_OF_SUBDOMAINS);
				return false;
			}
			for (int i = 0; i < subDomainsOld.length; i++){
				// compare boundary type
				if (getGeometry().getDimension() > 0) {
					if (subDomainsOld[i] instanceof CompartmentSubDomain && subDomainsNew[i] instanceof CompartmentSubDomain) {
						CompartmentSubDomain csdOld = (CompartmentSubDomain)subDomainsOld[i];
						CompartmentSubDomain csdNew = (CompartmentSubDomain)subDomainsNew[i];
						if (!Compare.isEqualOrNull(csdOld.getBoundaryConditionXm(), csdNew.getBoundaryConditionXm())
								|| !Compare.isEqualOrNull(csdOld.getBoundaryConditionXp(), csdNew.getBoundaryConditionXp())
								|| !Compare.isEqualOrNull(csdOld.getBoundaryConditionYm(), csdNew.getBoundaryConditionYm())
								|| !Compare.isEqualOrNull(csdOld.getBoundaryConditionYp(), csdNew.getBoundaryConditionYp())
								|| !Compare.isEqualOrNull(csdOld.getBoundaryConditionZm(), csdNew.getBoundaryConditionZm())
								|| !Compare.isEqualOrNull(csdOld.getBoundaryConditionZp(), csdNew.getBoundaryConditionZp())
							) {
							reasonForDecision.append(DIFFERENT_BOUNDARY_CONDITION_TYPE);
							return false;
						}					
					} else if (subDomainsOld[i] instanceof MembraneSubDomain && subDomainsNew[i] instanceof MembraneSubDomain) {
						MembraneSubDomain msdOld = (MembraneSubDomain)subDomainsOld[i];
						MembraneSubDomain msdNew = (MembraneSubDomain)subDomainsNew[i];
						if (!Compare.isEqualOrNull(msdOld.getBoundaryConditionXm(), msdNew.getBoundaryConditionXm())
								|| !Compare.isEqualOrNull(msdOld.getBoundaryConditionXp(), msdNew.getBoundaryConditionXp())
								|| !Compare.isEqualOrNull(msdOld.getBoundaryConditionYm(), msdNew.getBoundaryConditionYm())
								|| !Compare.isEqualOrNull(msdOld.getBoundaryConditionYp(), msdNew.getBoundaryConditionYp())
								|| !Compare.isEqualOrNull(msdOld.getBoundaryConditionZm(), msdNew.getBoundaryConditionZm())
								|| !Compare.isEqualOrNull(msdOld.getBoundaryConditionZp(), msdNew.getBoundaryConditionZp())
							) {
							reasonForDecision.append(DIFFERENT_BOUNDARY_CONDITION_TYPE);
							return false;
						}					
					}
				}
				
				for (int j = 0; j < oldVars.length; j++){
					//
					// test equation for this subdomain and variable
					//
					{
					Equation oldEqu = subDomainsOld[i].getEquation(oldVars[j]);
					Equation newEqu = subDomainsNew[i].getEquation(oldVars[j]);
					if (!Compare.isEqualOrNull(oldEqu,newEqu)){
						boolean bFoundDifference = false;
						//
						// equation didn't compare exactly, lets try to evaluate some instead
						//
						if (oldEqu==null){
							//
							// only one MathDescription had Equation for this Variable.
							//
							reasonForDecision.append(EQUATION_ADDED);
							return false;
						}
						if (newEqu==null){
							//
							// only one MathDescription had Equation for this Variable.
							//
							reasonForDecision.append(EQUATION_REMOVED);
							return false;
						}
						Expression oldExps[] = (Expression[])BeanUtils.getArray(oldEqu.getExpressions(oldMathDesc),Expression.class);
						Expression newExps[] = (Expression[])BeanUtils.getArray(newEqu.getExpressions(newMathDesc),Expression.class);
						if (oldExps.length != newExps.length){
							reasonForDecision.append(DIFFERENT_NUMBER_OF_EXPRESSIONS);
							return false;
						}
						for (int k = 0; k < oldExps.length; k++){
							if (!oldExps[k].compareEqual(newExps[k])){
								bFoundDifference = true;
								if (!ExpressionUtils.functionallyEquivalent(oldExps[k],newExps[k])){
									//
									// difference couldn't be reconciled
									//
									if (!bSilent) System.out.println("expressions are different Old: '"+oldExps[k]+"'\n"+
													   "expressions are different New: '"+newExps[k]+"'");
									reasonForDecision.append(EXPRESSION_IS_DIFFERENT);
									return false;
								}else{
									//if (!bSilent) System.out.println("expressions are equivalent Old: '"+oldExps[k]+"'\n"+
													   //"expressions are equivalent New: '"+newExps[k]+"'");
								}
							}
						}
						//
						// equation was not strictly "equal" but passed all tests, replace with old equation and move on
						//
						if (bFoundDifference){
							subDomainsNew[i].replaceEquation(oldEqu);
						}else{
							//
							// couldn't find the smoking gun, just plain bad
							//
							if (!bSilent) System.out.println("couldn't find problem with equation for "+oldVars[j].getName()+" in compartment "+subDomainsOld[i].getName());
							reasonForDecision.append(UNKNOWN_DIFFERENCE_IN_EQUATION);
							return false;
						}
					}
					}
					
					{
						ParticleProperties oldPP = subDomainsOld[i].getParticleProperties(oldVars[j]);
						ParticleProperties newPP = subDomainsNew[i].getParticleProperties(oldVars[j]);
						if (!Compare.isEqualOrNull(oldPP, newPP)){
							return false;
						}
					}
					//
					// if a membrane, test jumpCondition for this subdomain and variable
					//
					if (subDomainsOld[i] instanceof MembraneSubDomain && oldVars[j] instanceof VolVariable){
						JumpCondition oldJumpCondition = ((MembraneSubDomain)subDomainsOld[i]).getJumpCondition((VolVariable)oldVars[j]);
						JumpCondition newJumpCondition = ((MembraneSubDomain)subDomainsNew[i]).getJumpCondition((VolVariable)oldVars[j]);
						if (!Compare.isEqualOrNull(oldJumpCondition,newJumpCondition)){
							boolean bFoundDifference = false;
							//
							// equation didn't compare exactly, lets try to evaluate some instead
							//
							if (oldJumpCondition==null){
								//
								// only one MathDescription had Equation for this Variable.
								//
								reasonForDecision.append(EQUATION_ADDED);
								return false;
							}
							if (newJumpCondition==null){
								//
								// only one MathDescription had Equation for this Variable.
								//
								reasonForDecision.append(EQUATION_REMOVED);
								return false;
							}
							Expression oldExps[] = (Expression[])BeanUtils.getArray(oldJumpCondition.getExpressions(oldMathDesc),Expression.class);
							Expression newExps[] = (Expression[])BeanUtils.getArray(newJumpCondition.getExpressions(newMathDesc),Expression.class);
							if (oldExps.length != newExps.length){
								reasonForDecision.append(DIFFERENT_NUMBER_OF_EXPRESSIONS);
								return false;
							}
							for (int k = 0; k < oldExps.length; k++){
								if (!oldExps[k].compareEqual(newExps[k])){
									bFoundDifference = true;
									if (!ExpressionUtils.functionallyEquivalent(oldExps[k],newExps[k])){
										//
										// difference couldn't be reconciled
										//
										if (!bSilent) System.out.println("expressions are different Old: '"+oldExps[k]+"'\n"+
														   "expressions are different New: '"+newExps[k]+"'");
										reasonForDecision.append(EXPRESSION_IS_DIFFERENT);
										return false;
									}else{
										//if (!bSilent) System.out.println("expressions are equivalent Old: '"+oldExps[k]+"'\n"+
														   //"expressions are equivalent New: '"+newExps[k]+"'");
									}
								}
							}
							//
							// equation was not strictly "equal" but passed all tests, replace with old equation and move on
							//
							if (bFoundDifference){
								((MembraneSubDomain)subDomainsNew[i]).replaceJumpCondition(oldJumpCondition);
							}else{
								//
								// couldn't find the smoking gun, just plain bad
								//
								if (!bSilent) System.out.println("couldn't find problem with jumpCondition for "+oldVars[j].getName()+" in compartment "+subDomainsOld[i].getName());
								reasonForDecision.append(UNKNOWN_DIFFERENCE_IN_EQUATION);
								return false;
							}
						}
					}
				}
				//
				// test fast system for subdomain
				//
				FastSystem oldFastSystem = subDomainsOld[i].getFastSystem();
				FastSystem newFastSystem = subDomainsNew[i].getFastSystem();
				if (!Compare.isEqualOrNull(oldFastSystem,newFastSystem)){
					boolean bFoundDifference = false;
					//
					// fastSystems didn't compare exactly, lets try to evaluate some expressions instead
					//
					if (oldFastSystem==null){
						//
						// only one MathDescription had Equation for this Variable.
						//
						reasonForDecision.append(EQUATION_ADDED);
						return false;
					}
					if (newFastSystem==null){
						//
						// only one MathDescription had Equation for this Variable.
						//
						reasonForDecision.append(EQUATION_REMOVED);
						return false;
					}
					Enumeration<Expression> oldFastInvExpEnum = oldFastSystem.getFastInvariantExpressions();
					Enumeration<Expression> newFastInvExpEnum = newFastSystem.getFastInvariantExpressions();
					Expression[] oldFastInvariantExps = (Expression[])BeanUtils.getArray(oldFastInvExpEnum, Expression.class);
					Expression[] newFastInvariantExps = (Expression[])BeanUtils.getArray(newFastInvExpEnum, Expression.class);
					if (oldFastInvariantExps.length != newFastInvariantExps.length){
						reasonForDecision.append(DIFFERENT_NUMBER_OF_EXPRESSIONS);
						return false;
					}
					for (int k = 0; k < oldFastInvariantExps.length; k++){
						if (!oldFastInvariantExps[k].compareEqual(newFastInvariantExps[k])){
							bFoundDifference = true;
							if (!ExpressionUtils.functionallyEquivalent(oldFastInvariantExps[k],newFastInvariantExps[k])){
								//
								// difference couldn't be reconciled
								// ... for fast invariants, it is ok if the two equations are different by a scale factor (e.g. if X+Y is conserved, so is 2*X+2*Y, or 2*(X+Y))
								//
								// estimate proportionality factor (average of 5 evaluations)
								// 
								// ratio = old/new
								//
								// then compare old with ratio*new.
								//
								Expression ratioExp = Expression.mult(oldFastInvariantExps[k], Expression.invert(newFastInvariantExps[k]));
								String[] symbols = ratioExp.getSymbols();
								SimpleSymbolTable symbolTable = new SimpleSymbolTable(symbols);
								double[] values = new double[symbols.length];
								ratioExp.bindExpression(symbolTable);
								Random random = new Random(0);
								double ratioAccum = 0.0;
								final int NUM_TRIALS = 5;
								for (int m = 0; m < NUM_TRIALS; m++){
									for (int j = 0; j < values.length; j++) {
										values[j] = random.nextDouble()+1.0;
									}
									ratioAccum += ratioExp.evaluateVector(values);
								}								
								double estimatedRatio = ratioAccum/NUM_TRIALS;
								Expression scaled_newFastInvariantExp = Expression.mult(new Expression(estimatedRatio),newFastInvariantExps[k]);
								System.out.println("MathDescription.compareEquivalent(): comparing "+oldFastInvariantExps[k].infix()+" with "+scaled_newFastInvariantExp.infix());
								if (!ExpressionUtils.functionallyEquivalent(oldFastInvariantExps[k], scaled_newFastInvariantExp)){
									if (!bSilent) System.out.println("fast invariant expressions are different Old: '"+oldFastInvariantExps[k]+"'\n"+
													   "fast invariant expressions are different New: '"+newFastInvariantExps[k]+"'");
									reasonForDecision.append(FASTINVARIANT_EXPRESSION_IS_DIFFERENT);
									return false;
								}
								if (!bSilent) System.out.println("fast invariant expressions are proportional Old: '"+oldFastInvariantExps[k]+"'\n"+
								   "fast invariant expressions are proportional New: '"+newFastInvariantExps[k]+"'");
							}else{
								//if (!bSilent) System.out.println("expressions are equivalent Old: '"+oldExps[k]+"'\n"+
												   //"expressions are equivalent New: '"+newExps[k]+"'");
							}
						}
					}
					Enumeration<Expression> oldFastRateExpEnum = oldFastSystem.getFastRateExpressions();
					Enumeration<Expression> newFastRateExpEnum = newFastSystem.getFastRateExpressions();
					Expression[] oldFastRateExps = (Expression[])BeanUtils.getArray(oldFastRateExpEnum, Expression.class);
					Expression[] newFastRateExps = (Expression[])BeanUtils.getArray(newFastRateExpEnum, Expression.class);
					if (oldFastRateExps.length != newFastRateExps.length){
						reasonForDecision.append(DIFFERENT_NUMBER_OF_EXPRESSIONS);
						return false;
					}
					for (int k = 0; k < oldFastRateExps.length; k++){
						if (!oldFastRateExps[k].compareEqual(newFastRateExps[k])){
							bFoundDifference = true;
							if (!ExpressionUtils.functionallyEquivalent(oldFastRateExps[k],newFastRateExps[k])){
								//
								// difference couldn't be reconciled
								//
								if (!bSilent) System.out.println("fast rate expressions are different Old: '"+oldFastRateExps[k]+"'\n"+
												   "fast rate expressions are different New: '"+newFastRateExps[k]+"'");
								reasonForDecision.append(FASTRATE_EXPRESSION_IS_DIFFERENT);
								return false;
							}else{
								//if (!bSilent) System.out.println("expressions are equivalent Old: '"+oldExps[k]+"'\n"+
												   //"expressions are equivalent New: '"+newExps[k]+"'");
							}
						}
					}
					//
					// equation was not strictly "equal" but passed all tests, replace with old equation and move on
					//
					if (bFoundDifference){
						subDomainsNew[i].setFastSystem(oldFastSystem);
					}else{
						//
						// couldn't find the smoking gun, just plain bad
						//
						if (!bSilent) System.out.println("couldn't find problem with FastSystem for compartment "+subDomainsOld[i].getName());
						reasonForDecision.append(UNKNOWN_DIFFERENCE_IN_EQUATION);
						return false;
					}
				}
				
				List<ParticleJumpProcess> oldPjpList = subDomainsOld[i].getParticleJumpProcesses();
				List<ParticleJumpProcess> newPjpList = subDomainsNew[i].getParticleJumpProcesses();
				if (oldPjpList.size() != newPjpList.size()) {
					return false;
				}
				for (ParticleJumpProcess oldPjp : oldPjpList) {
					boolean bEqual = false;
					for (ParticleJumpProcess newPjp : newPjpList) {
						if (oldPjp.getName().equals(newPjp.getName())) {
							if (oldPjp.compareEqual(newPjp)) {
								bEqual = true;
							}
							break;
						}
					}
					if (!bEqual) {
						return false;
					}
				}
			}

			//
			// after repairing aspects of MathDescription, now see if same
			//
			if (oldMathDesc.compareInvariantAttributes(newMathDesc)){
				reasonForDecision.append(MATHS_ARE_NUMERICALLY_EQUIVALENT);
				return true;
			}else{
			    //if (!bSilent) System.out.println("------UNKNOWN DIFFERENCE IN MATH----------------------");
				//if (!bSilent) System.out.println("------old flattened MathDescription:\n"+oldMathDesc.getVCML_database());
				//if (!bSilent) System.out.println("------new flattened MathDescription:\n"+newMathDesc.getVCML_database());
				reasonForDecision.append(UNKNOWN_DIFFERENCE_IN_MATH);
				return false;
			}
		}
	}catch (Throwable e){
		e.printStackTrace(System.out);
		reasonForDecision.append(FAILURE_UNKNOWN);
		return false;
	}
}


/**
 * This method was created in VisualAge.
 * @return boolean
 * @param mathDesc cbit.vcell.math.MathDescription
 */
public boolean compareInvariantAttributes(MathDescription newMathDesc) {
	//
	// making cannonical math descriptions is expensive, so the idea is to quickly identify those differences that are invariant of any cannonical form.
	//

	
	//
	// compare subdomain names and types only SubDomain.compareEqual() would recursively compare all of the equations.
	//
	if (subDomainList.size()!=newMathDesc.subDomainList.size()){
		System.out.println("DIFFERENT INVARIANTS: number of SubDomains different");
		return false;
	}
	for (int i = 0; i < subDomainList.size(); i++){
		SubDomain subDomain = subDomainList.elementAt(i);
		SubDomain otherSubDomain = newMathDesc.getSubDomain(subDomain.getName());
		if (otherSubDomain==null || !otherSubDomain.getClass().equals(subDomain.getClass())){
			System.out.println("DIFFERENT INVARIANTS: SubDomains different");
			return false;
		}		
	}
	
	//
	// compare state variables (make sure number of state variables are equal).
	//
	HashSet<String> thisStateVarHash = getStateVariableNames();
	HashSet<String> otherStateVarHash = newMathDesc.getStateVariableNames();
	if (thisStateVarHash.size() != otherStateVarHash.size()){
		System.out.println("DIFFERENT INVARIANTS: number of StateVars different");
		return false;
	}
	//
	// disregard vars present in both sets (for efficiency).
	//
	HashSet<String> intersectionStateVarHash = new HashSet<String>(thisStateVarHash);
	intersectionStateVarHash.retainAll(otherStateVarHash);
	//
	// if intersection of state variables is smaller than entire set, 
	// then must make sure that each missing state variable exists as a Function (dependent variable).
	//
	if (intersectionStateVarHash.size()!=thisStateVarHash.size()){
		// trim both sets to remove intersection
		thisStateVarHash.removeAll(intersectionStateVarHash);
		otherStateVarHash.removeAll(intersectionStateVarHash);
		//
		// check this MathDescription's (extra) state variables are present in other MathDescription (as Function).
		//
		Iterator<String> iter = thisStateVarHash.iterator();
		while (iter.hasNext()){
			String varName = iter.next();
			Variable var = newMathDesc.getVariable(varName);
			if (var==null || !(var instanceof Function)){
				System.out.println("DIFFERENT INVARIANTS: StateVar not found as Function");
				return false;
			}
		}
		//
		// check other MathDescription's (extra) state variables are present in this MathDescription (as Function).
		//
		iter = otherStateVarHash.iterator();
		while (iter.hasNext()){
			String varName = iter.next();
			Variable var = getVariable(varName);
			if (var==null || !(var instanceof Function)){
				System.out.println("DIFFERENT INVARIANTS: StateVar not found as Function");
				return false;
			}
		}
	}
	
	//
	// compare geometry
	//
	if (!Compare.isEqualOrNull(
			(geometry != null?geometry.getGeometrySpec():null),
			(newMathDesc.geometry != null?newMathDesc.geometry.getGeometrySpec():null))) {
		System.out.println("DIFFERENT INVARIANTS: GeometrySpec different");
		return false;
	}

	return true;
}


/**
 * Insert the method's description here.
 * Creation date: (10/9/2002 10:54:06 PM)
 * @return cbit.vcell.math.MathDescription
 */
public static MathDescription createCanonicalMathDescription(MathDescription originalMathDescription) throws MathException, ExpressionException, MappingException {
	//
	// clone current mathdescription
	//
	MathDescription newMath = new MathDescription(originalMathDescription);

	newMath.makeCanonical();

	return newMath;
}


/**
 * Insert the method's description here.
 * Creation date: (10/9/2002 10:54:06 PM)
 * @return cbit.vcell.math.MathDescription
 */
public static MathDescription createMathWithExpandedEquations(MathDescription originalMathDescription, HashSet<String> varNamesToKeep) throws MathException, ExpressionException, MappingException {
	//
	// clone current mathdescription
	//
	MathDescription newMath = new MathDescription(originalMathDescription);

	//
	// for any dependent variables in the "varNamesToKeep" list, create appropriate Variable/Equation
	//
	// this assumes that the dependent 'Function' is a linear combination of existing state variables
	//  e.g. Function depVar = K0 + K1*indepVar1 + K2*indepVar2 + ... + Kn*indepVarN
	// if it doesn't fit this form, then math's are not equivalent.
	//
	HashSet<String> stateVarSet = newMath.getStateVariableNames();
	for (int i = 0; i < newMath.variableList.size(); i++){
		Variable tmp_var = newMath.variableList.elementAt(i);
		if (varNamesToKeep.contains(tmp_var.getName()) && tmp_var instanceof Function){
			Function function = (Function)tmp_var;
			//
			// get list of symbols that are state variables
			//
			Vector<Variable> indepVarList = new Vector<Variable>();         // holds the "indepVar's"
			Vector<Expression> coefficientList = new Vector<Expression>();      // holds the "K's"
			Expression exp = function.getExpression();
			exp.bindExpression(null);
			Expression K0 = new Expression(exp);
			K0.bindExpression(null);
			String symbols[] = exp.getSymbols();
			for (int j = 0; j < symbols.length; j++){
				if (stateVarSet.contains(symbols[j])){
					//
					// store the independent variable (indepVar_i)
					//
					indepVarList.add(newMath.getVariable(symbols[j]));
					Expression differential = exp.differentiate(symbols[j]);
					differential = differential.flatten();
					//
					// store the coefficient (K_i)
					//
					coefficientList.add(differential);
					//
					// remove this term from the "constant" term (K0)
					// (e.g. for expression "K0 + K1*V1 + ... + Ki*Vi + ... + Kn*Vn", Vi set to 0.0 and flattened)
					// after each term is removed, only K0 is left
					//
					K0.substituteInPlace(new Expression(symbols[j]),new Expression(0.0));
					K0 = K0.flatten();
				}
			}
			//
			// either all independent vars should be Volume, all should be Membrane, or all should be Filament 
			//
			int countVolumeVars = 0;
			int countMembraneVars = 0;
			int countFilamentVars = 0;
			for (int j = 0; j < indepVarList.size(); j++){
				if (indepVarList.elementAt(j) instanceof VolVariable){
					countVolumeVars++;
				}else if (indepVarList.elementAt(j) instanceof MemVariable){
					countMembraneVars++;
				}else if (indepVarList.elementAt(j) instanceof FilamentVariable){
					countFilamentVars++;
				}else{
					throw new RuntimeException("create canonicalMath cannot handle dependent vars of type '"+indepVarList.elementAt(j).getClass().getName()+"'");
				}
			}
			//
			// case: Volume Variable
			// create VolVariable
			// for each CompartmentSubDomain, create OdeEquation
			// remove Function
			//
			if (countVolumeVars == indepVarList.size()){
				VolVariable volVariable = new VolVariable(function.getName(),function.getDomain());
				newMath.variableList.remove(function);
				newMath.variableList.add(volVariable);
				newMath.variableHashTable.remove(function.getName());
				newMath.variableHashTable.put(volVariable.getName(), volVariable);
				for (int j = 0; j < newMath.subDomainList.size(); j++){
					SubDomain subDomain = newMath.subDomainList.elementAt(j);
					if (subDomain instanceof CompartmentSubDomain){
						//
						// add an ODE where 
						//    initial value = K0 + Sum(coefficient_i*Var_i.init)
						//    rate value = Sum(coefficient_i*Var_i.rate)
						//
						Expression initExp = new Expression(K0);
						Expression rateExp = new Expression(0.0);
						for (int k = 0; k < indepVarList.size(); k++){
							Variable indepVar = indepVarList.elementAt(k);
							Equation indepVarEqu = subDomain.getEquation(indepVar);
							Expression coefficient = coefficientList.elementAt(k);
							initExp = Expression.add(initExp,Expression.mult(new Expression(coefficient),new Expression(indepVarEqu.getInitialExpression())));
							rateExp = Expression.add(rateExp,Expression.mult(new Expression(coefficient),new Expression(indepVarEqu.getRateExpression())));
						}
						if (newMath.getVariable(function.getName()+"_init")!=null){
							initExp = new Expression(function.getName()+"_init");
						}
						OdeEquation odeEquation = new OdeEquation(volVariable, initExp.flatten(), rateExp.flatten());
						subDomain.addEquation(odeEquation);
					}
				}
			//
			// case: Membrane Variable
			//
			}else if (countMembraneVars == indepVarList.size()){
				MemVariable memVariable = new MemVariable(function.getName(),function.getDomain());
				newMath.variableList.remove(function);
				newMath.variableList.add(memVariable);
				newMath.variableHashTable.remove(function.getName());
				newMath.variableHashTable.put(memVariable.getName(), memVariable);				
				for (int j = 0; j < newMath.subDomainList.size(); j++){
					SubDomain subDomain = newMath.subDomainList.elementAt(j);
					if (subDomain instanceof MembraneSubDomain){
						//
						// add an ODE where 
						//    initial value = K0 + Sum(coefficient_i*Var_i.init)
						//    rate value = Sum(coefficient_i*Var_i.rate)
						//
						Expression initExp = new Expression(K0);
						Expression rateExp = new Expression(0.0);
						for (int k = 0; k < indepVarList.size(); k++){
							Variable indepVar = indepVarList.elementAt(k);
							Equation indepVarEqu = subDomain.getEquation(indepVar);
							Expression coefficient = coefficientList.elementAt(k);
							initExp = Expression.add(initExp,Expression.mult(new Expression(coefficient),new Expression(indepVarEqu.getInitialExpression())));
							rateExp = Expression.add(rateExp,Expression.mult(new Expression(coefficient),new Expression(indepVarEqu.getRateExpression())));
						}
						if (newMath.getVariable(function.getName()+"_init")!=null){
							initExp = new Expression(function.getName()+"_init");
						}
						OdeEquation odeEquation = new OdeEquation(memVariable, initExp.flatten(), rateExp.flatten());
						subDomain.addEquation(odeEquation);
					}
				}
			//
			// case: Filament Variable
			//
			}else if (countFilamentVars == indepVarList.size()){
				throw new RuntimeException("create canonicalMath cannot handle function of variables of type 'FilamentVariable'");
			//
			//
			//
			}else{
				throw new RuntimeException("create canonicalMath cannot handle mixture of dependent vars types");
			}
		}	
	}
	
	return newMath;
}

/**
 * The firePropertyChange method was generated to support the propertyChange field.
 */
public void firePropertyChange(java.lang.String propertyName, java.lang.Object oldValue, java.lang.Object newValue) {
	getPropertyChange().firePropertyChange(propertyName, oldValue, newValue);
}

/**
 * Method to support listener events.
 */
protected void fireStateChanged() {
	if (aChangeListener != null) {
		ChangeEvent e = new ChangeEvent(this);
		Enumeration<ChangeListener> en = aChangeListener.elements();
		while (en.hasMoreElements()) {
			ChangeListener listener = en.nextElement();
			listener.stateChanged(e);
		}
	}
}

/**
 * The fireVetoableChange method was generated to support the vetoPropertyChange field.
 */
public void fireVetoableChange(java.lang.String propertyName, java.lang.Object oldValue, java.lang.Object newValue) throws java.beans.PropertyVetoException {
	getVetoPropertyChange().fireVetoableChange(propertyName, oldValue, newValue);
}

/**
 * This method was created by a SmartGuide.
 * @param tokens java.util.StringTokenizer
 * @exception java.lang.Exception The exception description.
 */
public static MathDescription fromEditor(MathDescription oldMathDesc, String vcml) throws MathException, java.beans.PropertyVetoException {
	
	CommentStringTokenizer tokens = new CommentStringTokenizer(vcml);
	MathDescription mathDesc = new MathDescription(oldMathDesc.getVersion());
	mathDesc.clearAll();
	mathDesc.setGeometry0(oldMathDesc.getGeometry());
	mathDesc.read_database(tokens);

	//
	// compute warning string (if necessary)
	//
	if (!mathDesc.isValid()){
		System.out.println("Math is invalid, warning = '"+mathDesc.getWarning()+"'");
	}
	
	return mathDesc;
}


/**
 * This method was created by a SmartGuide.
 * @return cbit.vcell.math.SubDomain
 * @param handle int
 */
public CompartmentSubDomain getCompartmentSubDomain(String name) {
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()){
		SubDomain subDomain = enum1.nextElement();
		if (subDomain instanceof CompartmentSubDomain){
			CompartmentSubDomain compartment = (CompartmentSubDomain)subDomain;
			if (compartment.getName().equals(name)){
				return compartment;
			}
		}	
	}
	return null;		
}


/**
 * Insert the method's description here.
 * Creation date: (8/21/00 1:14:56 PM)
 * @return java.util.Enumeration
 */
public Enumeration<Constant> getConstants() {
	return new Enumeration<Constant>() {
	    int count = 0;

	    public boolean hasMoreElements() {
		    for (int i=count;i<variableList.size();i++){
			    if (variableList.elementAt(i) instanceof Constant){
				    return true;
			    }
		    }
		    return false;
	    }

	    public Constant nextElement() {
			synchronized (variableList) {
			    for (int i=count;i<variableList.size();i++){
				    if (variableList.elementAt(i) instanceof Constant){
					    count = i+1;
					    return (Constant)variableList.elementAt(i);
				    }
			    }
			}
			throw new NoSuchElementException("Vector Enumeration (Constant)");
	    }
	};
}


/**
 * Gets the description property (java.lang.String) value.
 * @return The description property value.
 * @see #setDescription
 */
public java.lang.String getDescription() {
	return fieldDescription;
}


/**
 * This method was created by a SmartGuide.
 * @return cbit.vcell.parser.SymbolTableEntry
 * @param id java.lang.String
 * @param qualifier java.lang.String
 * @exception java.lang.Exception The exception description.
 */
public SymbolTableEntry getEntry(String id) throws ExpressionBindingException {
	SymbolTableEntry entry = null;
	
	entry = ReservedMathSymbolEntries.getEntry(id);
	if (entry != null){
		if (entry instanceof SymbolTableFunctionEntry){
			if (entry.equals(MathFunctionDefinitions.Function_regionArea_current)
				|| entry.equals(MathFunctionDefinitions.Function_regionArea_indexed)
				|| entry.equals(MathFunctionDefinitions.Function_regionVolume_current)
				|| entry.equals(MathFunctionDefinitions.Function_regionVolume_indexed)) {
				bRegionSizeFunctionsUsed = true;
			}
		}
		return entry;
	}
	
	entry = getVariable(id);
	if (entry != null){
		return entry;
	}
	
	return null;
}

private Hashtable<FieldFunctionArguments, Vector<Expression>> collectFieldFuncAndExpressions() throws MathException, ExpressionException {
	// make sure each field only added once
	Hashtable<FieldFunctionArguments, Vector<Expression>> fieldFuncArgsExpHash =
		new Hashtable<FieldFunctionArguments, Vector<Expression>>();
	Enumeration<SubDomain> enum1 = getSubDomains();
	
	for(int i=0;i<variableList.size();i+=1){
		Variable variable = variableList.elementAt(i);
		if(variable instanceof Function){
			Function function = (Function)variable;
			FieldUtilities.addFieldFuncArgsAndExpToCollection(fieldFuncArgsExpHash,function.getExpression());
		}
	}
	// go through each subdomain
	while (enum1.hasMoreElements()){
		SubDomain subDomain = enum1.nextElement();
		// go through each equation
		Enumeration<Equation> enum_equ = subDomain.getEquations();
		while (enum_equ.hasMoreElements()){
			Equation equation = (Equation)enum_equ.nextElement();
			Vector<Expression> exs = equation.getExpressions(this);

			// go through each expresson
			for (int i = 0; i < exs.size(); i ++) {
				Expression exp = (Expression)exs.get(i);
				FieldUtilities.addFieldFuncArgsAndExpToCollection(fieldFuncArgsExpHash,exp);
			}
		}
		// go through each Fast System
		FastSystem fastSystem = subDomain.getFastSystem();
		if(fastSystem != null){
			Expression[] fsExprArr = fastSystem.getExpressions();
			for (int i = 0; i < fsExprArr.length; i ++) {
				FieldUtilities.addFieldFuncArgsAndExpToCollection(fieldFuncArgsExpHash,fsExprArr[i]);
			}
		}
		// go through each Jump Process
		for (JumpProcess jumpProcess : subDomain.getJumpProcesses()){
			Expression[] jpExprArr = jumpProcess.getExpressions();
			for (int i = 0; i < jpExprArr.length; i ++) {
				FieldUtilities.addFieldFuncArgsAndExpToCollection(fieldFuncArgsExpHash,jpExprArr[i]);
			}
		}
		// go through VarInitConditions
		for (VarIniCondition varInitCond : subDomain.getVarIniConditions()){
			Expression[] vicExprArr =
				new Expression[] {varInitCond.getIniVal(),varInitCond.getVar().getExpression()};
			for (int i = 0; i < vicExprArr.length; i ++) {
				FieldUtilities.addFieldFuncArgsAndExpToCollection(fieldFuncArgsExpHash,vicExprArr[i]);
			}
		}
	}
	
	return fieldFuncArgsExpHash;
}

public void substituteFieldFuncNames(Hashtable<String, ExternalDataIdentifier> oldFieldFuncArgsNameNewID) throws MathException, ExpressionException{
	FieldUtilities.substituteFieldFuncNames(
			oldFieldFuncArgsNameNewID, collectFieldFuncAndExpressions());
}

public FieldFunctionArguments[] getFieldFunctionArguments() throws MathException, ExpressionException {
	return collectFieldFuncAndExpressions().keySet().toArray(new FieldFunctionArguments[0]);
}


/**
 * Insert the method's description here.
 * Creation date: (8/21/00 1:14:56 PM)
 * @return java.util.Enumeration
 */
public Enumeration<FilamentVariable> getFilamentVariables() {
	return new Enumeration<FilamentVariable>() {
	    int count = 0;

	    public boolean hasMoreElements() {
		    for (int i=count;i<variableList.size();i++){
			    if (variableList.elementAt(i) instanceof FilamentVariable){
				    return true;
			    }
		    }
		    return false;
	    }

	    public FilamentVariable nextElement() {
			synchronized (variableList) {
			    for (int i=count;i<variableList.size();i++){
				    if (variableList.elementAt(i) instanceof FilamentVariable){
					    count = i+1;
					    return (FilamentVariable)variableList.elementAt(i);
				    }
			    }
			}
			throw new NoSuchElementException("Vector Enumeration (FilamentVariable)");
	    }
	};
}


/**
 * Insert the method's description here.
 * Creation date: (10/9/2002 10:54:06 PM)
 * @return cbit.vcell.math.MathDescription
 */
public static Function[] getFlattenedFunctions(MathDescription originalMathDescription, String functionNames[]) throws MathException, ExpressionException, MappingException {
	//
	// clone current mathdescription
	//
	MathDescription newMath = new MathDescription(originalMathDescription);

	//
	// make a "identity" simulation (no overrides), this will help to substitute/flatten expressions.
	//
	Simulation tempSimulation = new Simulation(newMath);
	SimulationSymbolTable simSymbolTable = new SimulationSymbolTable(tempSimulation, 0);
	Function functions[] = new Function[functionNames.length];
	for (int i = 0; i < functionNames.length; i++){
		for (int j = 0; j < originalMathDescription.variableList.size(); j++){
			Variable var = originalMathDescription.variableList.elementAt(j);
			if (var.getName().equals(functionNames[i])){
				if (var instanceof Function){
					Function function = (Function)var;
					Expression exp1 = new Expression(function.getExpression());
					try {
						exp1 = simSymbolTable.substituteFunctions(exp1);
						functions[i] = new Function(function.getName(),exp1.flatten(),function.getDomain());
					} catch (MathException e) {
						e.printStackTrace(System.out);
						throw new RuntimeException("Substitute function failed on function "+function.getName()+" "+e.getMessage());
					}
				}
			}
		}
	}
	return functions;
}


/**
 * Insert the method's description here.
 * Creation date: (8/21/00 1:14:56 PM)
 * @return java.util.Enumeration
 */
public Enumeration<Function> getFunctions() {
	return new Enumeration<Function>() {
	    int count = 0;

	    public boolean hasMoreElements() {
		    for (int i=count;i<variableList.size();i++){
			    if (variableList.elementAt(i) instanceof Function){
				    return true;
			    }
		    }
		    return false;
	    }

	    public Function nextElement() {
			synchronized (variableList) {
			    for (int i=count;i<variableList.size();i++){
				    if (variableList.elementAt(i) instanceof Function){
					    count = i+1;
					    return (Function)variableList.elementAt(i);
				    }
			    }
			}
			throw new NoSuchElementException("Vector Enumeration (Function)");
	    }
	};
}


/**
 * This method was created in VisualAge.
 * @return cbit.vcell.geometry.Geometry
 */
public Geometry getGeometry() {
	return geometry;
}


/**
 * This method was created in VisualAge.
 * @return int
 * @param compartmentSubDomain cbit.vcell.math.CompartmentSubDomain
 * @throws MathException 
 */
public int getHandle(CompartmentSubDomain compartmentSubDomain) throws MathException  {
	SubVolume subVolume = geometry.getGeometrySpec().getSubVolume(compartmentSubDomain.getName());
	if (subVolume ==null){
		throw new MathException("couldn't find a subVolume named "+compartmentSubDomain+" in Geometry");
	}
	return subVolume.getHandle();
}

/**
 * This method was created in VisualAge.
 * @return KeyValue
 */
public KeyValue getKey() {
	return (getVersion()!=null)?getVersion().getVersionKey():null;
}


/**
 * This method was created by a SmartGuide.
 * @return cbit.vcell.math.SubDomain
 * @param name java.lang.String
 * @exception java.lang.Exception The exception description.
 */
public MembraneSubDomain getMembraneSubDomain(CompartmentSubDomain compartment1, CompartmentSubDomain compartment2) {
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()){
		SubDomain subDomain = enum1.nextElement();
		if (subDomain instanceof MembraneSubDomain){
			MembraneSubDomain membraneSubDomain = (MembraneSubDomain)subDomain;
			if ((membraneSubDomain.getInsideCompartment()==compartment1 && membraneSubDomain.getOutsideCompartment()==compartment2) ||
				(membraneSubDomain.getInsideCompartment()==compartment2 && membraneSubDomain.getOutsideCompartment()==compartment1)){
				return membraneSubDomain;
			}
		}	
	}
	return null;
}


/**
 * This method was created by a SmartGuide.
 * @return cbit.vcell.math.SubDomain
 * @param name java.lang.String
 * @exception java.lang.Exception The exception description.
 */
private MembraneSubDomain getMembraneSubDomain(String membraneName) {
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()){
		SubDomain subDomain = enum1.nextElement();
		if (subDomain instanceof MembraneSubDomain){
			MembraneSubDomain membrane = (MembraneSubDomain)subDomain;
			if (membrane.getName().equalsIgnoreCase(membraneName)){
				return membrane;
			}
		}	
	}
	return null;		
}


/**
 * This method was created by a SmartGuide.
 * @return cbit.vcell.math.SubDomain
 * @param name java.lang.String
 * @exception java.lang.Exception The exception description.
 */
public MembraneSubDomain[] getMembraneSubDomains(CompartmentSubDomain compartment) {
	Vector<MembraneSubDomain> membraneSubDomainList = new Vector<MembraneSubDomain>();
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()){
		SubDomain subDomain = enum1.nextElement();
		if (subDomain instanceof MembraneSubDomain){
			MembraneSubDomain membraneSubDomain = (MembraneSubDomain)subDomain;
			if ((membraneSubDomain.getInsideCompartment() == compartment) || (membraneSubDomain.getOutsideCompartment() == compartment)){
				membraneSubDomainList.add(membraneSubDomain);
			}
		}	
	}
	return (MembraneSubDomain[])BeanUtils.getArray(membraneSubDomainList,MembraneSubDomain.class);		
}


/**
 * Gets the name property (java.lang.String) value.
 * @return The name property value.
 * @see #setName
 */
public java.lang.String getName() {
	return fieldName;
}


/**
 * Insert the method's description here.
 * Creation date: (4/22/2001 7:18:42 PM)
 * @return int
 */
public int getNumVariables() {
	return variableList.size();
}


/**
 * Accessor for the propertyChange field.
 */
protected java.beans.PropertyChangeSupport getPropertyChange() {
	if (propertyChange == null) {
		propertyChange = new java.beans.PropertyChangeSupport(this);
	};
	return propertyChange;
}

/**
 * Insert the method's description here.
 * Creation date: (11/24/2004 7:20:17 AM)
 * @return cbit.vcell.math.Variable[]
 */
public HashSet<String> getStateVariableNames() {
	HashSet<String> stateVarNameSet = new HashSet<String>();
	for (int i = 0; i < variableList.size(); i++){
		Variable var = variableList.elementAt(i);
		if (var instanceof VolVariable || var instanceof MemVariable || var instanceof FilamentVariable ||
			var instanceof VolumeRegionVariable || var instanceof MembraneRegionVariable || var instanceof FilamentRegionVariable){
			stateVarNameSet.add(var.getName());
		}
	}
	return stateVarNameSet;
}


/**
 * This method was created by a SmartGuide.
 * @return cbit.vcell.math.SubDomain
 * @param name java.lang.String
 * @exception java.lang.Exception The exception description.
 */
public SubDomain getSubDomain(String name) {
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()){
		SubDomain subDomain = enum1.nextElement();
		if (subDomain.getName().equals(name)){
			return subDomain;
		}	
	}
	return null;		
}


/**
 * This method was created by a SmartGuide.
 * @return java.util.Enumeration
 */
public Enumeration<SubDomain> getSubDomains() {
	return subDomainList.elements();
}


/**
 * This method was created by a SmartGuide.
 * @return cbit.vcell.math.Variable
 * @param name java.lang.String
 */
public Variable getVariable(String name) {
	return variableHashTable.get(name);	
}


/**
 * This method was created by a SmartGuide.
 * @return java.util.Enumeration
 */
public Enumeration<Variable> getVariables() {
	return variableList.elements();
}

public Iterator<Event> getEvents() {
	return eventList.iterator();
}

public int getNumEvents() {
	return eventList.size();
}

/**
 * Insert the method's description here.
 * Creation date: (11/29/00 12:39:15 PM)
 * @return java.lang.String
 */
public String getVCML() throws MathException {
	return getVCML_database();
}


/**
 * This method was created by a SmartGuide.
 * @return java.lang.String
 */
public String getVCML_database() throws MathException {
	//
	// regular VCML exception, no name, and no geometry
	//
	StringBuffer buffer = new StringBuffer();
//	buffer.append(VCML.MathDescription+" "+version.getName()+" {\n");
	buffer.append(VCML.MathDescription+" {\n");
	buffer.append("\n");
	boolean bSpaceNeeded = false;
	Enumeration<Variable> enum1 = getVariables();
	
	// ParameterVariable
	while (enum1.hasMoreElements()){
		Variable var = enum1.nextElement();
		if (var instanceof ParameterVariable){
			buffer.append(var.getVCML()+"\n");
			bSpaceNeeded = true;
		}
	}
	if (bSpaceNeeded){
		buffer.append("\n");
		bSpaceNeeded = false;
	}
	
	// Constant
	enum1 = getVariables();
	while (enum1.hasMoreElements()){
		Variable var = enum1.nextElement();
		if (var instanceof Constant){
			buffer.append(var.getVCML()+"\n");
			bSpaceNeeded = true;
		}
	}
	if (bSpaceNeeded){
		buffer.append("\n");
		bSpaceNeeded = false;
	}
	
	// VolVariable
	enum1 = getVariables();
	while (enum1.hasMoreElements()){
		Variable var = enum1.nextElement();
		if (var instanceof VolVariable){
			buffer.append(var.getVCML()+"\n");
			bSpaceNeeded = true;
		}
	}		
	if (bSpaceNeeded){
		buffer.append("\n");
		bSpaceNeeded = false;
	}
	
	// MemVariable
	enum1 = getVariables();
	while (enum1.hasMoreElements()){
		Variable var = enum1.nextElement();
		if (var instanceof MemVariable){
			buffer.append(var.getVCML()+"\n");
			bSpaceNeeded = true;
		}
	}		
	if (bSpaceNeeded){
		buffer.append("\n");
		bSpaceNeeded = false;
	}
	
	// FilamentVariable
	enum1 = getVariables();
	while (enum1.hasMoreElements()){
		Variable var = enum1.nextElement();
		if (var instanceof FilamentVariable){
			buffer.append(var.getVCML()+"\n");
			bSpaceNeeded = true;
		}
	}		
	if (bSpaceNeeded){
		buffer.append("\n");
		bSpaceNeeded = false;
	}
	
	// VolumeRegionVariable
	enum1 = getVariables();
	while (enum1.hasMoreElements()){
		Variable var = enum1.nextElement();
		if (var instanceof VolumeRegionVariable){
			buffer.append(var.getVCML()+"\n");
			bSpaceNeeded = true;
		}
	}		
	if (bSpaceNeeded){
		buffer.append("\n");
		bSpaceNeeded = false;
	}
	
	// MembraneRegionVariable
	enum1 = getVariables();
	while (enum1.hasMoreElements()){
		Variable var = enum1.nextElement();
		if (var instanceof MembraneRegionVariable){
			buffer.append(var.getVCML()+"\n");
			bSpaceNeeded = true;
		}
	}		
	if (bSpaceNeeded){
		buffer.append("\n");
		bSpaceNeeded = false;
	}
	
	// FilamentRegionVariable
	enum1 = getVariables();
	while (enum1.hasMoreElements()){
		Variable var = enum1.nextElement();
		if (var instanceof FilamentRegionVariable){
			buffer.append(var.getVCML()+"\n");
			bSpaceNeeded = true;
		}
	}		
	if (bSpaceNeeded){
		buffer.append("\n");
		bSpaceNeeded = false;
	}
	
	// StochVolVariable
	enum1 = getVariables();
	while (enum1.hasMoreElements()){
		Variable var = enum1.nextElement();
		if (var instanceof StochVolVariable)
		{
			buffer.append(var.getVCML());
			bSpaceNeeded = true;
		}
	}
	if (bSpaceNeeded){
		buffer.append("\n");
		bSpaceNeeded = false;
	}
	// VolumeParticleVariable
	enum1 = getVariables();
	while (enum1.hasMoreElements()){
		Variable var = enum1.nextElement();
		if (var instanceof VolumeParticleVariable)
		{
			buffer.append(var.getVCML());
			bSpaceNeeded = true;
		}
	}
	if (bSpaceNeeded){
		buffer.append("\n");
		bSpaceNeeded = false;
	}
	
	// MembraneParticleVariable
	enum1 = getVariables();
	while (enum1.hasMoreElements()){
		Variable var = enum1.nextElement();
		if (var instanceof MembraneParticleVariable)
		{
			buffer.append(var.getVCML());
			bSpaceNeeded = true;
		}
	}
	if (bSpaceNeeded){
		buffer.append("\n");
		bSpaceNeeded = false;
	}
	
	// Function
	enum1 = getVariables();
	while (enum1.hasMoreElements()){
		Variable var = enum1.nextElement();
		if (var instanceof Function){
			buffer.append(var.getVCML()+"\n");
			bSpaceNeeded = true;
		}
	}		
	if (bSpaceNeeded){
		buffer.append("\n");
		bSpaceNeeded = false;
	}
	
	enum1 = getVariables();
	while (enum1.hasMoreElements()){
		Variable var = enum1.nextElement();
		if (var instanceof RandomVariable){
			buffer.append(var.getVCML()+"\n");
			bSpaceNeeded = true;
		}
	}		
	if (bSpaceNeeded){
		buffer.append("\n");
		bSpaceNeeded = false;
	}	
	
	// Event
	for (Event event : eventList) {
		buffer.append(event.getVCML() + "\n");
	}
	if (eventList.size() > 0) {
		buffer.append("\n");
	}
	
	Enumeration<SubDomain> enum2 = getSubDomains();
	while (enum2.hasMoreElements()){
		SubDomain subDomain = enum2.nextElement();
		buffer.append(subDomain.getVCML(getGeometry().getDimension())+"\n");
	}
	buffer.append("}\n");
	return buffer.toString();		
}

/**
 * This method was created in VisualAge.
 * @return cbit.sql.Version
 */
public Version getVersion() {
	return version;
}


/**
 * Accessor for the vetoPropertyChange field.
 */
protected java.beans.VetoableChangeSupport getVetoPropertyChange() {
	if (vetoPropertyChange == null) {
		vetoPropertyChange = new java.beans.VetoableChangeSupport(this);
	};
	return vetoPropertyChange;
}


/**
 * Gets the warning property (java.lang.String) value.
 * @return The warning property value.
 * @see #setWarning
 */
public java.lang.String getWarning() {
	return fieldWarning;
}


/**
 * This method was created in VisualAge.
 * @return boolean
 */
public boolean hasFastSystems() {

	//
	// Check each subDomain for FastSystems
	//
	for (int i = 0; i < subDomainList.size(); i++) {
		SubDomain subDomain = subDomainList.elementAt(i);
		if (subDomain.getFastSystem() != null) {
			return true;
		}
	}
	return false;
}


public boolean hasPeriodicBoundaryCondition() {

	//
	// Check each subDomain for Periodic Boundary Condition
	//
	for (int i = 0; i < subDomainList.size(); i++) {
		SubDomain subDomain = subDomainList.elementAt(i);
		BoundaryConditionType[] bctypes = new BoundaryConditionType[0];
		if (subDomain instanceof CompartmentSubDomain) {
			CompartmentSubDomain dom = (CompartmentSubDomain)subDomain;
			bctypes = new BoundaryConditionType[] {
					dom.getBoundaryConditionXm(),
					dom.getBoundaryConditionXp(),
					dom.getBoundaryConditionYm(),
					dom.getBoundaryConditionYp(),
					dom.getBoundaryConditionZm(),
					dom.getBoundaryConditionZp()
			};
		} else if (subDomain instanceof MembraneSubDomain) {
			MembraneSubDomain dom = (MembraneSubDomain)subDomain;
			bctypes = new BoundaryConditionType[] {
					dom.getBoundaryConditionXm(),
					dom.getBoundaryConditionXp(),
					dom.getBoundaryConditionYm(),
					dom.getBoundaryConditionYp(),
					dom.getBoundaryConditionZm(),
					dom.getBoundaryConditionZp()
			};
		}
		for (BoundaryConditionType bct : bctypes) {
			if (bct.isPERIODIC()) {
				return true;
			}
		}
	}
	return false;
}

/**
 * The hasListeners method was generated to support the propertyChange field.
 */
public synchronized boolean hasListeners(java.lang.String propertyName) {
	return getPropertyChange().hasListeners(propertyName);
}


/**
 * This method was created by a SmartGuide.
 * @return boolean
 * @param volVariable cbit.vcell.math.VolVariable
 */
public boolean hasVelocity(VolVariable volVariable) {
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()){
		SubDomain subDomain = enum1.nextElement();
		if (subDomain instanceof CompartmentSubDomain){
			Equation equation = subDomain.getEquation(volVariable);
			if (equation instanceof PdeEquation){
				PdeEquation pdeEqn = (PdeEquation)equation;
				if ((pdeEqn.getVelocityX() != null && !pdeEqn.getVelocityX().isZero()) 
					|| (pdeEqn.getVelocityY() != null && !pdeEqn.getVelocityY().isZero())
					|| (pdeEqn.getVelocityZ() != null && !pdeEqn.getVelocityZ().isZero())) {
					return true;
				}
			}	
		}
	}
	return false;		
}

public boolean hasVelocity() {
	for (Variable var : variableList) {
		if (var instanceof VolVariable) {
			if (hasVelocity((VolVariable)var)) {
				return true;
			}
		}
	}
	return false;		
}

/**
 * This method was created by a SmartGuide.
 * @return boolean
 * @param volVariable cbit.vcell.math.VolVariable
 */
public boolean isPDE(MemVariable memVariable) {
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()){
		SubDomain subDomain = enum1.nextElement();
		if (subDomain instanceof MembraneSubDomain){
			Equation equation = subDomain.getEquation(memVariable);
			if (equation instanceof PdeEquation){
				return true;
			}	
		}
	}
	return false;		
}


/**
 * This method was created by a SmartGuide.
 * @return boolean
 * @param volVariable cbit.vcell.math.VolVariable
 */
public boolean isPDE(VolVariable volVariable) {
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()){
		SubDomain subDomain = enum1.nextElement();
		if (subDomain instanceof CompartmentSubDomain){
			Equation equation = subDomain.getEquation(volVariable);
			if (equation instanceof PdeEquation){
				return true;
			}	
		}
	}
	return false;		
}

/**
 * This method was created by a SmartGuide.
 * @return boolean
 * @param volVariable cbit.vcell.math.VolVariable
 */
public boolean isPdeSteady(VolVariable volVariable) {	
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()){
		SubDomain subDomain = enum1.nextElement();
		if (subDomain instanceof CompartmentSubDomain){
			Equation equation = subDomain.getEquation(volVariable);
			if (equation instanceof PdeEquation){
				if (((PdeEquation)equation).isSteady()) {
					return true;
				}
			}	
		}
	}
	return false;		
}

/**
 * This method was created in VisualAge.
 * @return boolean
 */
public boolean isSpatial() {
	if (getGeometry()==null) {
		return false;
	}
	return (getGeometry().getDimension()>0);
}


public boolean isNonSpatialStoch() {
	if (getGeometry().getDimension() != 0) {
		return false;
	}
	Enumeration<Variable> enum1 = getVariables();
	while (enum1.hasMoreElements()) {
		Variable var = enum1.nextElement();
		if (var instanceof StochVolVariable) {
			return true;
		}
		if (!(var instanceof Constant || var instanceof Function)) {
			return false;
		} 
	}
	return false;	
}

public boolean isSpatialStoch() {
	if (getGeometry().getDimension() == 0) {
		return false;
	}
	Enumeration<Variable> enum1 = getVariables();
	while (enum1.hasMoreElements()) {
		Variable var = enum1.nextElement();
		if (var instanceof ParticleVariable) {
			return true;
		}
		if (!(var instanceof Constant || var instanceof Function)) {
			return false;
		} 
	}
	return false;	
}


/**
 * This method was created in VisualAge.
 * @return boolean
 */
public boolean isValid() {
	setWarning(null);
	if (geometry==null){
		setWarning("no geometry defined");
		return false;
	}
	
	// check Constant are really constants
	for (int i=0;i<variableList.size();i++){
		Variable var = variableList.elementAt(i);
		if (var instanceof Constant){
			try {
				((Constant)var).getExpression().evaluateConstant();
			} catch (Exception ex) {
				ex.printStackTrace(System.out);
				setWarning("Constant '" + var.getName() + "' can't be evaluated to a number, see expression : " + var.getExpression().infix());
				return false;
			}
		}
	}
	
	//
	// count number of variables of each type
	//
	int volVarCount = 0;
	int memVarCount = 0;
	int filVarCount = 0;
	int volRegionVarCount = 0;
	int memRegionVarCount = 0;
	int filRegionVarCount = 0;
	int stochVarCount = 0;
	for (int i=0;i<variableList.size();i++){
		Variable var = variableList.elementAt(i);
		if (var instanceof VolVariable){
			volVarCount++;
		}else if (var instanceof MemVariable){
			memVarCount++;
		}else if (var instanceof FilamentVariable){
			filVarCount++;
		}else if (var instanceof VolumeRegionVariable){
			volRegionVarCount++;
		}else if (var instanceof MembraneRegionVariable){
			memRegionVarCount++;
		}else if (var instanceof FilamentRegionVariable){
			filRegionVarCount++;
		}else if (var instanceof StochVolVariable){
			stochVarCount++;
		}
	}
	//
	// check that all equation rates and initial conditions ... etc can be bound to this MathDescription (e.g. no unresolved identifiers).
	//
	try {
		for (int i = 0; i < subDomainList.size(); i++){
			SubDomain subDomain = subDomainList.elementAt(i);
			Enumeration<Equation> equEnum = subDomain.getEquations();
			while (equEnum.hasMoreElements()){
				Equation equ = equEnum.nextElement();
				equ.checkValid(this,subDomain);
				equ.bind(this);
			}
			FastSystem fastSystem = subDomain.getFastSystem();
			if (fastSystem!=null){
				Enumeration<FastRate> frEnum = fastSystem.getFastRates();
				while (frEnum.hasMoreElements()){
					FastRate fr = frEnum.nextElement();
					fr.bind(this);
				}
				Enumeration<FastInvariant> fiEnum = fastSystem.getFastInvariants();
				while (fiEnum.hasMoreElements()){
					FastInvariant fi = fiEnum.nextElement();
					fi.bind(this);
				}
			}
			for (ParticleProperties pp : subDomain.getParticleProperties()) {
				pp.bind(this);
			}
			for (ParticleJumpProcess pjp : subDomain.getParticleJumpProcesses()) {
				pjp.bind(this);
			}
		}
	}catch (ExpressionBindingException e){
		setWarning("error binding identifier: "+e.getMessage());
		return false;
	}catch (ExpressionException e){
		setWarning(e.getMessage());
		return false;
	}catch (MathException e){
		setWarning(e.getMessage());
		return false;
	}
	//
	// ODE only
	//
	if (geometry.getDimension()==0){
		//
		// Check that only 1 subdomain is defined and that it is a volumeSubdomain
		//
		if (subDomainList.size()!=1){
			setWarning("Compartmental Model requires exactly one "+VCML.CompartmentSubDomain+" object");
			return false;
		}
		if (!(subDomainList.elementAt(0) instanceof CompartmentSubDomain)){
			setWarning("Compartmental Model requires the subdomain be a "+VCML.CompartmentSubDomain+" object");
			return false;
		}
		CompartmentSubDomain subDomain = (CompartmentSubDomain)subDomainList.elementAt(0);
		//distinguish ODE model and stochastic model
		if(isNonSpatialStoch())
		{
			if(stochVarCount == 0)
			{
				setWarning("Compartmental stochastic model requires at least one stochastic volume variable");
				return false;
			}	
			if(subDomain.getJumpProcesses().size() == 0)
			{
				setWarning("Compartmental stochastic model requires at least one jump process");
				return false;
			}
			//check variable initial condition
			for (VarIniCondition varIniCondition : subDomain.getVarIniConditions()) {
				Expression iniExp = varIniCondition.getIniVal();
				try{
					iniExp.bindExpression(this);
				}catch(Exception ex){
					ex.printStackTrace(System.out);
					setWarning(ex.getMessage());
				}				
			}
			//check probability rate
			for (JumpProcess jumpProcess : subDomain.getJumpProcesses()) {
				Expression probExp = jumpProcess.getProbabilityRate();
				try{
					probExp.bindExpression(this);
				}catch(Exception ex){
					ex.printStackTrace(System.out);
					setWarning(ex.getMessage());
				}
			}
		}
		else
		{
			// ODE model
			//
			// Check that all equations are ODEs 
			//
			int odeCount = 0;
			Enumeration<Equation> enum_equ = subDomain.getEquations();
			while (enum_equ.hasMoreElements()){
				Equation equ = enum_equ.nextElement();
				if (equ instanceof OdeEquation){
					odeCount ++;
				} else {
					setWarning("Compartmental model, unexpected equation of type "+VCML.PdeEquation+", must include only "+VCML.OdeEquation+"'s");
					return false;
				}
			}
			if (odeCount==0){
				setWarning("Compartmental model, expecting at least one "+VCML.OdeEquation);
				return false;
			}

			if (volVarCount!=odeCount){
				setWarning("Compartmental model, must declare an "+VCML.OdeEquation+" for each "+VCML.VolumeVariable);
				return false;
			}
			if (memVarCount>0){
				setWarning("Compartmental model, must not declare any "+VCML.MembraneVariable+"'s");
				return false;
			}
			if (filVarCount>0){
				setWarning("Compartmental model, must not declare any "+VCML.FilamentVariable+"'s");
				return false;
			}
			if (volRegionVarCount>0){
				setWarning("Compartmental model, must not declare any "+VCML.VolumeRegionVariable+"'s");
				return false;
			}
			if (memRegionVarCount>0){
				setWarning("Compartmental model, must not declare any "+VCML.MembraneRegionVariable+"'s");
				return false;
			}
			if (filRegionVarCount>0){
				setWarning("Compartmental model, must not declare any "+VCML.FilamentRegionVariable+"'s");
				return false;
			}
		}
	//
	// spatial (PDE and ODE)
	//
	}else{
		//
		// Check that the number of CompartmentSubdomains equals the number of VolumeSubVolumes in the Geometry
		// Check that the number of FilamentSubdomains equals the number of Filaments in the Geometry
		//
		int compartmentCount = 0;
		int membraneCount = 0;
		int filamentCount = 0;
		for (int i=0;i<subDomainList.size();i++){
			SubDomain subDomain = (SubDomain)subDomainList.elementAt(i);
			if (subDomain instanceof CompartmentSubDomain){
				if (geometry.getGeometrySpec().getSubVolume(subDomain.getName()) == null) {
					setWarning("Spatial model, can't find a matching geometry subdomain for math subdomain '" + subDomain.getName() 
							+ "'. Math subdomain names must match geometry subdomain names .");
					return false;
				}
				compartmentCount++;
			}else if (subDomain instanceof MembraneSubDomain){
				membraneCount++;
			}else if (subDomain instanceof FilamentSubDomain){
				filamentCount++;
			}else{
				setWarning("Spatial model, unexpected subdomain type for subdomain "+subDomain.getName());
				return false;
			}
		}
		if (geometry.getGeometrySpec().getNumSubVolumes()!=compartmentCount){
			setWarning("Spatial model, there are "+geometry.getGeometrySpec().getNumSubVolumes()+" subdomains in geometry, but "+compartmentCount+" "+VCML.CompartmentSubDomain+"s in math description. They must match.");
			return false;
		}
		if (geometry.getGeometrySpec().getFilamentGroup().getFilamentCount()!=filamentCount){
			setWarning("Spatial model, there are "+geometry.getGeometrySpec().getFilamentGroup().getFilamentCount()+" filaments in geometry, but "+filamentCount+" "+VCML.FilamentSubDomain+"'s, must be equal");
			return false;
		}
		if (filamentCount==0 && (filVarCount>0 || filRegionVarCount>0)){
			setWarning("Spatial model, there are no "+VCML.FilamentSubDomain+"s defined, cannot define "+VCML.FilamentVariable+" or "+VCML.FilamentRegionVariable);
		}
		if (membraneCount==0 && (memVarCount>0 || memRegionVarCount>0)){
			setWarning("Spatial model, there are no "+VCML.MembraneSubDomain+"s defined, cannot define "+VCML.MembraneVariable+" or "+VCML.MembraneRegionVariable);
		}
		//
		// Check that there are no duplicate Subdomains and that priorities are unique
		//
		for (int i = 0; i < subDomainList.size(); i++){
			SubDomain subDomain1 = (SubDomain)subDomainList.elementAt(i);
			for (int j = 0; j < subDomainList.size(); j++){
				if (i!=j){
					SubDomain subDomain2 = (SubDomain)subDomainList.elementAt(j);
					if (subDomain1.getName().equals(subDomain2.getName())){
						setWarning("Duplicate subDomains "+subDomain1.getName()+" and "+subDomain2.getName());
						return false;
					}
					if (subDomain1 instanceof MembraneSubDomain && subDomain2 instanceof MembraneSubDomain){
						MembraneSubDomain memSubDomain1 = (MembraneSubDomain)subDomain1;
						MembraneSubDomain memSubDomain2 = (MembraneSubDomain)subDomain2;
						if ((memSubDomain1.getInsideCompartment()==memSubDomain2.getInsideCompartment() && memSubDomain1.getOutsideCompartment()==memSubDomain2.getOutsideCompartment()) ||
							(memSubDomain1.getInsideCompartment()==memSubDomain2.getOutsideCompartment() && memSubDomain1.getOutsideCompartment()==memSubDomain2.getInsideCompartment())){
							setWarning("Duplicate membrane subdomains between compartments "+memSubDomain1.getInsideCompartment().getName()+" and "+memSubDomain1.getOutsideCompartment().getName());
							return false;
						}
					}
					if (subDomain1 instanceof CompartmentSubDomain && subDomain2 instanceof CompartmentSubDomain){
						CompartmentSubDomain compartmentSubDomain1 = (CompartmentSubDomain)subDomain1;
						CompartmentSubDomain compartmentSubDomain2 = (CompartmentSubDomain)subDomain2;
						if (compartmentSubDomain1.getPriority()==compartmentSubDomain2.getPriority()){
							setWarning("CompartmentSubDomain priorities must be unique see '"+compartmentSubDomain1.getName()+"' and '"+compartmentSubDomain2.getName()+"'");
							return false;
						}
					}
				}
			}
			
		}
		// check periodic boundary conditons
		for (int i = 0; i < subDomainList.size(); i++){
			SubDomain subDomain = (SubDomain)subDomainList.elementAt(i);
			if (subDomain instanceof CompartmentSubDomain) {
				CompartmentSubDomain compartmentSubDomain = (CompartmentSubDomain)subDomain;
				BoundaryConditionType bctM = compartmentSubDomain.getBoundaryConditionXm();
				BoundaryConditionType bctP = compartmentSubDomain.getBoundaryConditionXp();
				if (bctM.isPERIODIC() && !bctP.isPERIODIC() || !bctM.isPERIODIC() && bctP.isPERIODIC()) {
					setWarning("Xm and Xp must both have periodic boundary condition");
					return false;
				}
				bctM = compartmentSubDomain.getBoundaryConditionYm();
				bctP = compartmentSubDomain.getBoundaryConditionYp();
				if (bctM.isPERIODIC() && !bctP.isPERIODIC() || !bctM.isPERIODIC() && bctP.isPERIODIC()) {
					setWarning("Ym and Yp must both have periodic boundary condition");
					return false;
				}
				bctM = compartmentSubDomain.getBoundaryConditionZm();
				bctP = compartmentSubDomain.getBoundaryConditionZp();
				if (bctM.isPERIODIC() && !bctP.isPERIODIC() || !bctM.isPERIODIC() && bctP.isPERIODIC()) {
					setWarning("Zm and Zp must both have periodic boundary condition");
					return false;
				}				
			}else if (subDomain instanceof MembraneSubDomain){
				MembraneSubDomain membraneSubDomain = (MembraneSubDomain)subDomain;
				BoundaryConditionType bctM = membraneSubDomain.getBoundaryConditionXm();
				BoundaryConditionType bctP = membraneSubDomain.getBoundaryConditionXp();
				if (bctM.isPERIODIC() && !bctP.isPERIODIC() || !bctM.isPERIODIC() && bctP.isPERIODIC()) {
					setWarning("Xm and Xp must both have periodic boundary condition");
					return false;
				}
				bctM = membraneSubDomain.getBoundaryConditionYm();
				bctP = membraneSubDomain.getBoundaryConditionYp();
				if (bctM.isPERIODIC() && !bctP.isPERIODIC() || !bctM.isPERIODIC() && bctP.isPERIODIC()) {
					setWarning("Ym and Yp must both have periodic boundary condition");
					return false;
				}
				bctM = membraneSubDomain.getBoundaryConditionZm();
				bctP = membraneSubDomain.getBoundaryConditionZp();
				if (bctM.isPERIODIC() && !bctP.isPERIODIC() || !bctM.isPERIODIC() && bctP.isPERIODIC()) {
					setWarning("Zm and Zp must both have periodic boundary condition");
					return false;
				}
			}		
		}
		
		try {
			if (geometry.getGeometrySpec().getDimension() > 0) {
				//
				// Check that there is a MembraneSubdomain for each unique subVolume-subVolume interface in Geometry
				// each ResolvedSurfaceLocation is an instance of a subVolume-subVolume interface (one-to-one with region boundaries).
				//
				GeometricRegion regions[] = geometry.getGeometrySurfaceDescription().getGeometricRegions();
				//if (regions==null){
					//try {
						//geometry.getGeometrySurfaceDescription().updateAll();
						//regions = geometry.getGeometrySurfaceDescription().getGeometricRegions();
					//}catch (Exception e){
						//e.printStackTrace(System.out);
					//}
				//}
				if (regions==null){
					setWarning("unable to get region information from geometry");
					return false;
				}
				for (int i = 0; i < regions.length; i++){
					if (regions[i] instanceof SurfaceGeometricRegion){
						SurfaceGeometricRegion surfaceRegion = (SurfaceGeometricRegion)regions[i];
						CompartmentSubDomain compartment1 = getCompartmentSubDomain(((VolumeGeometricRegion)surfaceRegion.getAdjacentGeometricRegions()[0]).getSubVolume().getName());
						if(compartment1 == null){
							setWarning("Geometry '"+getGeometry().getName()+"' SubDomain name '"+((VolumeGeometricRegion)surfaceRegion.getAdjacentGeometricRegions()[0]).getSubVolume().getName()+"' does not match any "+VCML.CompartmentSubDomain+" name in "+VCML.MathDescription+" -- check spelling/case");
							return false;
						}
						CompartmentSubDomain compartment2 = getCompartmentSubDomain(((VolumeGeometricRegion)surfaceRegion.getAdjacentGeometricRegions()[1]).getSubVolume().getName());
						if(compartment2 == null){
							setWarning("Geometry '"+getGeometry().getName()+"' SubDomain name '"+((VolumeGeometricRegion)surfaceRegion.getAdjacentGeometricRegions()[1]).getSubVolume().getName()+"' does not match any "+VCML.CompartmentSubDomain+" name in "+VCML.MathDescription+" -- check spelling/case");
							return false;
						}
						MembraneSubDomain membraneSubDomain = getMembraneSubDomain(compartment1,compartment2);
						if (membraneSubDomain==null){
							setWarning("There should be a MembraneSubDomain between compartments '"+compartment1.getName()+"' and '"+compartment2.getName()+"'");
							return false;
						}
					}
				}
				//
				// Check that for each MembraneSubdomain there exists an actual surface in the geometry
				//
				for (int i = 0; i < subDomainList.size(); i++){
					if (subDomainList.elementAt(i) instanceof MembraneSubDomain){
						MembraneSubDomain membraneSubDomain = (MembraneSubDomain)subDomainList.elementAt(i);
						boolean bFoundSurfaceInGeometry = false;
						for (int j = 0; j < regions.length; j++){
							if (regions[j] instanceof SurfaceGeometricRegion){
								SurfaceGeometricRegion surfaceRegion = (SurfaceGeometricRegion)regions[j];
								VolumeGeometricRegion volumeRegion1 = (VolumeGeometricRegion)surfaceRegion.getAdjacentGeometricRegions()[0];
								VolumeGeometricRegion volumeRegion2 = (VolumeGeometricRegion)surfaceRegion.getAdjacentGeometricRegions()[1];
								String memInsideName = membraneSubDomain.getInsideCompartment().getName();
								String memOutsideName = membraneSubDomain.getOutsideCompartment().getName();
								if ((memInsideName.equals(volumeRegion1.getSubVolume().getName()) && memOutsideName.equals(volumeRegion2.getSubVolume().getName()))||
									(memInsideName.equals(volumeRegion2.getSubVolume().getName()) && memOutsideName.equals(volumeRegion1.getSubVolume().getName()))){
									bFoundSurfaceInGeometry=true;
									break;
								}
							}
						}
						if (!bFoundSurfaceInGeometry){
							setWarning("MembraneSubDomain inside='"+membraneSubDomain.getInsideCompartment().getName()+"', outside='"+membraneSubDomain.getOutsideCompartment().getName()+"' not in geometry");
							return false;
						}
					}
				}
			}
		//}catch (GeometryException e){
			//e.printStackTrace(System.out);
			//setWarning("error validating MathDescription: "+e.getMessage());
			//return false;
		//}catch (ImageException e){
			//e.printStackTrace(System.out);
			//setWarning("error validating MathDescription: "+e.getMessage());
			//return false;
		//}catch (ExpressionException e){
			//e.printStackTrace(System.out);
			//setWarning("error validating MathDescription: "+e.getMessage());
			//return false;
		}catch (Exception e){
			e.printStackTrace(System.out);
			setWarning("error validating MathDescription: "+e.getMessage());
			return false;
		}
		//
		// Check that all equations for the same VolVariable are the same type (ODE or PDE)
		// ... and that all PDE equations have jump conditions defined on the appropriate membranes
		//
		for (int i=0;i<variableList.size();i++){
			Variable var = variableList.elementAt(i);
			if (var instanceof VolVariable){
				VolVariable volVar = (VolVariable)var;
				
				int pdeRefCount = 0;
				int odeRefCount = 0;
				int steadyPdeCount = 0;
				for (int j=0;j<subDomainList.size();j++){
					SubDomain subDomain = subDomainList.elementAt(j);
					Equation equ = subDomain.getEquation(volVar);
					if (equ instanceof PdeEquation){
						if (((PdeEquation)equ).isSteady()) {
							steadyPdeCount ++;
						} else {
							pdeRefCount++;
						}
						//
						// for each PDE, make sure that a jump condition all membranes that border this compartment
						//
						for (int k = 0; k < subDomainList.size(); k++){
							SubDomain subDomain2 = subDomainList.elementAt(k);
							if (subDomain2 instanceof MembraneSubDomain){
								MembraneSubDomain membraneSubDomain = (MembraneSubDomain)subDomain2;
								if (membraneSubDomain.getInsideCompartment() == subDomain || membraneSubDomain.getOutsideCompartment() == subDomain){
									if (membraneSubDomain.getJumpCondition(volVar)==null){
										setWarning("Spatial Model, PDE for '"+volVar.getName()+"' in '"+subDomain.getName()+"' "+
											       "does not have a jump condition on membrane '"+membraneSubDomain.getName() + "'");
										return false;
									}
								}
							}
						}
					}else if (equ instanceof OdeEquation){
						odeRefCount++;
					}
					//
					// for each JumpCondition, make sure that there is at least one PDE defined in inside or outside compartment
					// and for each side, if the PDE is missing, then the corresponding flux term should be identically zero.
					//
					if (subDomain instanceof MembraneSubDomain){
						MembraneSubDomain memSubDomain = (MembraneSubDomain)subDomain;
						JumpCondition jumpCondition = memSubDomain.getJumpCondition(volVar);
						if (jumpCondition != null){
							boolean bInsidePresent = (memSubDomain.getInsideCompartment().getEquation(volVar) instanceof PdeEquation);
							boolean bOutsidePresent = (memSubDomain.getOutsideCompartment().getEquation(volVar) instanceof PdeEquation);
							if (!bInsidePresent && !bOutsidePresent){
								setWarning("Spatial Model, Jump condition for '"+volVar.getName()+"' on membrane '"+memSubDomain.getName()+"' "+
									       "has no matching PDE in either '"+memSubDomain.getInsideCompartment().getName()+"' or "+
									       "'"+memSubDomain.getOutsideCompartment().getName()+"'");
								return false;
							}
							//
							// if either side is missing, then flux term should be identically zero.
							//
							if (!bInsidePresent && !jumpCondition.getInFluxExpression().isZero()){
								setWarning("Spatial Model, Jump condition for '"+volVar.getName()+"' on membrane '"+memSubDomain.getName()+"' "+
									       "has a non-zero inward flux but no PDE in compartment '"+memSubDomain.getInsideCompartment().getName()+"'");
								return false;
							}
							if (!bOutsidePresent && !jumpCondition.getOutFluxExpression().isZero()){
								setWarning("Spatial Model, Jump condition for '"+volVar.getName()+"' on membrane '"+memSubDomain.getName()+"' "+
									       "has a non-zero outward flux but no PDE in compartment '"+memSubDomain.getOutsideCompartment().getName()+"'");
								return false;
							}
								
						}
					}
				}
				if (odeRefCount>0 && pdeRefCount>0){
					setWarning("Spatial Model, cannot mix "+VCML.OdeEquation+"'s and "+VCML.PdeEquation+"'s for variable "+volVar.getName());
					return false;
				}
				if (steadyPdeCount>0 && pdeRefCount>0){
					setWarning("Spatial Model, cannot mix " + VCML.Steady + " and " + VCML.Unsteady + " " + VCML.PdeEquation + "'s for variable " + volVar.getName());
					return false;
				}
				if (odeRefCount==0 && pdeRefCount==0 && steadyPdeCount == 0){
					setWarning("Spatial Model, there is neither a "+VCML.PdeEquation+" nor an "+VCML.OdeEquation+" for variable "+volVar.getName());
					return false;
				}
			}
		
			//
			// Check that there is an equation (OdeEquation) for a given MembraneVariable on each membrane.
			//
			else if (var instanceof MemVariable){
				int pdeRefCount = 0;
				int odeRefCount = 0;
				int steadyPdeCount = 0;
				for (int j=0;j<subDomainList.size();j++){
					SubDomain subDomain = subDomainList.elementAt(j);
					Equation equ = subDomain.getEquation(var);
					if (equ instanceof PdeEquation){
						if (((PdeEquation)equ).isSteady()) {
							steadyPdeCount ++;
						} else {
							pdeRefCount++;
						}
					}else if (equ instanceof OdeEquation){
						odeRefCount++;
					}
				}
				if (odeRefCount>0 && pdeRefCount>0){
					setWarning("Spatial Model, cannot mix "+VCML.OdeEquation+"'s and "+VCML.PdeEquation+"'s for variable "+var.getName());
					return false;
				}
				if (steadyPdeCount>0 && pdeRefCount>0){
					setWarning("Spatial Model, cannot mix " + VCML.Steady + " and " + VCML.Unsteady + " " + VCML.PdeEquation + "'s for variable " + var.getName());
					return false;
				}
				if (odeRefCount==0 && pdeRefCount==0 && steadyPdeCount == 0){
					setWarning("Spatial Model, there is neither a "+VCML.PdeEquation+" nor an "+VCML.OdeEquation+" for variable "+var.getName());
					return false;
				}
			}
			//
			// Check that there is an equation (OdeEquation) for a given FilamentVariable on each FilamentSubDomain.
			//
			else if (var instanceof FilamentVariable){
				for (int j=0;j<subDomainList.size();j++){
					SubDomain subDomain = subDomainList.elementAt(j);
					if (subDomain instanceof FilamentSubDomain){
						Equation equ = subDomain.getEquation(var);
						if (!(equ instanceof OdeEquation)){
							setWarning("There should be a "+VCML.OdeEquation+" defined for variable "+var.getName()+" for "+VCML.FilamentSubDomain+" "+subDomain.getName());
							return false;
						}
					}
				}
			}
			//
			// Check that there is a region equation (VolumeRegionEquation) for a given VolumeRegionVariable on each CompartmentSubDomain.
			//
			else if (var instanceof VolumeRegionVariable){
				VolumeRegionVariable volRegionVar = (VolumeRegionVariable)var;
				int count = 0;
				for (int j=0;j<subDomainList.size();j++){
					SubDomain subDomain = subDomainList.elementAt(j);
					if (subDomain instanceof CompartmentSubDomain){
						Equation equ = subDomain.getEquation(volRegionVar);
						if (equ instanceof VolumeRegionEquation){
							count ++;
					
							//
							// for each VolumeRegionEquation, make sure that a jump condition all membranes that border this compartment
							//
							for (int k = 0; k < subDomainList.size(); k++){
								SubDomain subDomain2 = subDomainList.elementAt(k);
								if (subDomain2 instanceof MembraneSubDomain){
									MembraneSubDomain membraneSubDomain = (MembraneSubDomain)subDomain2;
									if (membraneSubDomain.getInsideCompartment() == subDomain || membraneSubDomain.getOutsideCompartment() == subDomain){
										if (membraneSubDomain.getJumpCondition(volRegionVar)==null){
											setWarning("Spatial Model, VolumeRegionEquation for '"+volRegionVar.getName()+"' in '"+subDomain.getName()+"' "+
												       "does not have a jump condition on membrane '"+membraneSubDomain.getName() + "'");
											return false;
										}
									}
								}
							}
						}
					}
				}
				if (count == 0) {
					setWarning("There should be at least one "+VCML.VolumeRegionEquation+" defined for variable "+volRegionVar.getName());
					return false;
				}
			}
			//
			// Check that there is a region equation (MembraneRegionEquation) for a given MembraneRegionVariable on each MembraneSubDomain.
			//
			else if (var instanceof MembraneRegionVariable){
				int count = 0;
				for (int j=0;j<subDomainList.size();j++){
					SubDomain subDomain = subDomainList.elementAt(j);
					if (subDomain instanceof MembraneSubDomain){
						Equation equ = subDomain.getEquation(var);
						if (equ instanceof MembraneRegionEquation){
							count ++;
						}
					}
				}
				if (count == 0) {
					setWarning("There should be at least one "+VCML.MembraneRegionEquation+" defined for variable "+var.getName());
					return false;
				}
			}
			//
			// Check that there is a region equation (FilamentRegionEquation) for a given FilamentRegionVariable on each FilamentSubDomain.
			//
			else if (var instanceof FilamentRegionVariable){
				for (int j=0;j<subDomainList.size();j++){
					SubDomain subDomain = subDomainList.elementAt(j);
					if (subDomain instanceof FilamentSubDomain){
						Equation equ = subDomain.getEquation(var);
						if (!(equ instanceof FilamentRegionEquation)){
							setWarning("There should be a "+VCML.FilamentRegionEquation+" defined for variable "+var.getName()+" for "+VCML.FilamentSubDomain+" "+subDomain.getName());
							return false;
						}
					}
				}
			}
		}
	}
	try {
		if (eventList.size() > 0 && isSpatial()) {
			setWarning("Events are not supported in spatial models.");
			return false;
		}
		for (Event event : eventList) {
			event.bind(this);
		}
	}catch (ExpressionBindingException e){
		setWarning("error binding identifier: "+e.getMessage());
		return false;
	}		
	return true;	
}


/**
 * Insert the method's description here.
 * Creation date: (10/9/2002 10:54:06 PM)
 * @return cbit.vcell.math.MathDescription
 */
void makeCanonical() throws MathException, ExpressionException, MappingException {
	
	// this method operates on argument; call createCanonicalMathDescription to make new one
	MathDescription newMath = this;
	
	boolean bRoundCoefficients = false;

	//
	// make a "identity" simulation (no overrides), this will help to substitute/flatten expressions.
	//
	Simulation tempSimulation = new Simulation(newMath);
	SimulationSymbolTable simSymbolTable = new SimulationSymbolTable(tempSimulation, 0);
	
	//
	// substitute all rates, initial conditions, boundary conditions, jump conditions
	//
	for (int i = 0; i < newMath.subDomainList.size(); i++){
		SubDomain subDomain = newMath.subDomainList.elementAt(i);
		Enumeration<Equation> equEnum = subDomain.getEquations();
		while (equEnum.hasMoreElements()){
			Equation equ = equEnum.nextElement();
			equ.flatten(simSymbolTable,bRoundCoefficients);
		}
		if (subDomain instanceof MembraneSubDomain){
			Enumeration<JumpCondition> jcEnum = ((MembraneSubDomain)subDomain).getJumpConditions();
			while (jcEnum.hasMoreElements()){
				JumpCondition jc = jcEnum.nextElement();
				jc.flatten(simSymbolTable,bRoundCoefficients);
			}
		}
	}

	//
	// remove all "dummy" equations (rate=0,initial=0)
	// remove all Priorities (shouldn't be used in BioModels)
	//
	for (int i = 0; i < newMath.subDomainList.size(); i++){
		SubDomain subDomain = newMath.subDomainList.elementAt(i);
		subDomain.trimTrivialEquations(newMath);
		if (subDomain instanceof CompartmentSubDomain){
			int uniquePriority = subDomain.getName().hashCode();
			((CompartmentSubDomain)subDomain).setPriority(uniquePriority);
		}
	}

	//
	// substitute all fast rates, fast invariants
	//
	for (int i = 0; i < newMath.subDomainList.size(); i++){
		SubDomain subDomain = newMath.subDomainList.elementAt(i);
		FastSystem fastSystem = subDomain.getFastSystem();
		if (fastSystem != null){
			fastSystem.flatten(simSymbolTable,bRoundCoefficients);
		}
	}

	//
	// get rid of all non-variables (functions, constants).
	//
	Vector<Variable> newVarList = new Vector<Variable>(newMath.variableList);
	Iterator<Variable> newVarListIter = newVarList.iterator();
	while (newVarListIter.hasNext()){
		Variable var = newVarListIter.next();
		if (var instanceof Constant || var instanceof Function || var instanceof InsideVariable || var instanceof OutsideVariable){
			newVarListIter.remove();
		}
	}
	Variable newVariables[] = (Variable[])BeanUtils.getArray(newVarList,Variable.class);
	newMath.setAllVariables(newVariables);

	//
	// rebind all mathDescription
	//	
	for (int i = 0; i < newMath.subDomainList.size(); i++){
		SubDomain subDomain = newMath.subDomainList.elementAt(i);
		FastSystem fastSystem = subDomain.getFastSystem();
		if (fastSystem != null){
			fastSystem.rebind();
		}
		Enumeration<Equation> equEnum = subDomain.getEquations();
		while (equEnum.hasMoreElements()){
			Equation equ = equEnum.nextElement();
			equ.bind(simSymbolTable);
		}
		if (subDomain instanceof MembraneSubDomain){
			Enumeration<JumpCondition> jcEnum = ((MembraneSubDomain)subDomain).getJumpConditions();
			while (jcEnum.hasMoreElements()){
				JumpCondition jc = jcEnum.nextElement();
				jc.bind(simSymbolTable);
			}
		}
	}
}


/**
 * This method was created by a SmartGuide.
 * @param tokens java.util.StringTokenizer
 * @exception java.lang.Exception The exception description.
 */
public void read_database(CommentStringTokenizer tokens) throws MathException {
							
	clearAll();
	
	VariableHash varHash = new VariableHash();	
	try {
		String token = null;
		token = tokens.nextToken();
		if (token.equalsIgnoreCase(VCML.MathDescription)){
			//token = tokens.nextToken();
			//setName(token);
			//CHECK THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			//if(!token.equals(argName)){
			//	throw new DataAccessException("MathDescription Version Name and Token Name Don't match");
			//}
			token = tokens.nextToken();
			if (!token.equalsIgnoreCase(VCML.BeginBlock)){
				throw new MathException("unexpected token "+token+" expecting "+VCML.BeginBlock);
			}
		}	
		while (tokens.hasMoreTokens()){
			token = tokens.nextToken();
			if (token.equalsIgnoreCase(VCML.EndBlock)){
				break;
			}			
			if (token.equalsIgnoreCase(VCML.VolumeVariable)){
				token = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(token);
				String name = Variable.getNameFromCombinedIdentifier(token);
				VolVariable var = new VolVariable(name,domain);
				varHash.addVariable(var);
//
// done in addVariable0()
//
//			InsideVariable inside = new InsideVariable(token+"_INSIDE", token);
//			addVariable0(inside);
//			OutsideVariable outside = new OutsideVariable(token+"_OUTSIDE", token);
//			addVariable0(outside);
				continue;
			}
			//
			// this is still here to gracefully read old mathDescriptions
			//
			if (token.equalsIgnoreCase(VCML.Task)){
				while (tokens.hasMoreTokens()){
					token = tokens.nextToken(); // toss away until end of block
					if (token.equalsIgnoreCase(VCML.EndBlock)){
						break;
					}			
				}
				continue;
			}			
			if (token.equalsIgnoreCase(VCML.MembraneVariable)){
				token = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(token);
				String name = Variable.getNameFromCombinedIdentifier(token);
				MemVariable var = new MemVariable(name,domain);
				varHash.addVariable(var);
				continue;
			}
			if (token.equalsIgnoreCase(VCML.FilamentVariable)){
				token = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(token);
				String name = Variable.getNameFromCombinedIdentifier(token);
				FilamentVariable var = new FilamentVariable(name,domain);
				varHash.addVariable(var);
				continue;
			}
			if (token.equalsIgnoreCase(VCML.VolumeRegionVariable)){
				token = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(token);
				String name = Variable.getNameFromCombinedIdentifier(token);
				VolumeRegionVariable var = new VolumeRegionVariable(name,domain);
				varHash.addVariable(var);
				continue;
			}
			if (token.equalsIgnoreCase(VCML.MembraneRegionVariable)){
				token = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(token);
				String name = Variable.getNameFromCombinedIdentifier(token);
				MembraneRegionVariable var = new MembraneRegionVariable(name,domain);
				varHash.addVariable(var);
				continue;
			}
			if (token.equalsIgnoreCase(VCML.FilamentRegionVariable)){
				token = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(token);
				String name = Variable.getNameFromCombinedIdentifier(token);
				FilamentRegionVariable var = new FilamentRegionVariable(name,domain);
				varHash.addVariable(var);
				continue;
			}
			if (token.equalsIgnoreCase(VCML.Constant)){
				token = tokens.nextToken();
				Expression exp = MathFunctionDefinitions.fixFunctionSyntax(tokens);
				Constant constant = new Constant(token,exp);
				varHash.addVariable(constant);
				continue;
			}
			if (token.equalsIgnoreCase("Parameter")){
				token = tokens.nextToken();
				ParameterVariable pv = new ParameterVariable(token);
				varHash.addVariable(pv);
				continue;
			}
			//stochastic variable
			if (token.equalsIgnoreCase(VCML.StochVolVariable))
			{
				token = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(token);
				String name = Variable.getNameFromCombinedIdentifier(token);
				StochVolVariable var = new StochVolVariable(name);
				varHash.addVariable(var);
				continue;
			}
			if (token.equalsIgnoreCase(VCML.VolumeParticleVariable))
			{
				token = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(token);
				String name = Variable.getNameFromCombinedIdentifier(token);
				VolumeParticleVariable var = new VolumeParticleVariable(name,domain);
				varHash.addVariable(var);
				continue;
			}
			if (token.equalsIgnoreCase(VCML.MembraneParticleVariable))
			{
				token = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(token);
				String name = Variable.getNameFromCombinedIdentifier(token);
				MembraneParticleVariable var = new MembraneParticleVariable(name,domain);
				varHash.addVariable(var);
				continue;
			}
			if (token.equalsIgnoreCase(VCML.Function)){
				token = tokens.nextToken();
				Expression exp = MathFunctionDefinitions.fixFunctionSyntax(tokens);
				Domain domain = Variable.getDomainFromCombinedIdentifier(token);
				String name = Variable.getNameFromCombinedIdentifier(token);
				Function function = new Function(name,exp,domain);
				varHash.addVariable(function);
				continue;
			}
			if (token.equalsIgnoreCase(VCML.CompartmentSubDomain)){
				if (variableList.size() == 0) {
					setAllVariables(varHash.getAlphabeticallyOrderedVariables());
				}
				token = tokens.nextToken();
				CompartmentSubDomain subDomain = new CompartmentSubDomain(token,this,tokens);
				addSubDomain0(subDomain);
				continue;
			}			
			if (token.equalsIgnoreCase(VCML.MembraneSubDomain)){
				token = tokens.nextToken();
				CompartmentSubDomain insideCompartment = getCompartmentSubDomain(token);
				if (insideCompartment == null){
					throw new MathFormatException("defined membrane subdomain without a corresponding inside volume subdomain first");
				}	
				token = tokens.nextToken();
				CompartmentSubDomain outsideCompartment = getCompartmentSubDomain(token);
				if (outsideCompartment == null){
					throw new MathFormatException("defined membrane subdomain without a corresponding outside volume subdomain first");
				}	
				MembraneSubDomain subDomain = new MembraneSubDomain(insideCompartment,outsideCompartment);
				subDomain.read(this,tokens);
				addSubDomain0(subDomain);
				continue;
			}			
			if (token.equalsIgnoreCase(VCML.FilamentSubDomain)){
				token = tokens.nextToken();
				String subDomainName = token;
				token = tokens.nextToken();
				CompartmentSubDomain outsideCompartment = getCompartmentSubDomain(token);
				if (outsideCompartment == null){
					throw new MathFormatException("defined membrane subdomain without a corresponding outside volume subdomain first");
				}	
				FilamentSubDomain subDomain = new FilamentSubDomain(subDomainName,outsideCompartment);
				subDomain.read(this,tokens);
				addSubDomain0(subDomain);
				continue;
			}
			//
			// this is here so that old mathDescriptions are read gracefully.
			//
			if (token.equalsIgnoreCase(VCML.Mesh)){
				while (tokens.hasMoreTokens()){
					token = tokens.nextToken(); // toss away until end of block
					if (token.equalsIgnoreCase(VCML.EndBlock)){
						break;
					}			
				}
				continue;
			}
			
			if (token.equalsIgnoreCase(VCML.Event)) {
				if (variableList.size() == 0) {
					setAllVariables(varHash.getAlphabeticallyOrderedVariables());
				}
				token = tokens.nextToken();
				Event event = new Event(token, this, tokens);
				eventList.add(event);
				continue;
			}
			if (token.equalsIgnoreCase(VCML.VolumeRandomVariable)) {
				token = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(token);
				String name = Variable.getNameFromCombinedIdentifier(token);
				RandomVariable randomVariable = new VolumeRandomVariable(name, this, tokens, domain);
				varHash.addVariable(randomVariable);
				continue;
			}
			if (token.equalsIgnoreCase(VCML.MembraneRandomVariable)) {
				token = tokens.nextToken();
				Domain domain = Variable.getDomainFromCombinedIdentifier(token);
				String name = Variable.getNameFromCombinedIdentifier(token);
				RandomVariable randomVariable = new MembraneRandomVariable(name, this, tokens, domain);
				varHash.addVariable(randomVariable);
				continue;
			}
			throw new MathFormatException("unexpected identifier "+token);
		}		
	}catch (Throwable e){
		e.printStackTrace(System.out);
		throw new MathException("line #" + tokens.lineIndex() + " Exception: "+e.getMessage());
	}	
	fireStateChanged();
}


/**
 * This method was created in VisualAge.
 */
public void refreshDependencies() {
}


/**
 * Remove a javax.swing.event.ChangeListener.
 */
public void removeChangeListener(javax.swing.event.ChangeListener newListener) {
	if (aChangeListener != null) {
		aChangeListener.removeElement(newListener);
	};
}


/**
 * The removePropertyChangeListener method was generated to support the propertyChange field.
 */
public synchronized void removePropertyChangeListener(java.beans.PropertyChangeListener listener) {
	getPropertyChange().removePropertyChangeListener(listener);
}

/**
 * The removeVetoableChangeListener method was generated to support the vetoPropertyChange field.
 */
public synchronized void removeVetoableChangeListener(java.beans.VetoableChangeListener listener) {
	getVetoPropertyChange().removeVetoableChangeListener(listener);
}


/**
 * This method was created by a SmartGuide.
 * @param var cbit.vcell.math.Variable
 */
public void setAllVariables(Variable vars[]) throws MathException, ExpressionBindingException, MappingException {
	// make sure it's OK
	VariableHash hash = new VariableHash();
	for (int i = 0; i < vars.length; i++){
		hash.addVariable(vars[i]);
	}	
	hash.getTopologicallyReorderedVariables();
	
	variableList.clear();
	variableHashTable.clear();
	// adding without binding
	for (Variable var : vars){
		if (var instanceof InsideVariable || var instanceof OutsideVariable) { // if vars has inside and outside already, ignore
			continue;
		}
		if (getVariable(var.getName()) != null){
			throw new MathException("variable "+var.getName()+" already exists");
		}
		variableList.addElement(var);
		variableHashTable.put(var.getName(), var);
		if (var instanceof VolVariable || var instanceof VolumeRegionVariable){
			//
			// for Volume Variables, also create an InsideVariable and an OutsideVariable for use in JumpConditions
			//
			InsideVariable inVar = new InsideVariable(var.getName()+InsideVariable.INSIDE_VARIABLE_SUFFIX, var.getName());
			variableList.addElement(inVar);
			variableHashTable.put(inVar.getName(), inVar);
			OutsideVariable outVar = new OutsideVariable(var.getName()+OutsideVariable.OUTSIDE_VARIABLE_SUFFIX, var.getName());
			variableList.addElement(outVar);
			variableHashTable.put(outVar.getName(), outVar);
		}
	}
	// bind each variable
	Iterator<Variable> iter = variableList.iterator();
	while (iter.hasNext()) {
		iter.next().bind(this);
	}
	
	for (int i = 0; i < subDomainList.size(); i++){
		SubDomain subDomain = subDomainList.elementAt(i);
		Enumeration<Equation> equEnum = subDomain.getEquations();
		while (equEnum.hasMoreElements()){
			Equation equ = equEnum.nextElement();
			equ.bind(this);
		}
		FastSystem fastSystem = subDomain.getFastSystem();
		if (fastSystem!=null){
			Enumeration<FastRate> frEnum = fastSystem.getFastRates();
			while (frEnum.hasMoreElements()){
				FastRate fr = frEnum.nextElement();
				fr.bind(this);
			}
			Enumeration<FastInvariant> fiEnum = fastSystem.getFastInvariants();
			while (fiEnum.hasMoreElements()){
				FastInvariant fi = fiEnum.nextElement();
				fi.bind(this);
			}
		}
	}
	for (Event event : eventList) {
		event.bind(this);
	}
	fireStateChanged();
}


/**
 * Sets the description property (java.lang.String) value.
 * @param description The new value for the property.
 * @exception java.beans.PropertyVetoException The exception description.
 * @see #getDescription
 */
public void setDescription(java.lang.String description) throws java.beans.PropertyVetoException {
	String oldValue = fieldDescription;
	fireVetoableChange("description", oldValue, description);
	fieldDescription = description;
	firePropertyChange("description", oldValue, description);
}


/**
 * This method was created in VisualAge.
 * @param geometry cbit.vcell.geometry.Geometry
 */
public void setGeometry(Geometry argGeometry) throws java.beans.PropertyVetoException {
	Geometry oldValue = this.geometry;
	fireVetoableChange(GeometryOwner.PROPERTY_NAME_GEOMETRY, oldValue, argGeometry);
//	this.geometry = argGeometry;
	setGeometry0(argGeometry);
	firePropertyChange(GeometryOwner.PROPERTY_NAME_GEOMETRY, oldValue, argGeometry);
	fireStateChanged();
	//
	// compute warning string (if necessary)
	//
	isValid();

}


/**
 * This method was created in VisualAge.
 * @param geometry cbit.vcell.geometry.Geometry
 */
private void setGeometry0(Geometry geometry) {
	if (this.geometry != geometry){
		this.geometry = geometry;
	}
}

/**
 * Sets the name property (java.lang.String) value.
 * @param name The new value for the property.
 * @exception java.beans.PropertyVetoException The exception description.
 * @see #getName
 */
public void setName(java.lang.String name) throws java.beans.PropertyVetoException {
	String oldValue = fieldName;
	fireVetoableChange("name", oldValue, name);
	fieldName = name;
	firePropertyChange("name", oldValue, name);
}


/**
 * Sets the warning property (java.lang.String) value.
 * @param warning The new value for the property.
 * @see #getWarning
 */
private void setWarning(java.lang.String warning) {
	String oldValue = fieldWarning;
	fieldWarning = warning;
	firePropertyChange("warning", oldValue, warning);
}


/**
 * Insert the method's description here.
 * Creation date: (10/9/2002 10:54:06 PM)
 * @return cbit.vcell.math.MathDescription
 */
void substituteInPlace(Function functionsToSubstitute[]) throws MathException, ExpressionException, MappingException {
	//
	// make a "identity" simulation (no overrides), this will help to substitute/flatten expressions.
	//
	for (int i = 0; i < functionsToSubstitute.length; i++){
		variableList.insertElementAt(functionsToSubstitute[i], 0);
		variableHashTable.put(functionsToSubstitute[i].getName(), functionsToSubstitute[i]);
	}
	Simulation tempSimulation = new Simulation(this);
	SimulationSymbolTable simSymbolTable = new SimulationSymbolTable(tempSimulation, 0);
	MathDescription newMath = this;
	boolean bRoundCoefficients = false;
	//
	// substitute all rates, initial conditions, boundary conditions, jump conditions, fast rates, fast invariants
	//
	for (int i = 0; i < newMath.subDomainList.size(); i++){
		SubDomain subDomain = newMath.subDomainList.elementAt(i);
		FastSystem fastSystem = subDomain.getFastSystem();
		if (fastSystem != null){
			fastSystem.flatten(simSymbolTable,bRoundCoefficients);
		}
		Enumeration<Equation> equEnum = subDomain.getEquations();
		while (equEnum.hasMoreElements()){
			Equation equ = equEnum.nextElement();
			equ.flatten(simSymbolTable,bRoundCoefficients);
		}
		if (subDomain instanceof MembraneSubDomain){
			Enumeration<JumpCondition> jcEnum = ((MembraneSubDomain)subDomain).getJumpConditions();
			while (jcEnum.hasMoreElements()){
				JumpCondition jc = jcEnum.nextElement();
				jc.flatten(simSymbolTable,bRoundCoefficients);
			}
		}
	}

	//
	// rebind all mathDescription
	//
	for (int i = 0; i < newMath.subDomainList.size(); i++){
		SubDomain subDomain = newMath.subDomainList.elementAt(i);
		FastSystem fastSystem = subDomain.getFastSystem();
		if (fastSystem != null){
			fastSystem.rebind();
		}
		Enumeration<Equation> equEnum = subDomain.getEquations();
		while (equEnum.hasMoreElements()){
			Equation equ = equEnum.nextElement();
			equ.bind(simSymbolTable);
		}
		if (subDomain instanceof MembraneSubDomain){
			Enumeration<JumpCondition> jcEnum = ((MembraneSubDomain)subDomain).getJumpConditions();
			while (jcEnum.hasMoreElements()){
				JumpCondition jc = jcEnum.nextElement();
				jc.bind(simSymbolTable);
			}
		}
	}
}


/**
 * Insert the method's description here.
 * Creation date: (9/28/2004 5:50:22 PM)
 * @return java.lang.String
 * @param memoryMathDescription cbit.vcell.math.MathDescription
 * @param databaseMathDescription cbit.vcell.math.MathDescription
 */
public static String testEquivalency(MathDescription mathDescription1, MathDescription mathDescription2, StringBuffer reason) {

	try {
		String equivalency = null;

		if (!mathDescription2.compareInvariantAttributes(mathDescription1)){
			//
			// can't be equivalent or equal
			//
			equivalency = MATH_DIFFERENT;
			reason.append("Different invariants");
		}else if (mathDescription2.compareEqual(mathDescription1)){
			equivalency = MATH_SAME;
			reason.append("Same");
		}else{
			//
			// must test for equivalence
			//
			HashSet<String> indepVars1 = mathDescription1.getStateVariableNames();
			HashSet<String> indepVars2 = mathDescription2.getStateVariableNames();
			HashSet<String> union = new HashSet<String>(indepVars1);
			union.addAll(indepVars2);
			
			MathDescription canonicalMath1 = MathDescription.createCanonicalMathDescription(createMathWithExpandedEquations(mathDescription1,union));
			MathDescription canonicalMath2 = MathDescription.createCanonicalMathDescription(createMathWithExpandedEquations(mathDescription2,union));

			HashSet<String> depVarsToSubstitute = new HashSet<String>(union);
			depVarsToSubstitute.removeAll(indepVars1);
			if (depVarsToSubstitute.size()>0){
				String depVarNames[] = (String[])depVarsToSubstitute.toArray(new String[depVarsToSubstitute.size()]);
				Function functionsToSubstitute[] = MathDescription.getFlattenedFunctions(mathDescription1,depVarNames);
				canonicalMath1.substituteInPlace(functionsToSubstitute);
				canonicalMath2.substituteInPlace(functionsToSubstitute);
			}
			// flatten again
			canonicalMath1.makeCanonical();
			canonicalMath2.makeCanonical();
			// now compare
			if (canonicalMath2.compareEquivalent(canonicalMath1,reason,true)){
				// found to be equivalent
				equivalency = MATH_EQUIVALENT;
			}else{
				// found to be different
				equivalency = MATH_DIFFERENT;
			}
		}
		return equivalency;
	}catch (MathException e){
		e.printStackTrace(System.out);
		throw new RuntimeException(e.getMessage());
	}catch (ExpressionException e){
		e.printStackTrace(System.out);
		throw new RuntimeException(e.getMessage());
	}catch (MappingException e){
		e.printStackTrace(System.out);
		throw new RuntimeException(e.getMessage());
	}
}

public boolean hasDiscontinuities() throws ExpressionException {
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()) {		
		SubDomain sd = enum1.nextElement();
		Enumeration<Equation> enum_equ = sd.getEquations();
		while (enum_equ.hasMoreElements()){
			Equation equation = enum_equ.nextElement();
			if (equation.hasDiscontinuities(this)) {
				return true;
			}
		}
		if (sd.getFastSystem() != null) {
			Expression[] exps = sd.getFastSystem().getExpressions();
			for (int i = 0; i < exps.length; i++) {
				if (exps[i].getDiscontinuities().size() > 0) {
					return true;
				}
			}
		}
	}
	for (Variable var : variableList) {
		Expression expression = var.getExpression();
		if (expression != null && expression.getDiscontinuities().size() > 0) {
			return true;			
		}
	}
	return false;
}


/**
 * This method was created by a SmartGuide.
 * @return java.lang.String
 */
public String toString() {
	return "Math@"+Integer.toHexString(hashCode())+"("+version+")";
}


public String getMathType()
{
	return isNonSpatialStoch() ? BioModelChildSummary.TYPE_STOCH_STR : BioModelChildSummary.TYPE_DETER_STR;
}


public void getEntries(Map<String, SymbolTableEntry> entryMap) {
	ReservedMathSymbolEntries.getAll(entryMap);
	for (Variable v : variableList) {
		entryMap.put(v.getName(), v);
	}
}

public void addEvent(Event event) throws MathException {
	if (getEvent(event.getName()) != null) {
		throw new MathException("Event '" + event.getName() + "' already exists.");
	}
	eventList.add(event);
}

public Event getEvent(String name) {
	for (Event e : eventList) {
		if (e.getName().equals(name)) {
			return e;
		}
	}	
	return null;
}

public boolean hasEvents() {
	return eventList.size() > 0;
}

public boolean hasRandomVariables() {
	for (Variable var : variableList) {
		if (var instanceof RandomVariable) {
			return true;
		}
	}
	return false;
}

public boolean hasVolumeRegionEquations() {
	Enumeration<SubDomain> enum1 = getSubDomains();
	while (enum1.hasMoreElements()){
		SubDomain subDomain = enum1.nextElement();
		if (subDomain instanceof CompartmentSubDomain){
			Enumeration<Equation> equations = subDomain.getEquations();
			while (equations.hasMoreElements()) {
				if (equations.nextElement() instanceof VolumeRegionEquation){
					return true;
				}
			}
		}
	}
	return false;		
}


public boolean hasRegionSizeFunctions() {
	return bRegionSizeFunctionsUsed;
}

}