package cbit.vcell.client;import java.awt.Dimension;import java.io.BufferedReader;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.ArrayList;import java.util.Enumeration;import java.util.Hashtable;import java.util.Vector;import javax.swing.JInternalFrame;import org.vcell.solver.smoldyn.SmoldynFileWriter;import org.vcell.util.BeanUtils;import org.vcell.util.PropertyLoader;import org.vcell.util.SessionLog;import org.vcell.util.StdoutSessionLog;import org.vcell.util.TokenMangler;import org.vcell.util.UserCancelException;import org.vcell.util.document.SimulationVersion;import org.vcell.util.document.Version;import org.vcell.util.gui.DialogUtils;import cbit.vcell.client.data.DataViewer;import cbit.vcell.client.data.ODEDataViewer;import cbit.vcell.client.data.OutputContext;import cbit.vcell.client.data.SimulationWorkspaceModelInfo;import cbit.vcell.client.desktop.simulation.SimulationStatusDetails;import cbit.vcell.client.desktop.simulation.SimulationStatusDetailsPanel;import cbit.vcell.client.desktop.simulation.SimulationWindow;import cbit.vcell.client.desktop.simulation.SimulationWorkspace;import cbit.vcell.client.server.DataViewerController;import cbit.vcell.client.task.AsynchClientTask;import cbit.vcell.client.task.ClientTaskDispatcher;import cbit.vcell.document.SimulationOwner;import cbit.vcell.mapping.SimulationContext;import cbit.vcell.resource.ResourceUtil;import cbit.vcell.simdata.ODEDataBlock;import cbit.vcell.simdata.SimDataConstants;import cbit.vcell.simdata.SimulationData;import cbit.vcell.solver.Simulation;import cbit.vcell.solver.SimulationInfo;import cbit.vcell.solver.SimulationJob;import cbit.vcell.solver.Solver;import cbit.vcell.solver.SolverDescription;import cbit.vcell.solver.SolverEvent;import cbit.vcell.solver.SolverException;import cbit.vcell.solver.SolverListener;import cbit.vcell.solver.SolverStatus;import cbit.vcell.solver.VCSimulationDataIdentifier;import cbit.vcell.solver.VCSimulationIdentifier;import cbit.vcell.solver.ode.AdamsMoultonFiveSolver;import cbit.vcell.solver.ode.CVodeSolverStandalone;import cbit.vcell.solver.ode.ForwardEulerSolver;import cbit.vcell.solver.ode.IDASolverStandalone;import cbit.vcell.solver.ode.RungeKuttaFehlbergSolver;import cbit.vcell.solver.ode.RungeKuttaFourSolver;import cbit.vcell.solver.ode.RungeKuttaTwoSolver;import cbit.vcell.solver.ode.gui.SimulationStatus;import cbit.vcell.solvers.CombinedSundialsSolver;/** * Insert the type's description here. * Creation date: (6/7/2004 10:31:36 AM) * @author: Ion Moraru */public class ClientSimManager implements java.beans.PropertyChangeListener {	private DocumentWindowManager documentWindowManager = null;	private SimulationWorkspace simWorkspace = null;	private SimulationStatusHash simHash = new SimulationStatusHash();/** * Insert the method's description here. * Creation date: (6/7/2004 10:48:50 AM) * @param documentWindowManager cbit.vcell.client.DocumentWindowManager * @param simulationOwner cbit.vcell.document.SimulationOwner */public ClientSimManager(DocumentWindowManager documentWindowManager, SimulationWorkspace simWorkspace) {	this.documentWindowManager = documentWindowManager;	this.simWorkspace = simWorkspace;	getSimWorkspace().addPropertyChangeListener(this);	initHash(getSimWorkspace().getSimulations());}/** * Insert the method's description here. * Creation date: (6/7/2004 12:50:45 PM) * @return cbit.vcell.client.DocumentWindowManager */DocumentWindowManager getDocumentWindowManager() {	return documentWindowManager;}/** * Insert the method's description here. * Creation date: (6/7/2004 10:31:36 AM) * @return cbit.vcell.solver.ode.gui.SimulationStatus * @param simulation cbit.vcell.solver.Simulation */public SimulationStatus getSimulationStatus(Simulation simulation) {	SimulationStatus cachedSimStatus = simHash.getSimulationStatus(simulation);	if (cachedSimStatus!=null){		if (simulation.getIsDirty()) {			return SimulationStatus.newNotSaved(simulation.getScanCount());		} else {			return cachedSimStatus;		}	} else {		// shouldn't really happen		try {			throw new RuntimeException("shouldn't really happen");		} catch (Throwable e) {			e.printStackTrace(System.out);		}		return null;	}}/** * Insert the method's description here. * Creation date: (6/8/2004 1:17:36 PM) * @return cbit.vcell.client.desktop.simulation.SimulationWorkspace */public SimulationWorkspace getSimWorkspace() {	return simWorkspace;}public void preloadSimulationStatus(Simulation[] simulations) {	initHash(simulations);}/** * Insert the method's description here. * Creation date: (6/7/2004 12:55:18 PM) * @param simulations cbit.vcell.solver.Simulation[] */private void initHash(Simulation[] simulations) {	simHash.changeSimulationInstances(simulations);	if (simulations != null) {		for (int i = 0; i < simulations.length; i++){			SimulationStatus simStatus = simHash.getSimulationStatus(simulations[i]);			if (simStatus==null || simStatus.isUnknown()){				// try to get status from server				simStatus = getDocumentWindowManager().getRequestManager().getServerSimulationStatus(simulations[i].getSimulationInfo());				if (simStatus != null) {					simHash.setSimulationStatus(simulations[i], simStatus);				} else {					simHash.setSimulationStatus(simulations[i], SimulationStatus.newNeverRan(simulations[i].getScanCount()));				}			}		}	}}	/**	 * This method gets called when a bound property is changed.	 * @param evt A PropertyChangeEvent object describing the event source 	 *   	and the property that has changed.	 */public void propertyChange(java.beans.PropertyChangeEvent evt) {	if (evt.getPropertyName().equals("simulations")) {		simHash.changeSimulationInstances((Simulation[])evt.getNewValue());	}	if (evt.getPropertyName().equals("simulationOwner")) {		initHash(((SimulationOwner)evt.getNewValue()).getSimulations());	}}/** * Insert the method's description here. * Creation date: (6/2/2004 3:01:29 AM) * @param simulation cbit.vcell.solver.Simulation[] */public void runSimulations(Simulation[] simulations) {	getDocumentWindowManager().getRequestManager().runSimulations(this, simulations);}/** * Insert the method's description here. * Creation date: (6/7/2004 10:31:36 AM) * @param simulations cbit.vcell.solver.Simulation[] */public void showSimulationResults(final OutputContext outputContext, Simulation[] simulations) {	if (simulations == null) {		return;	}	Vector<Simulation> v = new Vector<Simulation>();	for (int i = 0; i < simulations.length; i++){		if (simulations[i].getSimulationInfo() != null && getSimulationStatus(simulations[i]).getHasData()) {			v.add(simulations[i]);		}	}	final Simulation[] simsToShow = (Simulation[])BeanUtils.getArray(v, Simulation.class);		Hashtable<String, Object> hash = new Hashtable<String, Object>();	// Create the AsynchClientTasks 	ArrayList<AsynchClientTask> taskList = new ArrayList<AsynchClientTask>();	final String dataViewerControllers_string = "dataViewerControllers";	final String failures_string = "failures";	final DocumentWindowManager documentWindowManager = getDocumentWindowManager();	for (int i = 0; i < simsToShow.length; i++){				final Simulation sim  = simsToShow[i];		final VCSimulationIdentifier vcSimulationIdentifier = simsToShow[i].getSimulationInfo().getAuthoritativeVCSimulationIdentifier();		final SimulationWindow simWindow = documentWindowManager.haveSimulationWindow(vcSimulationIdentifier);				if (simWindow == null) {						AsynchClientTask task = new AsynchClientTask("Retrieving results for " + sim.getName(), AsynchClientTask.TASKTYPE_NONSWING_BLOCKING)  {				public void run(Hashtable<String, Object> hashTable) throws Exception {											Hashtable<Simulation,Throwable> failures = (Hashtable<Simulation,Throwable>)hashTable.get(failures_string);					if (failures == null) {						failures = new Hashtable<Simulation, Throwable>();						hashTable.put(failures_string, failures);					}											Hashtable<VCSimulationIdentifier, DataViewerController> dataViewerControllers = (Hashtable<VCSimulationIdentifier, DataViewerController>)hashTable.get(dataViewerControllers_string);					if (dataViewerControllers == null) {						dataViewerControllers = new Hashtable<VCSimulationIdentifier, DataViewerController>();						hashTable.put(dataViewerControllers_string, dataViewerControllers);					}									try {						// make the manager and wire it up						DataViewerController dataViewerController = documentWindowManager.getRequestManager().getDataViewerController(outputContext,sim, 0);						documentWindowManager.addDataListener(dataViewerController);//For changes in time or variable						// make the viewer						dataViewerControllers.put(vcSimulationIdentifier, dataViewerController);					} catch (Throwable exc) {						exc.printStackTrace(System.out);						failures.put(sim, exc);					}				}			};			taskList.add(task);		}				}				AsynchClientTask task = new AsynchClientTask("Showing results", AsynchClientTask.TASKTYPE_SWING_BLOCKING) {		public void run(Hashtable<String, Object> hashTable) throws Exception {								Hashtable<VCSimulationIdentifier, DataViewerController> dataViewerControllers = (Hashtable<VCSimulationIdentifier, DataViewerController>)hashTable.get(dataViewerControllers_string);			Hashtable<Simulation,Throwable> failures = (Hashtable<Simulation,Throwable>)hashTable.get(failures_string);			for (int i = 0; i < simsToShow.length; i++){				final Simulation sim  = simsToShow[i];				final VCSimulationIdentifier vcSimulationIdentifier = simsToShow[i].getSimulationInfo().getAuthoritativeVCSimulationIdentifier();								final SimulationWindow simWindow = documentWindowManager.haveSimulationWindow(vcSimulationIdentifier);				if (simWindow != null) {					JInternalFrame existingFrame = simWindow.getFrame();					documentWindowManager.showFrame(existingFrame);				} else {										// wire it up the viewer					DataViewerController viewerController = dataViewerControllers.get(vcSimulationIdentifier);					Throwable ex = failures.get(sim); 					if (viewerController != null && ex == null) { // no failure						DataViewer viewer = viewerController.createViewer();						getSimWorkspace().getSimulationOwner().getOutputFunctionContext().addPropertyChangeListener(viewerController);						documentWindowManager.addExportListener(viewer);						documentWindowManager.addDataJobListener(viewer);//For data related activities such as calculating statistics												viewer.setSimulationModelInfo(new SimulationWorkspaceModelInfo(getSimWorkspace().getSimulationOwner(),sim.getName()));						viewer.setDataViewerManager(documentWindowManager);						SimulationWindow newWindow = new SimulationWindow(vcSimulationIdentifier, sim, getSimWorkspace().getSimulationOwner(), viewer);												documentWindowManager.addResultsFrame(newWindow);					}				}			}			if (failures != null) {				if (!failures.isEmpty()) {					Enumeration<Simulation> en = failures.keys();					while (en.hasMoreElements()) {						Simulation sim = en.nextElement();						Throwable exc = (Throwable)failures.get(sim);						// notify user						PopupGenerator.showErrorDialog(ClientSimManager.this.getDocumentWindowManager(), "Failed to retrieve results for simulation '"+sim.getName()+"':\n"+exc.getMessage(), exc);					}				}			}		}				};	taskList.add(task);	// Dispatch the tasks using the ClientTaskDispatcher.			AsynchClientTask[] taskArray = new AsynchClientTask[taskList.size()];	taskList.toArray(taskArray);	ClientTaskDispatcher.dispatch(getDocumentWindowManager().getComponent(), hash, taskArray, false, true, null);}/** * Insert the method's description here. * Creation date: (6/7/2004 10:31:36 AM) * @param simulations cbit.vcell.solver.Simulation[] */public void showSimulationStatusDetails(Simulation[] simulations) {	if (simulations != null) {		final Simulation[] simsToShow = simulations; //(Simulation[])cbit.util.BeanUtils.getArray(v, Simulation.class);		for (int i = 0; i < simsToShow.length; i ++) {			SimulationStatusDetailsPanel ssdp = new SimulationStatusDetailsPanel();			ssdp.setPreferredSize(new Dimension(800, 350));			ssdp.setSimulationStatusDetails(new SimulationStatusDetails(getSimWorkspace(), simsToShow[i]));			DialogUtils.showComponentCloseDialog(getDocumentWindowManager().getComponent(), ssdp, "Simulation Status Details");						ssdp.setSimulationStatusDetails(null);		}	}}/** * Insert the method's description here. * Creation date: (6/2/2004 3:01:29 AM) * @param simulations cbit.vcell.solver.Simulation[] */public void stopSimulations(Simulation[] simulations) {	getDocumentWindowManager().getRequestManager().stopSimulations(this, simulations);}/** * Insert the method's description here. * Creation date: (6/9/2004 3:04:12 PM) */void updateStatusFromServer(Simulation simulation) {	// 	// get cached status	//	SimulationStatus oldStatus = getSimulationStatus(simulation);	SimulationStatus serverStatus = getDocumentWindowManager().getRequestManager().getServerSimulationStatus(simulation.getSimulationInfo());	SimulationStatus newStatus = null;	if (oldStatus.isStopRequested() && serverStatus.numberOfJobsDone() < simulation.getScanCount()) {		// if stop requested but still going, get updated server info but adjust status		newStatus = SimulationStatus.newStopRequest(serverStatus);	} else {		// otherwise accept server information		newStatus = serverStatus;	}	// update cache	simHash.setSimulationStatus(simulation,newStatus);		System.out.println("---ClientSimManager.updateStatusFromServer[newStatus=" + newStatus + "], simulation="+simulation.toString());	if (oldStatus!=newStatus){		int simIndex = getSimWorkspace().getSimulationIndex(simulation);		getSimWorkspace().firePropertyChange(SimulationWorkspace.PROPERTY_NAME_SIMULATION_STATUS, new Integer(-1), new Integer(simIndex));	}}/** * Insert the method's description here. * Creation date: (6/2/2004 3:01:29 AM) * @param simulations cbit.vcell.solver.Simulation[] */public void updateStatusFromStartRequest(final Simulation simulation, boolean failed, String failureMessage) {	// asynchronous call - from start request worker thread	SimulationStatus newStatus = failed ? SimulationStatus.newStartRequestFailure(failureMessage, simulation.getScanCount()) : SimulationStatus.newStartRequest(simulation.getScanCount());	simHash.setSimulationStatus(simulation,newStatus);	int simIndex = getSimWorkspace().getSimulationIndex(simulation);	getSimWorkspace().firePropertyChange(SimulationWorkspace.PROPERTY_NAME_SIMULATION_STATUS, new Integer(-1), new Integer(simIndex));}/** * Insert the method's description here. * Creation date: (6/2/2004 3:01:29 AM) * @param simulations cbit.vcell.solver.Simulation[] */public void updateStatusFromStopRequest(final Simulation simulation) {	// asynchronous call - from stop request worker thread	SimulationStatus currentStatus = getSimulationStatus(simulation);	SimulationStatus newStatus = SimulationStatus.newStopRequest(currentStatus);	simHash.setSimulationStatus(simulation,newStatus);	int simIndex = getSimWorkspace().getSimulationIndex(simulation);	getSimWorkspace().firePropertyChange(SimulationWorkspace.PROPERTY_NAME_SIMULATION_STATUS, new Integer(-1), new Integer(simIndex));}public void runSmoldynParticleView(final Simulation originalSimulation) {	SimulationOwner simulationOwner = simWorkspace.getSimulationOwner();	AsynchClientTask[] tasks = null;		if (simulationOwner instanceof SimulationContext) {		AsynchClientTask[] updateTask = ClientRequestManager.updateMath(documentWindowManager.getComponent(), ((SimulationContext)simulationOwner), false);		tasks = new AsynchClientTask[updateTask.length + 1];		System.arraycopy(updateTask, 0, tasks, 0, updateTask.length);	} else {		tasks = new AsynchClientTask[1];	}			tasks[tasks.length - 1] = new AsynchClientTask("starting particle view", AsynchClientTask.TASKTYPE_NONSWING_BLOCKING) {						@Override		public void run(Hashtable<String, Object> hashTable) throws Exception {			File smoldynExe = ResourceUtil.getSmoldynExecutable();				Simulation simulation = new TempSimulation(originalSimulation, false);			SimulationJob simJob = new SimulationJob(simulation, 0, null);			File inputFile = new File(ResourceUtil.getLocalSimDir(), simJob.getSimulationJobID() + SimDataConstants.SMOLDYN_INPUT_FILE_EXTENSION);			inputFile.deleteOnExit();			PrintWriter pw = new PrintWriter(inputFile);			SmoldynFileWriter smf = new SmoldynFileWriter(pw, true, null, simJob, false);			smf.write();			pw.close();				String[] cmd = new String[] {smoldynExe.getAbsolutePath(), inputFile.getAbsolutePath()};			StringBuilder commandLine = new StringBuilder();			for (int i = 0; i < cmd.length; i ++) {				if (i > 0) {					commandLine.append(" ");				}						commandLine.append(TokenMangler.getEscapedPathName(cmd[i]));			}			System.out.println(commandLine);			ProcessBuilder processBuilder = new ProcessBuilder(cmd);			Process process = processBuilder.start();			InputStream is = process.getInputStream();			InputStreamReader isr = new InputStreamReader(is);			BufferedReader br = new BufferedReader(isr);//			String line;						while (br.readLine() != null) {				//System.out.println(line);				//Thread.sleep(100);			}		}	};	ClientTaskDispatcher.dispatch(documentWindowManager.getComponent(), new Hashtable<String, Object>(), tasks, false);}@SuppressWarnings("serial")private class TempSimulation extends Simulation {	final private SimulationVersion tempSimVersion = SimulationVersion.createTempSimulationVersion();	public TempSimulation(Simulation simulation, boolean bCloneMath) {		super(simulation, bCloneMath);	}	@Override	public Version getVersion() {		return tempSimVersion;	}	@Override	public String getSimulationID() {		return createSimulationID(tempSimVersion.getVersionKey());	}	@Override	public SimulationInfo getSimulationInfo() {		return new SimulationInfo(null, tempSimVersion);	}		}public void runQuickOde(final Simulation originalSimulation) {	AsynchClientTask[] tasks = null;	final SimulationOwner simulationOwner = simWorkspace.getSimulationOwner();	if (simulationOwner instanceof SimulationContext) {		AsynchClientTask[] updateTask = ClientRequestManager.updateMath(documentWindowManager.getComponent(), ((SimulationContext)simulationOwner), false);		tasks = new AsynchClientTask[updateTask.length + 2];		System.arraycopy(updateTask, 0, tasks, 0, updateTask.length);	} else {		tasks = new AsynchClientTask[2];	}			final File localSimDataDir = ResourceUtil.getLocalSimDir();		tasks[tasks.length - 2] = new AsynchClientTask("running simulation", AsynchClientTask.TASKTYPE_NONSWING_BLOCKING) {				@Override		public void run(Hashtable<String, Object> hashTable) throws Exception {									Simulation simulation = new TempSimulation(originalSimulation, false);			StdoutSessionLog log = new StdoutSessionLog("ode quick run");			SimulationJob simJob = new SimulationJob(simulation, 0, null);			Solver solver = createQuickRunOdeSolver(log, localSimDataDir, simJob);			if (solver == null) {				throw new RuntimeException("null solver");			}			solver.addSolverListener(new SolverListener() {								public void solverStopped(SolverEvent event) {					getClientTaskStatusSupport().setMessage(event.getSimulationMessage().getDisplayMessage());				}								public void solverStarting(SolverEvent event) {					getClientTaskStatusSupport().setMessage(event.getSimulationMessage().getDisplayMessage());				}								public void solverProgress(SolverEvent event) {					getClientTaskStatusSupport().setMessage("Running...");					getClientTaskStatusSupport().setProgress((int)(event.getProgress() * 100));				}								public void solverPrinted(SolverEvent event) {					getClientTaskStatusSupport().setMessage("Running...");				}								public void solverFinished(SolverEvent event) {					getClientTaskStatusSupport().setMessage(event.getSimulationMessage().getDisplayMessage());				}								public void solverAborted(SolverEvent event) {					getClientTaskStatusSupport().setMessage(event.getSimulationMessage().getDisplayMessage());				}			});			solver.startSolver();						while (true){				try { 					Thread.sleep(500); 				} catch (InterruptedException e) {				}				if (getClientTaskStatusSupport().isInterrupted()) {					solver.stopSolver();					throw UserCancelException.CANCEL_GENERIC;				}				SolverStatus solverStatus = solver.getSolverStatus();				if (solverStatus != null) {					if (solverStatus.getStatus() == SolverStatus.SOLVER_ABORTED) {						throw new RuntimeException(solverStatus.getSimulationMessage().getDisplayMessage());					}					if (solverStatus.getStatus() != SolverStatus.SOLVER_STARTING &&						solverStatus.getStatus() != SolverStatus.SOLVER_READY &&						solverStatus.getStatus() != SolverStatus.SOLVER_RUNNING){						break;					}				}					}						// reading data			VCSimulationIdentifier vcSimulationIdentifier = simulation.getSimulationInfo().getAuthoritativeVCSimulationIdentifier();			VCSimulationDataIdentifier vcDataID = new VCSimulationDataIdentifier(vcSimulationIdentifier, 0); 			SimulationData simulationData = new SimulationData(vcDataID, localSimDataDir, null);			ODEDataBlock odeDataBlock = simulationData.getODEDataBlock();			if (odeDataBlock.getODESimData() == null) {				throw new RuntimeException("simulation failed.");			}			hashTable.put("simulation", simulation);			hashTable.put("vcSimulationIdentifier", vcSimulationIdentifier);			hashTable.put("vcDataID", vcDataID);			hashTable.put("odeDataBlock", odeDataBlock);		}	};	tasks[tasks.length - 1] = new AsynchClientTask("showing results", AsynchClientTask.TASKTYPE_SWING_BLOCKING) {		@Override		public void run(Hashtable<String, Object> hashTable) throws Exception {			Simulation simulation = (Simulation) hashTable.get("simulation");			VCSimulationIdentifier vcSimulationIdentifier = (VCSimulationIdentifier) hashTable.get("vcSimulationIdentifier");			VCSimulationDataIdentifier vcDataID = (VCSimulationDataIdentifier) hashTable.get("vcDataID");			ODEDataBlock odeDataBlock = (ODEDataBlock) hashTable.get("odeDataBlock");			ODEDataViewer odeDataViewer = new ODEDataViewer();			odeDataViewer.setOdeSolverResultSet(odeDataBlock.getODESimData());			odeDataViewer.setSimulation(simulation);			odeDataViewer.setVcDataIdentifier(vcDataID);						SimulationWindow newWindow = new SimulationWindow(vcSimulationIdentifier, simulation, simulationOwner, odeDataViewer);			newWindow.getFrame().setTitle(simulation.getName() + " -- " + simulation.getVersion().getDate());			documentWindowManager.addResultsFrame(newWindow);		}	};	ClientTaskDispatcher.dispatch(documentWindowManager.getComponent(), new Hashtable<String, Object>(), tasks, true, true, null);}private Solver createQuickRunOdeSolver(SessionLog sessionLog, File directory, SimulationJob simJob) throws SolverException, IOException {	SolverDescription solverDescription = simJob.getSimulation().getSolverTaskDescription().getSolverDescription();	if (solverDescription == null) {		throw new IllegalArgumentException("SolverDescription cannot be null");	}	if (solverDescription.isSundialsSolver()) {		System.getProperties().put(PropertyLoader.sundialsSolverExecutableProperty, ResourceUtil.getCombinedSundialsExecutable().getAbsolutePath());	}	Solver solver = null;	if (solverDescription.equals(SolverDescription.ForwardEuler)) {		solver = new ForwardEulerSolver(simJob, directory, sessionLog);	} else if (solverDescription.equals(SolverDescription.RungeKutta2)) {		solver = new RungeKuttaTwoSolver(simJob, directory, sessionLog);	} else if (solverDescription.equals(SolverDescription.RungeKutta4)) {		solver = new RungeKuttaFourSolver(simJob, directory, sessionLog);	} else if (solverDescription.equals(SolverDescription.AdamsMoulton)) {		solver = new AdamsMoultonFiveSolver(simJob, directory, sessionLog);	} else if (solverDescription.equals(SolverDescription.RungeKuttaFehlberg)) {		solver = new RungeKuttaFehlbergSolver(simJob, directory, sessionLog);	} else if (solverDescription.equals(SolverDescription.IDA)) {		solver = new IDASolverStandalone(simJob, directory, sessionLog, false);	} else if (solverDescription.equals(SolverDescription.CVODE)) {		solver = new CVodeSolverStandalone(simJob, directory, sessionLog, false);	} else if (solverDescription.equals(SolverDescription.CombinedSundials)) {		solver = new CombinedSundialsSolver(simJob, directory, sessionLog, false);	}	return solver;}}