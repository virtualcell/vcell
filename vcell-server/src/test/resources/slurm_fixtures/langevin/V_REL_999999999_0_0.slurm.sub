#!/bin/bash --login
#SBATCH --job-name=V_REL_999999999
#SBATCH --nodes=1
#SBATCH --ntasks=4
#SBATCH --qos=vcell
#SBATCH --partition=vcell
#SBATCH -o /share/apps/vcell3/htclogs/V_REL_999999999.stdout
#SBATCH -e /share/apps/vcell3/htclogs/V_REL_999999999.stderr
#SBATCH --cpus-per-task=1
#SBATCH --time=24:00:00

log_file="/share/apps/vcell3/htclogs/V_REL_999999999.log"
total_jobs=10
timeout_duration=15s
max_concurrent_jobs=$SLURM_NTASKS

echo "Job Execution Log" > $log_file
echo "------------------" >> $log_file

# Set up TMPDIR for temporary storage
TMPDIR=/scratch/vcell
if [ ! -e $TMPDIR ]; then mkdir -p $TMPDIR; fi

# Log execution environment details
echo "Job running on host `hostname -f`" >> $log_file
echo "User ID: `id`" >> $log_file
echo "Environment variables:" >> $log_file
env >> $log_file

# Load modules and set up Singularity execution
export MODULEPATH=/isg/shared/modulefiles:/tgcapps/modulefiles
source /usr/share/Modules/init/bash
module load singularity/vcell-3.10.0

export SINGULARITY_CACHEDIR=/share/apps/vcell3/singularity/cachdir
export SINGULARITY_PULLFOLDER=/share/apps/vcell3/singularity/pullfolder

# Define container bindings
container_bindings="--bind /share/apps/vcell3/users:/simdata "
container_bindings+="--bind /share/apps/vcell3/htclogs:/htclogs "
container_bindings+="--bind /scratch/vcell:/solvertmp "

# Define environment variables inside Singularity containers
container_env="--env java_mem_Xmx=4096M "
container_env+="--env primary_datadir_external=/share/apps/vcell3/users "
container_env+="--env primary_datadir_internal=/simdata "
container_env+="--env secondary_datadir_external=/share/apps/vcell7/users "
container_env+="--env secondary_datadir_internal=/simdata_secondary "
container_env+="--env htclogdir_external=/share/apps/vcell3/htclogs "
container_env+="--env htclogdir_internal=/htclogs "
container_env+="--env TMPDIR=/solvertmp "
container_env+="--env mongodbhost_internal=mongo-host-not-set "
container_env+="--env mongodbport_internal=mongo-port-not-set "
container_env+="--env mongodb_database=test "

# Set container prefixes for solvers and batch processing
solver_docker_name=ghcr.io/virtualcell/vcell-batch:7.7.0.27
solver_container_prefix="srun -N 1 -n 1 -c 1 singularity run --containall ${container_bindings} ${container_env} docker://${solver_docker_name}"

batch_docker_name=ghcr.io/virtualcell/vcell-batch:7.7.0.27
batch_container_prefix="srun -N 1 -n 1 -c 1 singularity run --containall ${container_bindings} ${container_env} docker://${batch_docker_name}"

# Exit processor function to handle failures gracefully
callExitProcessor() {
    ${batch_container_prefix} JavaPostprocessor64 999999999 vasilescu 17 0 0 $1 /htclogs/V_REL_999999999_0_0.slurm.sub
}

echo "Starting preprocessor at $(date)" >> $log_file
${batch_container_prefix} JavaPreprocessor64 /simdata/vasilescu/SimID_999999999_0_.simtask.xml /simdata/vasilescu/
preproc_pid=$!
wait $preproc_pid
preproc_exit_code=$?

if [ $preproc_exit_code -ne 0 ]; then
    echo "Preprocessor failed with exit code $preproc_exit_code at $(date)" >> $log_file
    callExitProcessor $preproc_exit_code
    exit $preproc_exit_code
fi

# Track job execution dynamically
declare -A job_pid_map
job_pids=()
running_jobs=0

for i in $(seq 0 $((total_jobs - 1))); do
    echo "Job $i started at $(date)" >> $log_file
    timeout $timeout_duration ${solver_container_prefix} langevin_x64 simulate /simdata/vasilescu/SimID_999999999_0_.langevinInput $i --output-log=/simdata/vasilescu/SimID_999999999_0_.log --vc-print-status &
    pid=$!
    job_pids+=($pid)
    job_pid_map[$pid]=$i
    ((running_jobs++))

    while (( running_jobs >= max_concurrent_jobs )); do
        for idx in "${!job_pids[@]}"; do
            pid="${job_pids[$idx]}"
            if ! kill -0 "$pid" 2>/dev/null; then
                wait "$pid"
                exit_code=$?
                job_index=${job_pid_map[$pid]}
                echo "Job $job_index with PID $pid finished with exit code $exit_code at $(date)" >> $log_file
                unset "job_pids[$idx]"
                unset "job_pid_map[$pid]"
                ((running_jobs--))

                if [ $exit_code -ne 0 ]; then
                    echo "Job $job_index failed, calling exit processor at $(date)" >> $log_file
                    callExitProcessor $exit_code
                    exit $exit_code
                fi
                break
            fi
        done
        sleep 1
    done
done

# Final wait for remaining jobs
for pid in "${job_pids[@]}"; do
    wait $pid
    exit_code=$?
    job_index=${job_pid_map[$pid]}
    echo "Job $job_index with PID $pid finished with exit code $exit_code at $(date)" >> $log_file

    if [ $exit_code -ne 0 ]; then
        echo "Job $job_index failed, calling exit processor at $(date)" >> $log_file
        callExitProcessor $exit_code
        exit $exit_code
    fi
done

# Execute last job with postprocessing
echo "Starting last job at $(date)" >> $log_file
timeout $timeout_duration ${solver_container_prefix} langevin_x64 postprocess /simdata/vasilescu/SimID_999999999_0_.langevinInput $total_jobs --output-log=/simdata/vasilescu/SimID_999999999_0_.log --vc-print-status &
last_pid=$!
wait $last_pid
exit_code=$?

echo "Job 'Last' with PID $last_pid finished with exit code $exit_code at $(date)" >> $log_file
if [ $exit_code -ne 0 ]; then
    echo "Last job failed, calling exit processor at $(date)" >> $log_file
    callExitProcessor $exit_code
    exit $exit_code
fi

echo "All jobs completed at $(date)" >> $log_file
callExitProcessor 0
exit 0
