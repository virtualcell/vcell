package org.jlibsedml;

import org.jdom2.Comment;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.Namespace;
import org.jdom2.output.XMLOutputter;
import org.jlibsedml.components.SId;
import org.jlibsedml.components.SedBase;
import org.jlibsedml.components.SedML;
import org.jlibsedml.components.Version;
import org.jlibsedml.components.model.AddXML;
import org.jlibsedml.components.model.Change;
import org.jlibsedml.components.model.ChangeXML;
import org.jlibsedml.components.model.Model;
import org.jlibsedml.extensions.XMLUtils;
import org.jlibsedml.validation.ValidatorController;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Encapsulates a {@link SedMLDataContainer} model and provides additional validation
 * services.<br/>
 * E.g., typical usage might be:
 *
 * <pre>
 * SEDMLDocument doc = new SEDMLDocument();
 * SedML sedml = doc.getSedMLModel();
 * //  create sedml object....
 * doc.validate();
 * if(doc.hasErrors(){
 *    List<SedMLError> errs = doc.getErrors();
 *    // show errors?
 * }
 * // now write model to file or to String
 *  doc.writeDocument (myFile);
 *  String doc = doc.writeDocumentToString();
 * </pre>
 *
 * @author Richard Adams
 *
 */
public class SedMLDocument {
    private static final Logger log = LoggerFactory.getLogger(SedMLDocument.class);
    private List<SedMLError> errors = new ArrayList<>();

    private final SedMLDataContainer sedMLDataContainer;

    private boolean validationHasBeenPerformed;

    private static final String jlibsedmlVersion = "3.0.0";
    static final String PROVENANCE = "This file was generated by jlibsedml (version " + jlibsedmlVersion + ").";

    /**
     * No parameter can be null, errors can be an empty list.
     *
     * @param model  A SedML element
     * @param errors A non-null <code>List</code> of {@link SedMLError}
     * @throws IllegalArgumentException if any arg is null.
     */
    public SedMLDocument(SedMLDataContainer model, List<SedMLError> errors) {
        if (null == model) throw new IllegalArgumentException("Cannot create SedMLDocument with a null Model");
        if (null == errors) errors = Collections.emptyList();
        for (SedMLError error : errors) {
            if (null == error) throw new IllegalArgumentException("Sed Errors reported, but Error itself is `null`");
        }
        this.sedMLDataContainer = model;
        this.errors = errors;
    }

    /**
     * Alternative constructor for creating a {@link SedMLDocument}
     *
     * @param sedMLModel An already created SED-ML model object.
     * @throws IllegalArgumentException if any arg is null.
     */
    public SedMLDocument(SedMLDataContainer sedMLModel) {
        this(sedMLModel, new ArrayList<>());
    }

    /**
     * Default constructor creates empty SED-ML element with default version,
     * currently level 1, version 1.
     *
     * @since 1.1
     */
    public SedMLDocument() {
        this(1, 1);
    }

    /**
     *
     * @param level   The SED-ML level (1)
     * @param version The SED-ML version ( 1 or 2)
     * @throws IllegalArgumentException if values are invalid
     * @since 2.2.3
     */
    public SedMLDocument(int level, int version) {
        SedML sedML = new SedML(level, version);
        this.sedMLDataContainer = new SedMLDataContainer(sedML);
        this.sedMLDataContainer.addExtraNamespace(Namespace.getNamespace(SedMLTags.MATHML_NS_PREFIX, SedMLTags.MATHML_NS));
    }

    /**
     * Gets a read-only list of this document's errors.
     *
     * @return An unmodifiable (read-only), non-null list of this document's
     * errors.
     */
    public List<SedMLError> getErrors() {
        return Collections.unmodifiableList(this.errors);
    }

    /**
     * Returns a {@link SedMLValidationReport} if validate() has previously been
     * called on this object, otherwise <code>null</code>.
     *
     * @return A SedMLValidationReport or <code>null</code>.
     */
    public SedMLValidationReport getValidationReport() {
        if (!this.validationHasBeenPerformed) {
            return null;

        } else {
            return new SedMLValidationReport(this.errors, getSedMLDocumentAsString(this.sedMLDataContainer));
        }
    }

    /**
     * A boolean test as to whether the SEDML referenced by this document has
     * errors or not.
     *
     * @return <code>true</code> if this document has at least one validation
     * error.
     */
    public boolean hasErrors() {
        return !this.errors.isEmpty();
    }

    /**
     * Gets the SED-ML model contained in this document.
     *
     * @return A non-null {@link SedMLDataContainer} object
     */
    public SedMLDataContainer getSedMLModel() {
        return this.sedMLDataContainer;
    }

    /**
     * Validates this document. Validation may terminate prematurely if errors
     * are serious ( for example, if validation against the XML schema fails),
     * so the list of errors may not be complete, and new errors may be revealed
     * on subsequent invocations of this method. <br/>
     * This validate method validates an existing object model of SED-ML, and
     * not the original input file. To validate the raw input from an external
     * file, use
     *
     * <pre>
     * Libsedml.validate(InputStream)
     * </pre>
     *
     * @return An unmodifiable, non-null <code>List</code> of {@link SedMLError}
     * .
     * @throws XMLException if the XML generated from the underlying SED-ML object is
     *                      unable to be parsed, is unavailable or unreadable.
     */
    public List<SedMLError> validate() throws XMLException {
        Document doc = this.createDocument(this.writeDocumentToString());
        List<SedMLError> errs = new ValidatorController().validate(this.sedMLDataContainer, doc);
        errs.addAll(this.errors);
        this.errors = errs;
        this.validationHasBeenPerformed = true;
        return this.getErrors();
    }

    /**
     * @see Object#toString()
     */
    public String toString() {
        return String.format("SedML Document for SedML L%dV%d", this.sedMLDataContainer.getSedML().getLevel(), this.sedMLDataContainer.getSedML().getVersion());
    }

    /**
     * Writes out a document to file. This operation will write valid and
     * invalid documents. To check a document is valid, call validate() and
     * hasErrors() before writing the document.
     *
     * @param file A {@link File} that can be written to.
     * @throws IllegalArgumentException if <code>file</code> argument is null
     */
    public void writeDocument(File file) {
        if (null == file) throw new IllegalArgumentException("A valid file must be provided to write a document to!");

        String xmlString = getSedMLDocumentAsString(this.sedMLDataContainer);
        try {
            Libsedml.writeXMLStringToFile(xmlString, file.getAbsolutePath(),
                    true);
        } catch (IOException e) {
            throw new RuntimeException("Unable to write SEDML to file : "
                    + e.getMessage(), e);
        }
    }

    static String getSedMLDocumentAsString(SedMLDataContainer sedRoot) {
        SedMLWriter producer = new SedMLWriter();
        Element root = producer.getXML(sedRoot);

        root.addContent(0, new Comment(PROVENANCE));
        Document sedmlDoc = new Document();
        sedmlDoc.setRootElement(root);
        return SEDMLUtils.xmlToString(sedmlDoc, true);
    }

    /**
     * Writes the document contents to formatted XML format, and returns it as a
     * <code>String</code>.
     *
     * @return A <code>String</code> of XML
     */
    public String writeDocumentToString() {
        return getSedMLDocumentAsString(this.sedMLDataContainer);
    }

    /**
     * Getter for the SED-ML version of this document
     *
     * @return A <code>Version</code> object.
     */
    public Version getVersion() {
        return new Version(this.sedMLDataContainer.getSedML().getLevel(), this.sedMLDataContainer.getSedML().getVersion());
    }

    /**
     * Gets a model variant, by applying whatever changes are defined in a
     * model's List of changes. This operation only performs one set of changes.
     * For example, if 3 models are defined in a SED-ML document: <font
     * style=bold>model1</font>, model2 and model3. If Model 3 is derived from
     * model2, and model2 from model1, then this method will only perform one
     * set of changes. E.g., if model3 is the desired output, then model2 must
     * be supplied as input.
     * <p/>
     * <p>
     * In order for an XPath expression to be applied, the namespace of the XML
     * to which the XPath is evaluated must be known. Since this library is
     * model-agnostic, this method tries to resolve the XPath prefix with a
     * Namespace defined in the model, by looking for the Namespace URI
     * containing the XPath prefix in a case-insensitive match.<br/>
     * For example, an XPath prefix of 'math' will match the namespace
     * 'http://www.w3.org/1998/Math/MathML'. The method <code>
     * canResolveXPathExpressions (String model_ID, final String originalModel);
     * </code> in this class provides a test as to whether prefixes can be
     * resolved.
     * <p/>
     *
     * @param modelID       The id of the SEDML Model element containing the description
     *                      whose changes are to be applied.
     * @param originalModel A String representation of the XML of the model to be altered.
     * @return A String representation of the changed model. The original model
     * will be unchanged by this operation. IF there are no changes, or
     * the model_ID cannot be resolved, the original model will be
     * returned unchanged.
     * @throws XMLException             if XML cannot be parsed or the XPath expression applied.
     * @throws IllegalArgumentException if <code>modelID</code> is not defined in the ListOfModels for
     *                                  this document.
     */
    public static String getChangedModel(SedMLDataContainer sedml, SId modelID, final String originalModel)
            throws XPathExpressionException, XMLException {

        String xmlString;
        SedBase sedBaseFound = sedml.getSedML().searchInModelsFor(modelID);
        if (!(sedBaseFound instanceof Model sedModelFound))
            throw new IllegalArgumentException("Provided ID does not exist as a SedML Model!");
        if (!sedModelFound.hasChanges()) return originalModel;

        List<Change> changes = sedModelFound.getChanges();
        try {
            org.w3c.dom.Document doc = ModelTransformationUtils
                    .getXMLDocumentFromModelString(originalModel);

            XPathFactory xpf = XPathFactory.newInstance();
            XPath xpath = xpf.newXPath();

            for (Change change : changes) {
                Document jdomDoc = SedMLDocument.createDocument(originalModel);
                NamespaceContextHelper nc = new NamespaceContextHelper(jdomDoc);
                nc.process(change.getTargetXPath());
                xpath.setNamespaceContext(nc);
                if (change.getChangeKind().equals(SedMLTags.CHANGE_ATTRIBUTE_KIND)) {
                    ModelTransformationUtils.applyAttributeChange(doc, xpath, change);
                } else if (change.getChangeKind().equals(SedMLTags.REMOVE_XML_KIND)) {
                    ModelTransformationUtils.deleteXMLElement(doc, change.getTargetXPath().getTargetAsString(), xpath);
                } else if (change.getChangeKind().equals(SedMLTags.ADD_XML_KIND)) {
                    AddXML addXML = (AddXML) change;
                    for (Element el : addXML.getNewXML().xml()) {
                        el.setNamespace(Namespace.NO_NAMESPACE);
                        String elAsString = new XMLOutputter().outputString(el);
                        log.debug(elAsString);
                        ModelTransformationUtils.addXMLelement(doc, elAsString,
                                addXML.getTargetXPath().getTargetAsString(),
                                xpath);
                    }
                } else if (change.getChangeKind().equals(
                        SedMLTags.CHANGE_XML_KIND)) {
                    ChangeXML changeXML = (ChangeXML) change;
                    ModelTransformationUtils.changeXMLElement(doc, changeXML
                            .getNewXML(), changeXML.getTargetXPath()
                            .getTargetAsString(), xpath);

                }
            }
            xmlString = ModelTransformationUtils.exportChangedXMLAsString(doc);
        } catch (Exception e) {
            throw new XMLException("Error generating new model"
                    + e.getMessage(), e);
        }
        return xmlString;
    }

    private static org.jdom2.Document createDocument(String sedml) throws XMLException {
        return new XMLUtils().readDoc(sedml);
    }

    /**
     * Boolean test for whether XPath expressions can be mapped to XML
     * namespaces in the model XML.
     *
     * @param modelID id of the sedml model to interrogate
     * @param originalModelXMLStr the string-representation of the XML (SBML) model to validate against
     * @return <code>true</code> if can be mapped, false otherwise.
     * @throws XMLException
     */
    public boolean canResolveXPathExpressions(SId modelID, final String originalModelXMLStr) throws XMLException {
        org.jdom2.Document doc = SedMLDocument.createDocument(originalModelXMLStr);
        SedBase sedBaseFound = this.sedMLDataContainer.getSedML().searchInModelsFor(modelID);
        if (!(sedBaseFound instanceof Model sedModelFound))
            throw new IllegalArgumentException("Provided ID does not exist as a SedML Model!");
        for (Change change : sedModelFound.getChanges()) {
            XPathTarget target = change.getTargetXPath();
            NamespaceContextHelper nc = new NamespaceContextHelper(doc);
            nc.process(target);
            if (!nc.areAllXPathPrefixesMapped(target)) {
                return false;
            }
        }
        return true;
    }
}
